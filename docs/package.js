(function(pkg) {
  (function() {
  var annotateSourceURL, cacheFor, circularGuard, defaultEntryPoint, fileSeparator, generateRequireFn, global, isPackage, loadModule, loadPackage, loadPath, normalizePath, publicAPI, rootModule, startsWith,
    __slice = [].slice;

  fileSeparator = '/';

  global = self;

  defaultEntryPoint = "main";

  circularGuard = {};

  rootModule = {
    path: ""
  };

  loadPath = function(parentModule, pkg, path) {
    var cache, localPath, module, normalizedPath;
    if (startsWith(path, '/')) {
      localPath = [];
    } else {
      localPath = parentModule.path.split(fileSeparator);
    }
    normalizedPath = normalizePath(path, localPath);
    cache = cacheFor(pkg);
    if (module = cache[normalizedPath]) {
      if (module === circularGuard) {
        throw "Circular dependency detected when requiring " + normalizedPath;
      }
    } else {
      cache[normalizedPath] = circularGuard;
      try {
        cache[normalizedPath] = module = loadModule(pkg, normalizedPath);
      } finally {
        if (cache[normalizedPath] === circularGuard) {
          delete cache[normalizedPath];
        }
      }
    }
    return module.exports;
  };

  normalizePath = function(path, base) {
    var piece, result;
    if (base == null) {
      base = [];
    }
    base = base.concat(path.split(fileSeparator));
    result = [];
    while (base.length) {
      switch (piece = base.shift()) {
        case "..":
          result.pop();
          break;
        case "":
        case ".":
          break;
        default:
          result.push(piece);
      }
    }
    return result.join(fileSeparator);
  };

  loadPackage = function(pkg) {
    var path;
    path = pkg.entryPoint || defaultEntryPoint;
    return loadPath(rootModule, pkg, path);
  };

  loadModule = function(pkg, path) {
    var args, content, context, dirname, file, module, program, values;
    if (!(file = pkg.distribution[path])) {
      throw "Could not find file at " + path + " in " + pkg.name;
    }
    if ((content = file.content) == null) {
      throw "Malformed package. No content for file at " + path + " in " + pkg.name;
    }
    program = annotateSourceURL(content, pkg, path);
    dirname = path.split(fileSeparator).slice(0, -1).join(fileSeparator);
    module = {
      path: dirname,
      exports: {}
    };
    context = {
      require: generateRequireFn(pkg, module),
      global: global,
      module: module,
      exports: module.exports,
      PACKAGE: pkg,
      __filename: path,
      __dirname: dirname
    };
    args = Object.keys(context);
    values = args.map(function(name) {
      return context[name];
    });
    Function.apply(null, __slice.call(args).concat([program])).apply(module, values);
    return module;
  };

  isPackage = function(path) {
    if (!(startsWith(path, fileSeparator) || startsWith(path, "." + fileSeparator) || startsWith(path, ".." + fileSeparator))) {
      return path.split(fileSeparator)[0];
    } else {
      return false;
    }
  };

  generateRequireFn = function(pkg, module) {
    var fn;
    if (module == null) {
      module = rootModule;
    }
    if (pkg.name == null) {
      pkg.name = "ROOT";
    }
    if (pkg.scopedName == null) {
      pkg.scopedName = "ROOT";
    }
    fn = function(path) {
      var otherPackage;
      if (typeof path === "object") {
        return loadPackage(path);
      } else if (isPackage(path)) {
        if (!(otherPackage = pkg.dependencies[path])) {
          throw "Package: " + path + " not found.";
        }
        if (otherPackage.name == null) {
          otherPackage.name = path;
        }
        if (otherPackage.scopedName == null) {
          otherPackage.scopedName = "" + pkg.scopedName + ":" + path;
        }
        return loadPackage(otherPackage);
      } else {
        return loadPath(module, pkg, path);
      }
    };
    fn.packageWrapper = publicAPI.packageWrapper;
    fn.executePackageWrapper = publicAPI.executePackageWrapper;
    return fn;
  };

  publicAPI = {
    generateFor: generateRequireFn,
    packageWrapper: function(pkg, code) {
      return ";(function(PACKAGE) {\n  var src = " + (JSON.stringify(PACKAGE.distribution.main.content)) + ";\n  var Require = new Function(\"PACKAGE\", \"return \" + src)({distribution: {main: {content: src}}});\n  var require = Require.generateFor(PACKAGE);\n  " + code + ";\n})(" + (JSON.stringify(pkg, null, 2)) + ");";
    },
    executePackageWrapper: function(pkg) {
      return publicAPI.packageWrapper(pkg, "require('./" + pkg.entryPoint + "')");
    },
    loadPackage: loadPackage
  };

  if (typeof exports !== "undefined" && exports !== null) {
    module.exports = publicAPI;
  } else {
    global.Require = publicAPI;
  }

  startsWith = function(string, prefix) {
    return string.lastIndexOf(prefix, 0) === 0;
  };

  cacheFor = function(pkg) {
    if (pkg.cache) {
      return pkg.cache;
    }
    Object.defineProperty(pkg, "cache", {
      value: {}
    });
    return pkg.cache;
  };

  annotateSourceURL = function(program, pkg, path) {
    return "" + program + "\n//# sourceURL=" + pkg.scopedName + "/" + path;
  };

  return publicAPI;

}).call(this);

  window.require = Require.generateFor(pkg);
})({
  "source": {
    "LICENSE": {
      "path": "LICENSE",
      "content": "MIT License\n\nCopyright (c) 2016 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "mode": "100644",
      "type": "blob"
    },
    "README.md": {
      "path": "README.md",
      "content": "# zine\nDIY E-Zine and Operating System\n",
      "mode": "100644",
      "type": "blob"
    },
    "TODO.md": {
      "path": "TODO.md",
      "content": "TODO\n====\n\nSystem Features\n---------------\n[x] File Browser\n\n[x] App Associations\n\n[x] File Context Menu\n\n[x] Folders\n\n[x] Desktop Icons\n\n[ ] Desktop Background\n\n[ ] Help Documentation\n\n[ ] Compiler\n\n[x] Require/Include Local Files\n\n[ ] Custom Models/Views\n\nApplications\n------------\n\nSpreadsheet\n- Save/Load Data\n- Custom Cell Views\n- Data Relationships\n- Forms\n\nTactics Game Sandbox\n\nMarkdown / Wiki\n\nImage Munger\n\nNetwork Social\n--------------\n\n[ ] CDN\n\n[x] Comments\n\n[ ] Sharing\n\n[ ] Remote Files\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/audio-bro.coffee": {
      "path": "apps/audio-bro.coffee",
      "content": "# Play Audio\n\nFileIO = require \"../os/file-io\"\nModel = require \"model\"\n\nmodule.exports = ->\n  # Global system\n  {ContextMenu, MenuBar, Modal, Progress, Util:{parseMenu}, Window} = system.UI\n  {Achievement} = system\n\n  Achievement.unlock \"Pump up the jam\"\n\n  audio = document.createElement 'audio'\n  audio.controls = true\n  audio.autoplay = true\n\n  handlers = Model().include(FileIO).extend\n    loadFile: (blob) ->\n      audio.src = URL.createObjectURL blob\n\n    exit: ->\n      windowView.element.remove()\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [F]ile\n        [O]pen\n        -\n        E[x]it\n    \"\"\"\n    handlers: handlers\n\n  windowView = Window\n    title: \"Audio Bro\"\n    content: audio\n    menuBar: menuBar.element\n    width: 308\n    height: 80\n\n  windowView.loadFile = handlers.loadFile\n\n  return windowView\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/chateau.coffee": {
      "path": "apps/chateau.coffee",
      "content": "IFrameApp = require \"../lib/iframe-app\"\n\nmodule.exports = ->\n  {Achievement} = system\n\n  app = IFrameApp\n    src: \"https://danielx.net/chateau/\"\n    width: 960\n    height: 540\n    title: \"Chateau\"\n\n  app.on \"event\", (name) ->\n    switch name\n      when \"login\"\n        Achievement.unlock \"Enter the Chateau\"\n      when \"custom-avatar\"\n        Achievement.unlock \"Puttin' on the Ritz\"\n      when \"custom-background\"\n        Achievement.unlock \"Paint the town red\"\n      when \"file-upload\"\n        Achievement.unlock \"It's in the cloud\"\n\n  return app\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/contrasaurus.coffee": {
      "path": "apps/contrasaurus.coffee",
      "content": "IFrameApp = require \"../lib/iframe-app\"\n\nmodule.exports = ->\n  {Achievement} = system\n\n  app = IFrameApp\n    src: \"https://contrasaur.us/\"\n    width: 960\n    height: 540\n    title: \"Contrasaurus: Defender of the American Dream\"\n\n  Achievement.unlock \"Rawr\"\n\n  app.on \"event\", (name) ->\n    switch name\n      when \"win\"\n        Achievement.unlock \"A winner is you\"\n\n  return app\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/dungeon-of-sadness.coffee": {
      "path": "apps/dungeon-of-sadness.coffee",
      "content": "Model = require \"model\"\n\nmodule.exports = ->\n  {ContextMenu, MenuBar, Modal, Observable, Progress, Table, Util:{parseMenu}, Window} = system.UI\n\n  frame = document.createElement \"iframe\"\n  frame.src = \"https://danielx.net/ld33/\"\n\n  system.Achievement.unlock \"The dungeon is in our heart\"\n\n  windowView = Window\n    title: \"Dungeon of Sadness\"\n    content: frame\n    menuBar: null\n    width: 648\n    height: 507\n\n  return windowView\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/explorer.coffee": {
      "path": "apps/explorer.coffee",
      "content": "# Explorer File Browser\n#\n# Explore the file system like adventureres of old!\n# TODO: Drag and drop files and folders\n# TODO: Select multiple\n# TOOD: Keyboard Input\n# TODO: Style file types\n\nDrop = require \"../lib/drop\"\nFileTemplate = require \"../templates/file\"\nFolderTemplate = require \"../templates/folder\"\n\n{emptyElement} = require \"../util\"\n\nmodule.exports = Explorer = (options={}) ->\n  {ContextMenu, MenuBar, Modal, Progress, Util:{parseMenu}, Window} = system.UI\n  {path} = options\n  path ?= '/'\n\n  explorer = document.createElement \"explorer\"\n\n  Drop explorer, (e) ->\n    files = e.dataTransfer.files\n\n    if files.length\n      files.forEach (file) ->\n        newPath = path + file.name\n        system.writeFile(newPath, file, true)\n\n  contextMenuFor = (file, e) ->\n    return if e.defaultPrevented\n    e.preventDefault()\n\n    contextMenuHandlers =\n      open: ->\n        system.open(file)\n      openWith: -> #TODO\n      cut: -> #TODO\n      copy: -> #TODO\n      delete: ->\n        system.deleteFile(file.path)\n      rename: ->\n        Modal.prompt \"Filename\", file.path\n        .then (newPath) ->\n          if newPath\n            system.deleteFile(file.path)\n            system.writeFile(newPath, file.blob)\n      properties: -> #TODO\n      editMIMEType: ->\n        Modal.prompt \"MIME Type\", file.type\n        .then (newType) ->\n          if newType\n            system.updateFile file.path,\n              type: newType\n            .then console.log\n\n    openers = system.openersFor(file)\n\n    openerOptions = openers.map ({name, fn}, i) ->\n      handlerName = \"opener#{i}\"\n      contextMenuHandlers[handlerName] = ->\n        fn(file)\n\n      \"  #{name} -> #{handlerName}\"\n    .join(\"\\n\")\n\n    openWithMenu = \"\"\n    if openers.length > 0\n      openWithMenu = \"\"\"\n        Open With\n        #{openerOptions}\n      \"\"\"\n\n    # TODO: Open With Options\n    # TODO: Set Mime Type\n    contextMenu = ContextMenu\n      items: parseMenu \"\"\"\n        Open\n        #{openWithMenu}\n        -\n        Cut\n        Copy\n        -\n        Delete\n        Rename\n        -\n        Edit MIME Type\n        Properties\n      \"\"\"\n      handlers: contextMenuHandlers\n\n\n    contextMenu.display\n        inElement: document.body\n        x: e.pageX\n        y: e.pageY\n\n  contextMenuForFolder = (folder, e) ->\n    return if e.defaultPrevented\n    e.preventDefault()\n\n    # TODO: Cut/Copy\n    contextMenu = ContextMenu\n      items: parseMenu \"\"\"\n        Open\n        -\n        Cut\n        Copy\n        -\n        Delete\n        Rename\n        -\n        Properties\n      \"\"\"\n      handlers:\n        open: ->\n          addWindow(folder.path)\n        delete: -> # TODO: Delete all files under folder\n        rename: ->\n          ;# TODO: Rename all files under folder (!)\n          # May want to think about inodes or something that makes this simpler\n        properties: -> # TODO\n\n    contextMenu.display\n        inElement: document.body\n        x: e.pageX\n        y: e.pageY\n\n  update = ->\n    system.fs.list(path)\n    .then (files) ->\n      emptyElement explorer\n\n      addedFolders = {}\n\n      files.forEach (file) ->\n        if file.relativePath.match /\\// # folder\n          folderPath = file.relativePath.replace /\\/.*$/, \"\"\n          addedFolders[folderPath] = true\n          return\n\n        file.dblclick = ->\n          console.log \"dblclick\", file\n          system.open file\n\n        file.contextmenu = (e) ->\n          contextMenuFor(file, e)\n\n        fileElement = FileTemplate file\n        if file.type.match /^image\\//\n          url = URL.createObjectURL file.blob\n          fileElement.querySelector('icon').style.backgroundImage = \"url(#{url})\"\n\n        explorer.appendChild fileElement\n\n      Object.keys(addedFolders).forEach (folderName) ->\n        folder =\n          path: \"#{path}#{folderName}/\"\n          relativePath: folderName\n          contextmenu: (e) ->\n            contextMenuForFolder(folder, e)\n          dblclick: ->\n            # Open folder in new window\n            addWindow(folder.path)\n\n        folderElement = FolderTemplate folder\n        explorer.insertBefore(folderElement, explorer.firstChild)\n\n  update()\n\n  # Refresh files when they change\n  system.fs.on \"write\", (path) -> update()\n  system.fs.on \"delete\", (path) -> update()\n  system.fs.on \"update\", (path) -> update()\n\n  addWindow = (path) ->\n    element = document.createElement \"container\"\n\n    element.appendChild Explorer\n      path: path\n\n    windowView = Window\n      title: path\n      content: element\n      menuBar: null\n      width: 640\n      height: 480\n\n    document.body.appendChild windowView.element\n\n  return explorer\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/filter.coffee": {
      "path": "apps/filter.coffee",
      "content": "# View and Manipulate Images\n\nFileIO = require \"../os/file-io\"\nModel = require \"model\"\n\nmodule.exports = ->\n  # Global system\n  {ContextMenu, MenuBar, Modal, Progress, Util:{parseMenu}, Window} = system.UI\n\n  system.Achievement.unlock \"Look at that\"\n\n  canvas = document.createElement 'canvas'\n  context = canvas.getContext('2d')\n\n  modalForm = system.compileTemplate \"\"\"\n    form\n      label\n        h2 Width\n        input(name=\"width\")\n      label\n        h2 Height\n        input(name=\"height\")\n  \"\"\"\n\n  handlers = Model().include(FileIO).extend\n    loadFile: (blob) ->\n      Image.fromBlob blob\n      .then (img) ->\n        canvas.width = img.width\n        canvas.height = img.height\n        context.drawImage(img, 0, 0)\n\n    saveData: ->\n      new Promise (resolve) ->\n        canvas.toBlob resolve\n\n    exit: ->\n      windowView.element.remove()\n\n    crop: ->\n      Modal.form modalForm()\n      .then console.log\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [F]ile\n        [O]pen\n        [S]ave\n        Save [A]s\n        -\n        E[x]it\n      [E]dit\n        [C]rop\n        [F]ilter\n    \"\"\"\n    handlers: handlers\n\n  windowView = Window\n    title: \"Spectacle Image Viewer\"\n    content: canvas\n    menuBar: menuBar.element\n    width: 640\n    height: 480\n\n  windowView.loadFile = handlers.loadFile\n\n  return windowView\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/markdown.coffee": {
      "path": "apps/markdown.coffee",
      "content": "# Render Markdown\n\nFileIO = require \"../os/file-io\"\nModel = require \"model\"\n\nmodule.exports = ->\n  # Global system\n  {ContextMenu, MenuBar, Modal, Progress, Util:{parseMenu}, Window} = system.UI\n\n  container = document.createElement 'container'\n  container.style.padding = \"1em\"\n\n  handlers = Model().include(FileIO).extend\n    loadFile: (blob) ->\n      blob.readAsText()\n      .then (textContent) ->\n        container.innerHTML = marked(textContent)\n\n    saveData: ->\n\n    exit: ->\n      windowView.element.remove()\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [F]ile\n        [O]pen\n        -\n        E[x]it\n    \"\"\"\n    handlers: handlers\n\n  windowView = Window\n    title: \"Markdown\"\n    content: container\n    menuBar: menuBar.element\n    width: 720\n    height: 480\n\n  windowView.loadFile = handlers.loadFile\n\n  return windowView\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/notepad.coffee": {
      "path": "apps/notepad.coffee",
      "content": "FileIO = require \"../os/file-io\"\nModel = require \"model\"\n\nmodule.exports = ->\n  # Global system\n  {ContextMenu, MenuBar, Modal, Progress, Util:{parseMenu}, Window} = system.UI\n\n  system.Achievement.unlock \"Notepad.exe\"\n\n  exec = (cmd) ->\n    ->\n      textarea.focus()\n      document.execCommand(cmd)\n\n  TODO = -> console.log \"TODO\"\n\n  textarea = document.createElement \"textarea\"\n  textarea.spellcheck = false\n\n  handlers = Model().include(FileIO).extend\n    loadFile: (blob, path) ->\n      blob.readAsText()\n      .then (text) ->\n        handlers.currentPath path\n        textarea.value = text\n    newFile: ->\n      textarea.value = \"\"\n    saveData: ->\n      data = new Blob [textarea.value],\n        type: \"text/plain\"\n\n      return Promise.resolve data\n\n    # Printing\n    pageSetup: TODO\n    print: TODO\n\n    exit: ->\n      windowView.element.remove()\n\n    undo: exec \"undo\"\n    redo: exec \"redo\"\n    cut: exec \"cut\"\n    copy: exec \"copy\"\n    # NOTE: Can't paste from system clipboard for security reasons\n    # Can probably paste from an in-app clipboard equivalent\n    paste: exec \"paste\"\n    delete: exec \"delete\"\n\n    find: TODO\n    findNext: TODO\n    replace: TODO\n    goTo: TODO\n\n    selectAll: ->\n      textarea.select()\n\n    timeDate: ->\n      textarea.focus()\n      dateText = (new Date).toString().split(\" \").slice(0, -4).join(\" \")\n      document.execCommand(\"insertText\", false, dateText)\n\n    wordWrap: TODO\n\n    font: ->\n      Modal.prompt \"Font\", textarea.style.fontFamily or \"monospace\"\n      .then (font) ->\n        if font\n          textarea.style.fontFamily = font\n\n    statusBar: TODO\n    viewHelp: TODO\n    aboutNotepad: TODO\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [F]ile\n        [N]ew\n        [O]pen\n        [S]ave\n        Save [A]s\n        -\n        Page Set[u]p\n        [P]rint\n        -\n        E[x]it\n      [E]dit\n        [U]ndo\n        Redo\n        -\n        Cu[t]\n        [C]opy\n        [P]aste\n        De[l]ete\n        -\n        [F]ind\n        Find [N]ext\n        [R]eplace\n        [G]o To\n        -\n        Select [A]ll\n        Time/[D]ate\n      F[o]rmat\n        [W]ord Wrap\n        [F]ont...\n      [V]iew\n        [S]tatus Bar\n      [H]elp\n        View [H]elp\n        -\n        [A]bout Notepad\n    \"\"\"\n    handlers: handlers\n\n  windowView = Window\n    title: ->\n      path = handlers.currentPath()\n      if path\n        \"Notepad.exe [#{path}]\"\n      else\n        \"Notepad.exe\"\n    content: textarea\n    menuBar: menuBar.element\n    width: 640\n    height: 480\n\n  windowView.loadFile = handlers.loadFile\n\n  return windowView\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/pixel.coffee": {
      "path": "apps/pixel.coffee",
      "content": "Model = require \"model\"\nPostmaster = require \"postmaster\"\nFileIO = require \"../os/file-io\"\n\nmodule.exports = ->\n  {ContextMenu, MenuBar, Modal, Observable, Progress, Table, Util:{parseMenu}, Window} = system.UI\n\n  frame = document.createElement \"iframe\"\n  frame.src = \"https://danielx.net/pixel-editor/\"\n\n  # TODO: Gross hack to keep track of waiting for child window to load\n  # May want to move it into the postmaster library\n  resolveLoaded = null\n  loadedPromise = new Promise (resolve) ->\n    resolveLoaded = resolve\n\n  postmaster = Postmaster()\n  postmaster.remoteTarget = -> frame.contentWindow\n  Object.assign postmaster,\n    childLoaded: ->\n      console.log \"child loaded\"\n      resolveLoaded()\n    save: ->\n      handlers.save()\n\n  handlers = Model().include(FileIO).extend\n    loadFile: (blob) ->\n      loadedPromise.then ->\n        postmaster.invokeRemote \"loadFile\", blob\n    newFile: ->\n    saveData: ->\n      postmaster.invokeRemote \"getBlob\"\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [F]ile\n        [N]ew\n        [O]pen\n        [S]ave\n        Save [A]s\n        -\n        E[x]it\n      [H]elp\n        View [H]elp\n        -\n        [A]bout\n    \"\"\"\n    handlers: handlers\n\n  windowView = Window\n    title: Observable \"Pixie Paint\"\n    content: frame\n    menuBar: menuBar.element\n    width: 640\n    height: 480\n\n  windowView.loadFile = handlers.loadFile\n\n  system.Achievement.unlock \"Pixel perfect\"\n\n  return windowView\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/spreadsheet.coffee": {
      "path": "apps/spreadsheet.coffee",
      "content": "FileIO = require \"../os/file-io\"\nModel = require \"model\"\n\nmodule.exports = ->\n  {ContextMenu, MenuBar, Modal, Observable, Progress, Table, Util:{parseMenu}, Window} = system.UI\n\n  system.Achievement.unlock \"Microsoft Access 97\"\n\n  sourceData = []\n\n  headers = [\"id\", \"name\", \"color\"]\n\n  RowModel = (datum) ->\n    Model(datum).attrObservable headers...\n\n  models = sourceData.map RowModel\n\n  InputTemplate = require \"../templates/input\"\n  RowElement = (datum) ->\n    tr = document.createElement \"tr\"\n    types = [\n      \"number\"\n      \"text\"\n      \"color\"\n    ]\n\n    headers.forEach (key, i) ->\n      td = document.createElement \"td\"\n      td.appendChild InputTemplate\n        value: datum[key]\n        type: types[i]\n\n      tr.appendChild td\n\n    return tr\n\n  {element} = tableView = Table {\n    data: models\n    RowElement: RowElement\n    headers: headers\n  }\n\n  handlers = Model().include(FileIO).extend\n    loadFile: (blob) ->\n      blob.readAsJSON()\n      .then (json) ->\n        console.log json\n\n        unless Array.isArray json\n          throw new Error \"Data must be an array\"\n\n        sourceData = json\n        # Update models data\n        models.splice(0, models.length, sourceData.map(RowModel)...)\n\n        # Re-render\n        tableView.render()\n\n    newFile: -> # TODO\n    saveData: ->\n      Promise.resolve new Blob [JSON.stringify(sourceData)],\n        type: \"application/json\"\n\n    about: ->\n      Modal.alert \"Spreadsheet v0.0.1 by Daniel X Moore\"\n    insertRow: ->\n      # TODO: Data template\n      datum =\n        id: 0\n        name: \"new\"\n        color: \"#FF00FF\"\n\n      sourceData.push datum\n      models.push RowModel(datum)\n\n      # Re-render\n      tableView.render()\n    exit: ->\n      windowView.element.remove()\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [F]ile\n        [N]ew\n        [O]pen\n        [S]ave\n        Save [A]s\n        -\n        E[x]it\n      Insert\n        Row -> insertRow\n      Help\n        About\n    \"\"\"\n    handlers: handlers\n\n  windowView = Window\n    title: \"MS Access 97 [DEMO VERSION]\"\n    content: element\n    menuBar: menuBar.element\n    width: 640\n    height: 480\n\n  windowView.loadFile = handlers.loadFile\n\n  return windowView\n",
      "mode": "100644",
      "type": "blob"
    },
    "apps/text-editor.coffee": {
      "path": "apps/text-editor.coffee",
      "content": "Model = require \"model\"\nFileIO = require \"../os/file-io\"\n\nace.require(\"ace/ext/language_tools\")\n\nextraModes =\n  jadelet: \"jade\"\n\nmode = (mode) ->\n  extraModes[mode] or mode\n\nmodule.exports = ->\n  {ContextMenu, MenuBar, Modal, Observable, Progress, Table, Util:{parseMenu}, Window} = system.UI\n\n  system.Achievement.unlock \"Notepad.exe\"\n\n  aceWrap = document.createElement \"div\"\n  aceWrap.style.width = aceWrap.style.height = \"100%\"\n\n  aceElement = document.createElement \"div\"\n  aceElement.style.width = aceElement.style.height = \"100%\"\n\n  aceWrap.appendChild aceElement\n\n  aceEditor = ace.edit aceElement\n  aceEditor.$blockScrolling = Infinity\n  aceEditor.setOptions\n    fontSize: \"16px\"\n    enableBasicAutocompletion: true\n    enableLiveAutocompletion: true\n    highlightActiveLine: true\n\n  session = aceEditor.getSession()\n  session.setUseSoftTabs true\n  session.setTabSize 2\n\n  mode = \"coffee\"\n  session.setMode(\"ace/mode/#{mode}\")\n\n  global.aceEditor = aceEditor\n\n  initSession = (file, path) ->\n    # TODO: Update window title\n    file.readAsText()\n    .then (content) ->\n      if path\n        handlers.currentFile path\n      session.setValue(content)\n      # TODO: Correct modes\n      mode = \"coffee\"\n      session.setMode(\"ace/mode/#{mode}\")\n\n  handlers = Model().include(FileIO).extend\n    loadFile: initSession\n    newFile: ->\n      session.setValue \"\"\n    saveData: ->\n      # TODO: Maintain proper mime type\n      data = new Blob [session.getValue()],\n        type: \"text/plain\"\n\n      return Promise.resolve data\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [F]ile\n        [N]ew\n        [O]pen\n        [S]ave\n        Save [A]s\n        -\n        E[x]it\n      [H]elp\n        View [H]elp\n        -\n        [A]bout\n    \"\"\"\n    handlers: handlers\n\n  windowView = Window\n    title: Observable \"Ace\"\n    content: aceWrap\n    menuBar: menuBar.element\n    width: 640\n    height: 480\n\n  windowView.loadFile = initSession\n\n  windowView.on \"resize\", ->\n    aceEditor.resize()\n\n  return windowView\n",
      "mode": "100644",
      "type": "blob"
    },
    "extensions.coffee": {
      "path": "extensions.coffee",
      "content": "# Add some utility readers to the Blob API\nBlob::readAsText = ->\n  file = this\n\n  new Promise (resolve, reject) ->\n    reader = new FileReader\n    reader.onload = ->\n      resolve reader.result\n    reader.onerror = reject\n    reader.readAsText(file)\n\nBlob::readAsJSON = ->\n  @readAsText()\n  .then JSON.parse\n\nBlob::readAsDataURL = ->\n  file = this\n\n  new Promise (resolve, reject) ->\n    reader = new FileReader\n    reader.onload = ->\n      resolve reader.result\n    reader.onerror = reject\n    reader.readAsDataURL(file)\n\n# Load an image from a blob returning a promise that is fulfilled with the\n# loaded image or rejected with an error\nImage.fromBlob = (blob) ->\n  new Promise (resolve, reject) ->\n    img = new Image\n    img.onload = ->\n      resolve img\n    img.onerror = reject\n\n    img.src = URL.createObjectURL blob\n\nFileList::forEach ?= (args...) ->\n  Array::forEach.apply(this, args)\n",
      "mode": "100644",
      "type": "blob"
    },
    "feedback.coffee": {
      "path": "feedback.coffee",
      "content": "# Open a feedback form\nmodule.exports = ->\n  iframe = document.createElement \"iframe\"\n  iframe.src = \"https://docs.google.com/forms/d/e/1FAIpQLSfAK8ZYmMd4-XsDqyTK4soYGWApGD9R33nReuqwG-TxjXaGFg/viewform?embedded=true\"\n\n  Window = system.UI.Window\n\n  windowView = Window\n    title: \"Whimsy Space Feedback\"\n    content: iframe\n    menuBar: null\n    width: 600\n    height: 500\n\n  system.Achievement.unlock \"We value your input\"\n\n  document.body.appendChild windowView.element\n",
      "mode": "100644",
      "type": "blob"
    },
    "issues/2016-12.coffee": {
      "path": "issues/2016-12.coffee",
      "content": "Notepad = require \"../apps/notepad\"\nCommentFormTemplate = require \"../social/comment-form\"\nCommentsTemplate = require \"../social/comments\"\n\nAjax = require \"ajax\"\najax = Ajax()\n\nissueTag = \"2016-12\"\n\nmodule.exports = ->\n  {ContextMenu, MenuBar, Modal, Progress, Util:{parseMenu}, Window} = system.UI\n\n  system.Achievement.unlock \"Issue 1\"\n\n  img = document.createElement \"img\"\n  img.src = \"https://68.media.tumblr.com/6a141d69564a29ac7d4071df5d519808/tumblr_o0rbb4TA1k1urr1ryo1_500.gif\"\n\n  handlers =\n    waitAroundForABit: ->\n      initialMessage = \"Waiting\"\n      progressView = Progress\n        value: 0\n        max: 2\n        message: initialMessage\n\n      Modal.show progressView.element,\n        cancellable: false\n\n      intervalId = setInterval ->\n        newValue = progressView.value() + 1/60\n        ellipsesCount = Math.floor(newValue * 4) % 4\n        ellipses = [0...ellipsesCount].map ->\n          \".\"\n        .join(\"\")\n        progressView.value(newValue)\n        progressView.message(initialMessage + ellipses)\n        if newValue > 2\n          system.Achievement.unlock \"No rush\"\n          clearInterval intervalId\n          Modal.hide()\n      , 15\n    comment: ->\n      Modal.form CommentFormTemplate\n        area: issueTag\n      .then (data) ->\n        ajax\n          url: \"https://whimsy-space.gomix.me/comments\"\n          data: JSON.stringify(data)\n          headers:\n            \"Content-Type\": \"application/json\"\n          method: \"POST\"\n      .then ->\n        handlers.viewComments()\n\n    viewComments: ->\n      ajax.getJSON \"https://whimsy-space.gomix.me/comments/#{issueTag}\"\n      .then (data) ->\n        data = data.reverse()\n\n        if data.length is 0\n          data = [{\n            body: \"no comments\"\n            author: \"mgmt\"\n          }]\n\n        Modal.show CommentsTemplate data\n\n    like: ->\n      Modal.alert \"I like you too, but we don't have a facebook or anything yet :)\"\n    subscribe: ->\n      require(\"../mailchimp\").show()\n    notepadexe: ->\n      app = Notepad()\n      document.body.appendChild app.element\n    mSAccess97: ->\n      app = Spreadsheet()\n      document.body.appendChild app.element\n    mysterySmell: ->\n      system.Achievement.unlock \"Cover-2-cover\"\n\n      div = document.createElement \"div\"\n      div.textContent = require \"../stories/mystery-smell\"\n      div.style.padding = \"1em\"\n      div.style.whiteSpace = \"pre-wrap\"\n      div.style.textAlign = \"justify\"\n      storyWindow = Window\n        title: \"Mystery Smell\"\n        content: div\n        width: 380\n        height: 480\n      document.body.appendChild storyWindow.element\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [H]ello\n        [W]ait Around For A Bit\n      [A]pps\n        [N]otepad.exe\n      [S]tories\n        [M]ystery Smell\n      S[o]cial Media\n        [V]iew Comments\n        [C]omment\n        [L]ike\n        [S]ubscribe\n    \"\"\"\n    handlers: handlers\n\n  windowView = Window\n    title: \"ZineOS Volume 1 | Issue 1 | December 2016\"\n    content: img\n    menuBar: menuBar.element\n    width: 508\n    height: 604\n\n  document.body.appendChild windowView.element\n",
      "mode": "100644",
      "type": "blob"
    },
    "issues/2017-02.coffee": {
      "path": "issues/2017-02.coffee",
      "content": "Achievement = require \"../lib/achievement\"\nModel = require \"model\"\nChateau = require \"../apps/chateau\"\nPixiePaint = require \"../apps/pixel\"\nSpreadsheet = require \"../apps/spreadsheet\"\nTextEditor = require \"../apps/text-editor\"\n\nSocial = require \"../social/social\"\n\n{parentElementOfType, emptyElement} = require \"../util\"\n\nmodule.exports = ->\n  {ContextMenu, MenuBar, Modal, Progress, Util:{parseMenu}, Window} = system.UI\n\n  container = document.createElement \"container\"\n\n  system.Achievement.unlock \"Issue 2\"\n\n  system.writeFile \"issue-2/around.md\", new Blob [require \"../stories/around-the-world\"], type: \"text/markdown\"\n  system.writeFile \"issue-2/provision.txt\", new Blob [require \"../stories/provision\"], type: \"text/plain\"\n  system.writeFile \"issue-2/dungeon-dog.txt\", new Blob [require \"../stories/dungeon-dog\"], type: \"text/plain\"\n  system.writeFile \"issue-2/dsad.exe\", new Blob [\"\"], type: \"application/exe\"\n\n  pages =\n    front: \"\"\"\n      a(href=\"#vista\")\n        img(src=\"https://s-media-cache-ak0.pinimg.com/originals/a3/ba/56/a3ba56cef667d14b54023cd624d4e070.jpg\")\n    \"\"\"\n    vista: \"\"\"\n      a(href=\"#table\")\n        img(width=640 height=\"auto\" src=\"https://books.google.com/books/content?id=2cgDAAAAMBAJ&rview=1&pg=PA10&img=1&zoom=3&hl=en&sig=ACfU3U3477L46r0KxSQusJrQ6w9qxIQ70w&w=1280\")\n    \"\"\"\n    table: \"\"\"\n      div(style=\"padding: 1em;\")\n        h1 Table of Contents\n        ul\n          li\n            a(href=\"#front\") Cover\n          li\n            a(href=\"#vista\") Excerpt from Windows Vista Magazine\n          li\n            a(href=\"#table\") Table of Contents\n          li\n            a(href=\"#random\") Random Thoughts\n          li\n            a(href=\"#cheevos\") Cheevos\n          li\n            a(href=\"#contributors\") Contributors\n    \"\"\"\n    random: \"\"\"\n      div(style=\"padding: 1em;\")\n        h1 Random Thoughts\n        p Don't you hate it when you're cooking something and you look at the stove clock and think it's 3:75 and you're late for your appointment but it was just the temperature and also 3:75 isn't even a real time?\n        p I suggest you bone up a bit on torts before the next attempt at the bar exam.\n        p Does anyone remember thepalace.com avatar based chat and virtual worlds?\n        p Those spreadsheets you like are going back in style.\n    \"\"\"\n    cheevos: \"\"\"\n      div(style=\"padding: 1em;\")\n        h1 Cheevos\n\n        p No matter if you guy/girl or whatever, Cheevos impress people. It's almost like saying 'Well, I got tons of Cheevos. There are tons of people online that are interested and respect me.\"\n\n        p You might be thinking 'Oh that's complete BS, I personally don't care about Cheevos when dating'. And yeah, you are probably telling the truth, but it's in your sub-concious.  Sort of like how girls always like the bad guy, but never admit it.\n\n        p Braggin about your Cheevos sometimes makes you look conceited, but that's a good thing.  It like how celebraties look conceited because they're rolling VIP into clubs and you're stuck in line.\n\n        p 'Brewer' asks 'What happens if you're cheevo talking at a bar, club or party and someone says they have more cheevos that you?'\n\n        p Well, hopefully they are just hating and are lying. First look up their score with your cellphone, make sure you have a page bookmarked where you can check. If you catch them in a lie, you look even better. If they are telling the truth and have more Cheevos than you, leave. Nothing else you can do. Buy the person a drink and leave, unless you're willing to look 2nd best. If you brought a date, odds are she's going to be impressed with the higher gamer score and ditch you. Get out as soon as you can and go to some other party.\n\n        p\n          a(href=\"http://cheevos.com\") Learn more about cheevos from Bboy360 at cheevos.com\n\n    \"\"\"\n    contributors: \"\"\"\n      div(style=\"padding: 1em;\")\n        h1 Contributors\n        ul\n          li Daniel X\n          li Lan\n          li pketh\n          li Mayor\n          li and you!\n\n        p\n          a(href=\"#table\") Return to table of contents\n    \"\"\"\n\n  Object.keys(pages).forEach (pageName) ->\n    value = pages[pageName]\n    pages[pageName] = system.compileTemplate(value)({})\n\n  pages.cheevos.appendChild system.Achievement.progressView()\n\n  handlers = Model().include(Social).extend\n    area: ->\n      \"2017-01\"\n    mSAccess97: ->\n      app = Spreadsheet(system)\n      document.body.appendChild app.element\n    textEditor: ->\n      app = TextEditor(system)\n      document.body.appendChild app.element\n    pixiePaint: ->\n      app = PixiePaint(system)\n      document.body.appendChild app.element\n    chateau: ->\n      app = Chateau(system)\n      document.body.appendChild app.element\n    credits: ->\n      displayPage \"contributors\"\n    tableofContents: ->\n      displayPage \"table\"\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [A]pps\n        [T]ext Editor\n        [P]ixie Paint\n      #{Social.menuText}\n      H[e]lp\n        [T]able of Contents\n        [C]redits\n    \"\"\"\n    handlers: handlers\n\n  windowView = Window\n    title: \"ZineOS Volume 1 | Issue 2 | ENTER THE DUNGEON | February 2017\"\n    content: container\n    menuBar: menuBar.element\n    width: 1228\n    height: 936\n    x: 32\n    y: 32\n\n  windowView.element.addEventListener \"click\", (e) ->\n    anchor = parentElementOfType(\"a\", e.target)\n\n    if anchor\n      next = anchor.getAttribute('href')\n\n      if next.match /^\\#/\n        e.preventDefault()\n        page = next.substr(1)\n\n        displayPage(page)\n\n  currentPage = \"front\"\n\n  visited = {}\n\n  displayPage = (page) ->\n    return unless page\n\n    visited[page] = true\n\n    if Object.keys(visited).length is Object.keys(pages).length\n      system.Achievement.unlock \"Cover-2-cover 2: 2 cover 2 furious\"\n\n    if page is \"vista\"\n      system.Achievement.unlock \"Lol wut\"\n\n    if page is \"cheevos\"\n      system.Achievement.unlock \"Check yo' self\"\n\n    emptyElement(container)\n    container.appendChild(pages[page])\n\n    currentPage = page\n\n  displayPage currentPage\n\n  nextPage = (n=1) ->\n    pageKeys = Object.keys(pages)\n    nextIndex = pageKeys.indexOf(currentPage) + n\n\n    return pageKeys[nextIndex]\n\n  windowView.element.addEventListener \"keydown\", (e) ->\n    switch e.key\n      when \"Enter\", \"ArrowRight\", \" \"\n        displayPage nextPage()\n      when \"ArrowLeft\"\n        displayPage nextPage(-1)\n\n  document.body.appendChild windowView.element\n\n  windowView.element.tabIndex = 0\n  windowView.element.focus()\n",
      "mode": "100644",
      "type": "blob"
    },
    "issues/2017-03.coffee": {
      "path": "issues/2017-03.coffee",
      "content": "Model = require \"model\"\nChateau = require \"../apps/chateau\"\nContrasaurus = require \"../apps/contrasaurus\"\nPixiePaint = require \"../apps/pixel\"\nSpreadsheet = require \"../apps/spreadsheet\"\nTextEditor = require \"../apps/text-editor\"\n\nSocial = require \"../social/social\"\n\n{parentElementOfType, emptyElement} = require \"../util\"\n\nmodule.exports = ->\n  {ContextMenu, MenuBar, Modal, Progress, Util:{parseMenu}, Window} = system.UI\n  {Achievement} = system\n\n  visitedAreas =\n    blue: false\n    csaur: false\n    chateau: false\n    cheevo: false\n    evan: false\n  \n  visit = (area) ->\n    visitedAreas[area] = true\n\n    visitedAll = Object.keys(visitedAreas).every (key) ->\n      visitedAreas[key]\n\n    if visitedAll\n      Achievement.unlock \"Cover-2-cover 3: Tokyo Drift\"\n\n  system.writeFile \"issue-3/blue-light-special.txt\", new Blob [require \"../stories/blue-light-special\"], type: \"text/plain\"\n\n  system.Achievement.unlock \"Issue 3\"\n\n  handlers = Model().include(Social).extend\n    area: ->\n      \"2017-03\"\n\n    mSAccess97: ->\n      app = Spreadsheet(system)\n      document.body.appendChild app.element\n\n    chateau: ->\n      visit \"chateau\"\n      app = Chateau(system)\n      document.body.appendChild app.element\n\n    contrasaurus: ->\n      visit \"csaur\"\n      document.body.appendChild Contrasaurus(system).element\n\n    achievementStatus: ->\n      visit \"cheevo\"\n      cheevoElement = system.Achievement.progressView()\n      cheevoElement.style.width = \"100%\"\n      cheevoElement.style.padding = \"1em\"\n\n      system.Achievement.unlock \"Check yo' self\"\n\n      windowView = Window\n        title: \"Cheevos\"\n        content: cheevoElement\n        width: 640\n        height: 480\n\n      document.body.appendChild windowView.element\n    \n    evanAndMore: ->\n      visit \"evan\"\n      url = \"https://s3.amazonaws.com/whimsyspace-databucket-1g3p6d9lcl6x1/danielx/IMG_9794.JPG\"\n      img = document.createElement \"img\"\n      img.src = url\n\n      {element} = system.UI.Window\n        title: \"Evan And More\"\n        content: img\n        width: 600\n        height: 480\n\n      document.body.appendChild element\n\n    blueLightSpecial: ->\n      Achievement.unlock \"Blue light special\"\n      visit \"blue\"\n\n      storyWindow = StoryWindow(\"Blue Light Special\", require(\"../stories/blue-light-special\"))\n\n      document.body.appendChild storyWindow.element\n\n  menuBar = MenuBar\n    items: parseMenu \"\"\"\n      [A]pps\n        [C]hateau\n        Contra[s]aurus\n      [S]tories\n        [B]lue Light Special\n        [E]van And More\n      #{Social.menuText}\n      [H]elp\n        [A]chievement Status\n    \"\"\"\n    handlers: handlers\n\n  kmartGif = document.createElement \"img\"\n  kmartGif.src = \"http://media.boingboing.net/wp-content/uploads/2015/07/m66DBJ.gif\"\n  kmartGif.style = \"width: 100%; height: 100%\"\n\n  windowView = Window\n    title: \"ZineOS Volume 1 | Issue 3 | ATTN: K-Mart Shoppers | March 2017\"\n    content: kmartGif\n    menuBar: menuBar.element\n    width: 800\n    height: 600\n    x: 32\n    y: 32\n\n  document.body.appendChild windowView.element\n\nStoryWindow = (title, text) ->\n  div = document.createElement \"div\"\n  div.textContent = text\n  div.style.padding = \"1em\"\n  div.style.whiteSpace = \"pre-wrap\"\n  div.style.textAlign = \"justify\"\n\n  system.UI.Window\n    title: title\n    content: div\n    width: 380\n    height: 480\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/achievement.coffee": {
      "path": "lib/achievement.coffee",
      "content": "AchievementTemplate = require \"../templates/achievement\"\n\npending = []\ndisplaying = false\n\naudioPath = \"https://cdn.gomix.com/294e834f-223f-4792-9323-5b1fa8d0402b/unlock2.mp3\"\n\nplaySound = ->\n  audio = new Audio(audioPath)\n  audio.autoplay = true\n\n  audio\n\nmodule.exports = Achievement =\n  display: (options={}) ->\n    if displaying\n      return pending.push(options)\n\n    options.title ?= \"Achievement Unlocked\"\n\n    achievementElement = AchievementTemplate options\n    document.body.appendChild achievementElement\n    achievementElement.classList.add \"display\"\n    achievementElement.appendChild playSound()\n\n    displaying = true\n\n    achievementElement.addEventListener \"animationend\", (e) ->\n      achievementElement.remove()\n\n      displaying = false\n      if pending.length\n        Achievement.display(pending.shift())\n\n    , false\n\n    return achievementElement\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/drop.coffee": {
      "path": "lib/drop.coffee",
      "content": "module.exports = (element, handler) ->\n  cancel = (e) ->\n    e.preventDefault()\n    return false\n\n  element.addEventListener \"dragover\", cancel\n  element.addEventListener \"dragenter\", cancel\n  element.addEventListener \"drop\", (e) ->\n    e.preventDefault()\n    handler(e)\n    return false\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/error-reporter.coffee": {
      "path": "lib/error-reporter.coffee",
      "content": "window.addEventListener \"error\", (e) ->\n  system.Achievement.unlock \"I AM ERROR\"\n\nwindow.addEventListener \"unhandledrejection\", (e) ->\n  system.Achievement.unlock \"I AM ERROR\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/hamlet.js": {
      "path": "lib/hamlet.js",
      "content": "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Hamlet = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  var Hamlet, compile;\n\n  Hamlet = require(\"./runtime\");\n\n  compile = require(\"hamlet-compiler\").compile;\n\n  Hamlet.compile = compile;\n\n  module.exports = Hamlet;\n\n}).call(this);\n\n},{\"./runtime\":2,\"hamlet-compiler\":5}],2:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  \"use strict\";\n  var Observable, Runtime, bindEvent, bindObservable, bufferTo, classes, createElement, empty, eventNames, get, id, isEvent, isFragment, makeElement, observeAttribute, observeAttributes, observeContent, specialBindings, valueBind, valueIndexOf;\n\n  Observable = require(\"o_0\");\n\n  eventNames = \"abort\\nblur\\nchange\\nclick\\ncontextmenu\\ndblclick\\ndrag\\ndragend\\ndragenter\\ndragexit\\ndragleave\\ndragover\\ndragstart\\ndrop\\nerror\\nfocus\\ninput\\nkeydown\\nkeypress\\nkeyup\\nload\\nmousedown\\nmousemove\\nmouseout\\nmouseover\\nmouseup\\nreset\\nresize\\nscroll\\nselect\\nsubmit\\ntouchcancel\\ntouchend\\ntouchenter\\ntouchleave\\ntouchmove\\ntouchstart\\nunload\".split(\"\\n\");\n\n  isEvent = function(name) {\n    return eventNames.indexOf(name) !== -1;\n  };\n\n  isFragment = function(node) {\n    return (node != null ? node.nodeType : void 0) === 11;\n  };\n\n  valueBind = function(element, value, context) {\n    Observable(function() {\n      var update;\n      value = Observable(value, context);\n      switch (element.nodeName) {\n        case \"SELECT\":\n          element.oninput = element.onchange = function() {\n            var optionValue, _ref, _value;\n            _ref = this.children[this.selectedIndex], optionValue = _ref.value, _value = _ref._value;\n            return value(_value || optionValue);\n          };\n          update = function(newValue) {\n            var options;\n            element._value = newValue;\n            if ((options = element._options)) {\n              if (newValue.value != null) {\n                return element.value = (typeof newValue.value === \"function\" ? newValue.value() : void 0) || newValue.value;\n              } else {\n                return element.selectedIndex = valueIndexOf(options, newValue);\n              }\n            } else {\n              return element.value = newValue;\n            }\n          };\n          return bindObservable(element, value, context, update);\n        default:\n          element.oninput = element.onchange = function() {\n            return value(element.value);\n          };\n          if (typeof element.attachEvent === \"function\") {\n            element.attachEvent(\"onkeydown\", function() {\n              return setTimeout(function() {\n                return value(element.value);\n              }, 0);\n            });\n          }\n          return bindObservable(element, value, context, function(newValue) {\n            if (element.value !== newValue) {\n              return element.value = newValue;\n            }\n          });\n      }\n    });\n  };\n\n  specialBindings = {\n    INPUT: {\n      checked: function(element, value, context) {\n        element.onchange = function() {\n          return typeof value === \"function\" ? value(element.checked) : void 0;\n        };\n        return bindObservable(element, value, context, function(newValue) {\n          return element.checked = newValue;\n        });\n      }\n    },\n    SELECT: {\n      options: function(element, values, context) {\n        var updateValues;\n        values = Observable(values, context);\n        updateValues = function(values) {\n          empty(element);\n          element._options = values;\n          return values.map(function(value, index) {\n            var option, optionName, optionValue;\n            option = createElement(\"option\");\n            option._value = value;\n            if (typeof value === \"object\") {\n              optionValue = (value != null ? value.value : void 0) || index;\n            } else {\n              optionValue = value.toString();\n            }\n            bindObservable(option, optionValue, value, function(newValue) {\n              return option.value = newValue;\n            });\n            optionName = (value != null ? value.name : void 0) || value;\n            bindObservable(option, optionName, value, function(newValue) {\n              return option.textContent = option.innerText = newValue;\n            });\n            element.appendChild(option);\n            if (value === element._value) {\n              element.selectedIndex = index;\n            }\n            return option;\n          });\n        };\n        return bindObservable(element, values, context, updateValues);\n      }\n    }\n  };\n\n  observeAttribute = function(element, context, name, value) {\n    var binding, nodeName, _ref;\n    nodeName = element.nodeName;\n    if (name === \"value\") {\n      valueBind(element, value);\n    } else if (binding = (_ref = specialBindings[nodeName]) != null ? _ref[name] : void 0) {\n      binding(element, value, context);\n    } else if (name.match(/^on/) && isEvent(name.substr(2))) {\n      bindEvent(element, name, value, context);\n    } else if (isEvent(name)) {\n      bindEvent(element, \"on\" + name, value, context);\n    } else {\n      bindObservable(element, value, context, function(newValue) {\n        if ((newValue != null) && newValue !== false) {\n          return element.setAttribute(name, newValue);\n        } else {\n          return element.removeAttribute(name);\n        }\n      });\n    }\n    return element;\n  };\n\n  observeAttributes = function(element, context, attributes) {\n    return Object.keys(attributes).forEach(function(name) {\n      var value;\n      value = attributes[name];\n      return observeAttribute(element, context, name, value);\n    });\n  };\n\n  bindObservable = function(element, value, context, update) {\n    var observable, observe, unobserve;\n    observable = Observable(value, context);\n    observe = function() {\n      observable.observe(update);\n      return update(observable());\n    };\n    unobserve = function() {\n      return observable.stopObserving(update);\n    };\n    observe();\n    return element;\n  };\n\n  bindEvent = function(element, name, fn, context) {\n    return element[name] = function() {\n      return fn.apply(context, arguments);\n    };\n  };\n\n  id = function(element, context, sources) {\n    var lastId, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(newId) {\n      return element.id = newId;\n    };\n    lastId = function() {\n      return value.last();\n    };\n    return bindObservable(element, lastId, context, update);\n  };\n\n  classes = function(element, context, sources) {\n    var classNames, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(classNames) {\n      return element.className = classNames;\n    };\n    classNames = function() {\n      return value.join(\" \");\n    };\n    return bindObservable(element, classNames, context, update);\n  };\n\n  createElement = function(name) {\n    return document.createElement(name);\n  };\n\n  observeContent = function(element, context, contentFn) {\n    var append, contents, update;\n    contents = [];\n    contentFn.call(context, {\n      buffer: bufferTo(context, contents),\n      element: makeElement\n    });\n    append = function(item) {\n      if (item == null) {\n\n      } else if (typeof item === \"string\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"number\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"boolean\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item.each === \"function\") {\n        return item.each(append);\n      } else if (typeof item.forEach === \"function\") {\n        return item.forEach(append);\n      } else {\n        return element.appendChild(item);\n      }\n    };\n    update = function(contents) {\n      empty(element);\n      return contents.forEach(append);\n    };\n    return update(contents);\n  };\n\n  bufferTo = function(context, collection) {\n    return function(content) {\n      if (typeof content === 'function') {\n        content = Observable(content, context);\n      }\n      collection.push(content);\n      return content;\n    };\n  };\n\n  makeElement = function(name, context, attributes, fn) {\n    var element;\n    if (attributes == null) {\n      attributes = {};\n    }\n    element = createElement(name);\n    Observable(function() {\n      if (attributes.id != null) {\n        id(element, context, attributes.id);\n        return delete attributes.id;\n      }\n    });\n    Observable(function() {\n      if (attributes[\"class\"] != null) {\n        classes(element, context, attributes[\"class\"]);\n        return delete attributes[\"class\"];\n      }\n    });\n    Observable(function() {\n      return observeAttributes(element, context, attributes);\n    }, context);\n    if (element.nodeName !== \"SELECT\") {\n      Observable(function() {\n        return observeContent(element, context, fn);\n      }, context);\n    }\n    return element;\n  };\n\n  Runtime = function(context) {\n    var self;\n    self = {\n      buffer: function(content) {\n        if (self.root) {\n          throw \"Cannot have multiple root elements\";\n        }\n        return self.root = content;\n      },\n      element: makeElement,\n      filter: function(name, content) {}\n    };\n    return self;\n  };\n\n  Runtime.VERSION = require(\"../package.json\").version;\n\n  Runtime.Observable = Observable;\n\n  module.exports = Runtime;\n\n  empty = function(node) {\n    var child, _results;\n    _results = [];\n    while (child = node.firstChild) {\n      _results.push(node.removeChild(child));\n    }\n    return _results;\n  };\n\n  valueIndexOf = function(options, value) {\n    if (typeof value === \"object\") {\n      return options.indexOf(value);\n    } else {\n      return options.map(function(option) {\n        return option.toString();\n      }).indexOf(value.toString());\n    }\n  };\n\n  get = function(x) {\n    if (typeof x === 'function') {\n      return x();\n    } else {\n      return x;\n    }\n  };\n\n}).call(this);\n\n},{\"../package.json\":13,\"o_0\":10}],3:[function(require,module,exports){\n\n},{}],4:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  var ROOT_NAME, indentText, util;\n\n  indentText = function(text, indent) {\n    if (indent == null) {\n      indent = \"  \";\n    }\n    return indent + text.replace(/\\n/g, \"\\n\" + indent);\n  };\n\n  ROOT_NAME = \"__root\";\n\n  util = {\n    indent: indentText,\n    filters: {\n      verbatim: function(content, compiler) {\n        return compiler.buffer('\"\"\"' + content.replace(/(#|\")/g, \"\\\\$1\") + '\"\"\"');\n      },\n      plain: function(content, compiler) {\n        return compiler.buffer(JSON.stringify(content));\n      },\n      coffeescript: function(content, compiler) {\n        return [content];\n      },\n      javascript: function(content, compiler) {\n        return [\"`\", compiler.indent(content), \"`\"];\n      }\n    },\n    element: function(tag, attributes, contents) {\n      var lines;\n      if (attributes == null) {\n        attributes = [];\n      }\n      if (contents == null) {\n        contents = [];\n      }\n      return lines = [\"\" + ROOT_NAME + \".buffer \" + ROOT_NAME + \".element \" + (JSON.stringify(tag)) + \", this, {\" + (attributes.join('\\n')) + \"}, (\" + ROOT_NAME + \") ->\", indentText(contents.join(\"\\n\")), \"  return\"];\n    },\n    buffer: function(value) {\n      return [\"\" + ROOT_NAME + \".buffer \" + value];\n    },\n    attributes: function(node) {\n      var attributeLines, attributes, classes, id, ids, idsAndClasses;\n      id = node.id, classes = node.classes, attributes = node.attributes;\n      if (id) {\n        ids = [JSON.stringify(id)];\n      } else {\n        ids = [];\n      }\n      classes = (classes || []).map(JSON.stringify);\n      if (attributes) {\n        attributes = attributes.filter(function(_arg) {\n          var name, value;\n          name = _arg.name, value = _arg.value;\n          if (name === \"class\") {\n            classes.push(value);\n            return false;\n          } else if (name === \"id\") {\n            ids.push(value);\n            return false;\n          } else {\n            return true;\n          }\n        });\n      } else {\n        attributes = [];\n      }\n      idsAndClasses = [];\n      if (ids.length) {\n        idsAndClasses.push(\"id: [\" + (ids.join(', ')) + \"]\");\n      }\n      if (classes.length) {\n        idsAndClasses.push(\"class: [\" + (classes.join(', ')) + \"]\");\n      }\n      attributeLines = attributes.map(function(_arg) {\n        var name, value;\n        name = _arg.name, value = _arg.value;\n        name = JSON.stringify(name);\n        return \"\" + name + \": \" + value;\n      });\n      return idsAndClasses.concat(attributeLines);\n    },\n    render: function(node) {\n      var filter, tag, text;\n      tag = node.tag, filter = node.filter, text = node.text;\n      if (tag) {\n        return this.tag(node);\n      } else if (filter) {\n        return this.filter(node);\n      } else {\n        return this.contents(node);\n      }\n    },\n    filter: function(node) {\n      var filter, filterName;\n      filterName = node.filter;\n      if (filter = this.filters[filterName]) {\n        return [].concat.apply([], this.filters[filterName](node.content, this));\n      } else {\n        return [\"\" + ROOT_NAME + \".filter(\" + (JSON.stringify(filterName)) + \", \" + (JSON.stringify(node.content)) + \")\"];\n      }\n    },\n    contents: function(node) {\n      var bufferedCode, childContent, children, contents, indent, text, unbufferedCode;\n      children = node.children, bufferedCode = node.bufferedCode, unbufferedCode = node.unbufferedCode, text = node.text;\n      if (unbufferedCode) {\n        indent = true;\n        contents = [unbufferedCode];\n      } else if (bufferedCode) {\n        contents = this.buffer(bufferedCode);\n      } else if (text) {\n        contents = this.buffer(JSON.stringify(text));\n      } else if (node.tag) {\n        contents = [];\n      } else if (node.comment) {\n        return [];\n      } else {\n        contents = [];\n        console.warn(\"No content for node:\", node);\n      }\n      if (children) {\n        childContent = this.renderNodes(children);\n        if (indent) {\n          childContent = this.indent(childContent.join(\"\\n\"));\n        }\n        contents = contents.concat(childContent);\n      }\n      return contents;\n    },\n    renderNodes: function(nodes) {\n      return [].concat.apply([], nodes.map(this.render, this));\n    },\n    tag: function(node) {\n      var tag;\n      tag = node.tag;\n      return this.element(tag, this.attributes(node), this.contents(node));\n    }\n  };\n\n  exports.compile = function(parseTree, _arg) {\n    var compiler, exports, items, options, program, programSource, runtime, source, _ref;\n    _ref = _arg != null ? _arg : {}, compiler = _ref.compiler, runtime = _ref.runtime, exports = _ref.exports;\n    if (runtime == null) {\n      runtime = \"require\" + \"(\\\"hamlet-runtime\\\")\";\n    }\n    if (exports == null) {\n      exports = \"module.exports\";\n    }\n    items = util.renderNodes(parseTree);\n    if (exports) {\n      exports = \"\" + exports + \" = \";\n    } else {\n      exports = \"\";\n    }\n    source = \"\" + exports + \"(data) ->\\n  \\\"use strict\\\"\\n  (->\\n    \" + ROOT_NAME + \" = \" + runtime + \"(this)\\n\\n\" + (util.indent(items.join(\"\\n\"), \"    \")) + \"\\n    return \" + ROOT_NAME + \".root\\n  ).call(data)\";\n    options = {\n      bare: true\n    };\n    programSource = source;\n    program = compiler.compile(programSource, options);\n    return program;\n  };\n\n}).call(this);\n\n},{}],5:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  var compile, parser;\n\n  compile = require(\"./compiler\").compile;\n\n  parser = require(\"hamlet-parser\");\n\n  module.exports = {\n    compile: function(input, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (typeof input === \"string\") {\n        input = parser.parse(input, options.mode);\n      }\n      return compile(input, options);\n    }\n  };\n\n}).call(this);\n\n},{\"./compiler\":4,\"hamlet-parser\":8}],6:[function(require,module,exports){\n/* generated by jison-lex 0.2.1 */\nvar haml_lexer = (function(){\nvar lexer = {\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"moduleName\":\"haml_lexer\"},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return 'SEPARATOR';\nbreak;\ncase 1:this.popState(); return 'RIGHT_PARENTHESIS';\nbreak;\ncase 2:return 'ATTRIBUTE';\nbreak;\ncase 3:this.begin('value'); return 'EQUAL';\nbreak;\ncase 4:return 'AT_ATTRIBUTE';\nbreak;\ncase 5:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 6:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 7:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 8:yy.indent = 0; this.popState(); return 'NEWLINE';\nbreak;\ncase 9:return 'FILTER_LINE';\nbreak;\ncase 10:yy.indent = 0; return 'NEWLINE';\nbreak;\ncase 11:yy.indent += 1; if(yy.indent > yy.filterIndent){this.begin('filter'); }; return 'INDENT';\nbreak;\ncase 12:this.begin(\"parentheses_attributes\"); return 'LEFT_PARENTHESIS';\nbreak;\ncase 13:yy_.yytext = yy_.yytext.substring(1); return 'COMMENT';\nbreak;\ncase 14:yy.filterIndent = yy.indent; yy_.yytext = yy_.yytext.substring(1); return 'FILTER';\nbreak;\ncase 15:yy_.yytext = yy_.yytext.substring(1); return 'ID';\nbreak;\ncase 16:yy_.yytext = yy_.yytext.substring(1); return 'CLASS';\nbreak;\ncase 17:yy_.yytext = yy_.yytext.substring(1); return 'TAG';\nbreak;\ncase 18:yy_.yytext = yy_.yytext.substring(1).trim(); return 'BUFFERED_CODE';\nbreak;\ncase 19:yy_.yytext = yy_.yytext.substring(1).trim(); return 'UNBUFFERED_CODE';\nbreak;\ncase 20:yy_.yytext = yy_.yytext.trim(); return 'TEXT';\nbreak;\n}\n},\nrules: [/^(?:[ \\t]+)/,/^(?:\\))/,/^(?:([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:=)/,/^(?:@([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:'(\\\\.|[^\\\\'])*')/,/^(?:[^ \\t\\)]*)/,/^(?:(\\n|$))/,/^(?:[^\\n]*)/,/^(?:\\s*(\\n|$))/,/^(?:(  |\\\\t))/,/^(?:\\()/,/^(?:\\/.*)/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:#((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:\\.((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:%((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:=.*)/,/^(?:-.*)/,/^(?:.*)/],\nconditions: {\"filter\":{\"rules\":[8,9],\"inclusive\":false},\"value\":{\"rules\":[5,6,7],\"inclusive\":false},\"parentheses_attributes\":{\"rules\":[0,1,2,3,4],\"inclusive\":false},\"INITIAL\":{\"rules\":[10,11,12,13,14,15,16,17,18,19,20],\"inclusive\":true}}\n};\nreturn lexer;\n})();module.exports = haml_lexer;\n\n},{}],7:[function(require,module,exports){\n/* generated by jison-lex 0.2.1 */\nvar jade_lexer = (function(){\nvar lexer = {\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"moduleName\":\"jade_lexer\"},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return 'SEPARATOR';\nbreak;\ncase 1:this.popState(); return 'RIGHT_PARENTHESIS';\nbreak;\ncase 2:return 'ATTRIBUTE';\nbreak;\ncase 3:this.begin('value'); return 'EQUAL';\nbreak;\ncase 4:return 'AT_ATTRIBUTE';\nbreak;\ncase 5:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 6:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 7:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 8:yy.indent = 0; this.popState(); return 'NEWLINE';\nbreak;\ncase 9:return 'FILTER_LINE';\nbreak;\ncase 10:yy.indent = 0; return 'NEWLINE';\nbreak;\ncase 11:yy.indent += 1; if(yy.indent > yy.filterIndent){this.begin('filter'); }; return 'INDENT';\nbreak;\ncase 12:this.begin(\"parentheses_attributes\"); return 'LEFT_PARENTHESIS';\nbreak;\ncase 13:yy_.yytext = yy_.yytext.substring(2); return 'COMMENT';\nbreak;\ncase 14:yy.filterIndent = yy.indent; yy_.yytext = yy_.yytext.substring(1); return 'FILTER';\nbreak;\ncase 15:yy_.yytext = yy_.yytext.substring(1); return 'ID';\nbreak;\ncase 16:yy_.yytext = yy_.yytext.substring(1); return 'CLASS';\nbreak;\ncase 17:return 'TAG';\nbreak;\ncase 18:yy_.yytext = yy_.yytext.substring(1).trim(); return 'BUFFERED_CODE';\nbreak;\ncase 19:yy_.yytext = yy_.yytext.substring(1).trim(); return 'UNBUFFERED_CODE';\nbreak;\ncase 20:yy_.yytext = yy_.yytext.trim(); return 'TEXT';\nbreak;\n}\n},\nrules: [/^(?:[ \\t]+)/,/^(?:\\))/,/^(?:([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:=)/,/^(?:@([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:'(\\\\.|[^\\\\'])*')/,/^(?:[^ \\t\\)]*)/,/^(?:(\\n|$))/,/^(?:[^\\n]*)/,/^(?:\\s*(\\n|$))/,/^(?:(  |\\\\t))/,/^(?:\\()/,/^(?:\\/\\/.*)/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:#((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:\\.((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:=.*)/,/^(?:-.*)/,/^(?:.*)/],\nconditions: {\"filter\":{\"rules\":[8,9],\"inclusive\":false},\"value\":{\"rules\":[5,6,7],\"inclusive\":false},\"parentheses_attributes\":{\"rules\":[0,1,2,3,4],\"inclusive\":false},\"INITIAL\":{\"rules\":[10,11,12,13,14,15,16,17,18,19,20],\"inclusive\":true}}\n};\nreturn lexer;\n})();module.exports = jade_lexer;\n\n},{}],8:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  var extend, lexers, oldParse, parser,\n    __slice = [].slice;\n\n  parser = require(\"./parser\").parser;\n\n  lexers = {\n    haml: require(\"./haml_lexer\"),\n    jade: require(\"./jade_lexer\")\n  };\n\n  extend = function() {\n    var name, source, sources, target, _i, _len;\n    target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    for (_i = 0, _len = sources.length; _i < _len; _i++) {\n      source = sources[_i];\n      for (name in source) {\n        target[name] = source[name];\n      }\n    }\n    return target;\n  };\n\n  oldParse = parser.parse;\n\n  extend(parser, {\n    parse: function(input, mode) {\n      if (mode == null) {\n        mode = \"haml\";\n      }\n      parser.lexer = lexers[mode];\n      extend(parser.yy, {\n        indent: 0,\n        nodePath: [\n          {\n            children: []\n          }\n        ],\n        filterIndent: void 0\n      });\n      return oldParse.call(parser, input);\n    }\n  });\n\n  extend(parser.yy, {\n    extend: extend,\n    newline: function() {\n      var lastNode;\n      lastNode = this.nodePath[this.nodePath.length - 1];\n      if (lastNode.filter) {\n        return this.appendFilterContent(lastNode, \"\");\n      }\n    },\n    lastParent: function(indentation) {\n      var parent;\n      while (!(parent = this.nodePath[indentation])) {\n        indentation -= 1;\n      }\n      return parent;\n    },\n    append: function(node, indentation) {\n      var index, lastNode, parent;\n      if (indentation == null) {\n        indentation = 0;\n      }\n      if (node.filterLine) {\n        lastNode = this.nodePath[this.nodePath.length - 1];\n        this.appendFilterContent(lastNode, node.filterLine);\n        return;\n      }\n      parent = this.lastParent(indentation);\n      this.appendChild(parent, node);\n      index = indentation + 1;\n      this.nodePath[index] = node;\n      this.nodePath.length = index + 1;\n      return node;\n    },\n    appendChild: function(parent, child) {\n      if (!child.filter) {\n        this.filterIndent = void 0;\n        this.lexer.popState();\n      }\n      parent.children || (parent.children = []);\n      return parent.children.push(child);\n    },\n    appendFilterContent: function(filter, content) {\n      filter.content || (filter.content = \"\");\n      return filter.content += \"\" + content + \"\\n\";\n    }\n  });\n\n  module.exports = parser;\n\n}).call(this);\n\n},{\"./haml_lexer\":6,\"./jade_lexer\":7,\"./parser\":9}],9:[function(require,module,exports){\n(function (process){\n/* parser generated by jison 0.4.6 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"lines\":4,\"line\":5,\"indentation\":6,\"indentationLevel\":7,\"INDENT\":8,\"lineMain\":9,\"end\":10,\"tag\":11,\"rest\":12,\"COMMENT\":13,\"FILTER\":14,\"FILTER_LINE\":15,\"NEWLINE\":16,\"name\":17,\"tagComponents\":18,\"attributes\":19,\"idComponent\":20,\"classComponents\":21,\"ID\":22,\"CLASS\":23,\"LEFT_PARENTHESIS\":24,\"attributePairs\":25,\"RIGHT_PARENTHESIS\":26,\"SEPARATOR\":27,\"attributePair\":28,\"ATTRIBUTE\":29,\"EQUAL\":30,\"ATTRIBUTE_VALUE\":31,\"AT_ATTRIBUTE\":32,\"TAG\":33,\"BUFFERED_CODE\":34,\"UNBUFFERED_CODE\":35,\"TEXT\":36,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",8:\"INDENT\",13:\"COMMENT\",14:\"FILTER\",15:\"FILTER_LINE\",16:\"NEWLINE\",22:\"ID\",23:\"CLASS\",24:\"LEFT_PARENTHESIS\",26:\"RIGHT_PARENTHESIS\",27:\"SEPARATOR\",29:\"ATTRIBUTE\",30:\"EQUAL\",31:\"ATTRIBUTE_VALUE\",32:\"AT_ATTRIBUTE\",33:\"TAG\",34:\"BUFFERED_CODE\",35:\"UNBUFFERED_CODE\",36:\"TEXT\"},\nproductions_: [0,[3,1],[4,2],[4,1],[6,0],[6,1],[7,2],[7,1],[5,3],[5,1],[9,2],[9,1],[9,1],[9,1],[9,1],[9,1],[10,1],[11,2],[11,2],[11,1],[11,1],[18,3],[18,2],[18,2],[18,2],[18,1],[18,1],[20,1],[21,2],[21,1],[19,3],[25,3],[25,1],[28,3],[28,1],[17,1],[12,1],[12,1],[12,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:return this.$ = yy.nodePath[0].children;\nbreak;\ncase 2:this.$ = $$[$0-1];\nbreak;\ncase 3:this.$ = $$[$0];\nbreak;\ncase 4:this.$ = 0;\nbreak;\ncase 5:this.$ = $$[$0];\nbreak;\ncase 6:this.$ = $$[$0-1] + 1;\nbreak;\ncase 7:this.$ = 1;\nbreak;\ncase 8:this.$ = yy.append($$[$0-1], $$[$0-2]);\nbreak;\ncase 9:this.$ = (function () {\n        if ($$[$0].newline) {\n          return yy.newline();\n        }\n      }());\nbreak;\ncase 10:this.$ = yy.extend($$[$0-1], $$[$0]);\nbreak;\ncase 11:this.$ = $$[$0];\nbreak;\ncase 12:this.$ = $$[$0];\nbreak;\ncase 13:this.$ = {\n          comment: $$[$0]\n        };\nbreak;\ncase 14:this.$ = {\n          filter: $$[$0]\n        };\nbreak;\ncase 15:this.$ = {\n          filterLine: $$[$0]\n        };\nbreak;\ncase 16:this.$ = {\n          newline: true\n        };\nbreak;\ncase 17:this.$ = (function () {\n        $$[$0].tag = $$[$0-1];\n        return $$[$0];\n      }());\nbreak;\ncase 18:this.$ = {\n          tag: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 19:this.$ = {\n          tag: $$[$0]\n        };\nbreak;\ncase 20:this.$ = yy.extend($$[$0], {\n          tag: \"div\"\n        });\nbreak;\ncase 21:this.$ = {\n          id: $$[$0-2],\n          classes: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 22:this.$ = {\n          id: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 23:this.$ = {\n          classes: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 24:this.$ = {\n          id: $$[$0-1],\n          classes: $$[$0]\n        };\nbreak;\ncase 25:this.$ = {\n          id: $$[$0]\n        };\nbreak;\ncase 26:this.$ = {\n          classes: $$[$0]\n        };\nbreak;\ncase 27:this.$ = $$[$0];\nbreak;\ncase 28:this.$ = $$[$0-1].concat($$[$0]);\nbreak;\ncase 29:this.$ = [$$[$0]];\nbreak;\ncase 30:this.$ = $$[$0-1];\nbreak;\ncase 31:this.$ = $$[$0-2].concat($$[$0]);\nbreak;\ncase 32:this.$ = [$$[$0]];\nbreak;\ncase 33:this.$ = {\n          name: $$[$0-2],\n          value: $$[$0]\n        };\nbreak;\ncase 34:this.$ = {\n          name: $$[$0].substring(1),\n          value: $$[$0]\n        };\nbreak;\ncase 35:this.$ = $$[$0];\nbreak;\ncase 36:this.$ = {\n          bufferedCode: $$[$0]\n        };\nbreak;\ncase 37:this.$ = {\n          unbufferedCode: $$[$0]\n        };\nbreak;\ncase 38:this.$ = {\n          text: $$[$0] + \"\\n\"\n        };\nbreak;\n}\n},\ntable: [{3:1,4:2,5:3,6:4,7:6,8:[1,8],10:5,13:[2,4],14:[2,4],15:[2,4],16:[1,7],22:[2,4],23:[2,4],33:[2,4],34:[2,4],35:[2,4],36:[2,4]},{1:[3]},{1:[2,1],5:9,6:4,7:6,8:[1,8],10:5,13:[2,4],14:[2,4],15:[2,4],16:[1,7],22:[2,4],23:[2,4],33:[2,4],34:[2,4],35:[2,4],36:[2,4]},{1:[2,3],8:[2,3],13:[2,3],14:[2,3],15:[2,3],16:[2,3],22:[2,3],23:[2,3],33:[2,3],34:[2,3],35:[2,3],36:[2,3]},{9:10,11:11,12:12,13:[1,13],14:[1,14],15:[1,15],17:16,18:17,20:22,21:23,22:[1,24],23:[1,25],33:[1,21],34:[1,18],35:[1,19],36:[1,20]},{1:[2,9],8:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[2,9],22:[2,9],23:[2,9],33:[2,9],34:[2,9],35:[2,9],36:[2,9]},{8:[1,26],13:[2,5],14:[2,5],15:[2,5],22:[2,5],23:[2,5],33:[2,5],34:[2,5],35:[2,5],36:[2,5]},{1:[2,16],8:[2,16],13:[2,16],14:[2,16],15:[2,16],16:[2,16],22:[2,16],23:[2,16],33:[2,16],34:[2,16],35:[2,16],36:[2,16]},{8:[2,7],13:[2,7],14:[2,7],15:[2,7],22:[2,7],23:[2,7],33:[2,7],34:[2,7],35:[2,7],36:[2,7]},{1:[2,2],8:[2,2],13:[2,2],14:[2,2],15:[2,2],16:[2,2],22:[2,2],23:[2,2],33:[2,2],34:[2,2],35:[2,2],36:[2,2]},{10:27,16:[1,7]},{12:28,16:[2,11],34:[1,18],35:[1,19],36:[1,20]},{16:[2,12]},{16:[2,13]},{16:[2,14]},{16:[2,15]},{16:[2,19],18:29,19:30,20:22,21:23,22:[1,24],23:[1,25],24:[1,31],34:[2,19],35:[2,19],36:[2,19]},{16:[2,20],34:[2,20],35:[2,20],36:[2,20]},{16:[2,36]},{16:[2,37]},{16:[2,38]},{16:[2,35],22:[2,35],23:[2,35],24:[2,35],34:[2,35],35:[2,35],36:[2,35]},{16:[2,25],19:33,21:32,23:[1,25],24:[1,31],34:[2,25],35:[2,25],36:[2,25]},{16:[2,26],19:34,23:[1,35],24:[1,31],34:[2,26],35:[2,26],36:[2,26]},{16:[2,27],23:[2,27],24:[2,27],34:[2,27],35:[2,27],36:[2,27]},{16:[2,29],23:[2,29],24:[2,29],34:[2,29],35:[2,29],36:[2,29]},{8:[2,6],13:[2,6],14:[2,6],15:[2,6],22:[2,6],23:[2,6],33:[2,6],34:[2,6],35:[2,6],36:[2,6]},{1:[2,8],8:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[2,8],22:[2,8],23:[2,8],33:[2,8],34:[2,8],35:[2,8],36:[2,8]},{16:[2,10]},{16:[2,17],34:[2,17],35:[2,17],36:[2,17]},{16:[2,18],34:[2,18],35:[2,18],36:[2,18]},{25:36,28:37,29:[1,38],32:[1,39]},{16:[2,24],19:40,23:[1,35],24:[1,31],34:[2,24],35:[2,24],36:[2,24]},{16:[2,22],34:[2,22],35:[2,22],36:[2,22]},{16:[2,23],34:[2,23],35:[2,23],36:[2,23]},{16:[2,28],23:[2,28],24:[2,28],34:[2,28],35:[2,28],36:[2,28]},{26:[1,41],27:[1,42]},{26:[2,32],27:[2,32]},{30:[1,43]},{26:[2,34],27:[2,34]},{16:[2,21],34:[2,21],35:[2,21],36:[2,21]},{16:[2,30],34:[2,30],35:[2,30],36:[2,30]},{28:44,29:[1,38],32:[1,39]},{31:[1,45]},{26:[2,31],27:[2,31]},{26:[2,33],27:[2,33]}],\ndefaultActions: {12:[2,12],13:[2,13],14:[2,14],15:[2,15],18:[2,36],19:[2,37],20:[2,38],28:[2,10]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        throw new Error(str);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    this.yy.parser = this;\n    if (typeof this.lexer.yylloc == 'undefined') {\n        this.lexer.yylloc = {};\n    }\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = this.lexer.options && this.lexer.options.ranges;\n    if (typeof this.yy.parseError === 'function') {\n        this.parseError = this.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    function lex() {\n        var token;\n        token = self.lexer.lex() || EOF;\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + this.lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: this.lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: this.lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(this.lexer.yytext);\n            lstack.push(this.lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\nundefined\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}\n}).call(this,require('_process'))\n},{\"_process\":12,\"fs\":3,\"path\":11}],10:[function(require,module,exports){\n(function (global){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],11:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n},{\"_process\":12}],12:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],13:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"hamlet.coffee\",\n  \"version\": \"0.7.6\",\n  \"description\": \"Truly amazing templating!\",\n  \"devDependencies\": {\n    \"browserify\": \"^12.0.1\",\n    \"coffee-script\": \"~1.7.1\",\n    \"jsdom\": \"^7.2.0\",\n    \"mocha\": \"^2.3.3\"\n  },\n  \"dependencies\": {\n    \"hamlet-compiler\": \"0.7.0\",\n    \"o_0\": \"0.3.8\"\n  },\n  \"homepage\": \"hamlet.coffee\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/dr-coffee-labs/hamlet.git\"\n  },\n  \"scripts\": {\n    \"prepublish\": \"script/prepublish\",\n    \"test\": \"script/test\"\n  },\n  \"files\": [\n    \"dist/\"\n  ],\n  \"main\": \"dist/runtime.js\"\n}\n\n},{}]},{},[1])(1)\n});",
      "mode": "100644",
      "type": "blob"
    },
    "lib/iframe-app.coffee": {
      "path": "lib/iframe-app.coffee",
      "content": "Model = require \"model\"\nPostmaster = require \"postmaster\"\nFileIO = require \"../os/file-io\"\n\nmodule.exports = (opts={}) ->\n  {ContextMenu, MenuBar, Modal, Observable, Progress, Table, Util:{parseMenu}, Window} = system.UI\n\n  {height, menuBar, src, title, width} = opts\n\n  frame = document.createElement \"iframe\"\n  frame.src = src\n\n  # Keep track of waiting for child window to load, all remote invocations are\n  # queued behind a promise until the child has loaded\n  # May want to move it into the postmaster library\n  resolveLoaded = null\n  loadedPromise = new Promise (resolve) ->\n    resolveLoaded = resolve\n\n  # Attach a postmaster to receive events from the child frame\n  postmaster = Postmaster()\n  postmaster.remoteTarget = -> frame.contentWindow\n  Object.assign postmaster,\n    childLoaded: ->\n      console.log \"child loaded\"\n      resolveLoaded()\n\n    # Send events from the iframe app to the window view\n    event: ->\n      windowView.trigger \"event\", arguments...\n\n      return\n\n  # TODO: Extend with passed in handlers?\n  handlers = Model().include(FileIO).extend\n    loadFile: (blob) ->\n      loadedPromise.then ->\n        postmaster.invokeRemote \"loadFile\", blob\n\n  windowView = Window\n    title: title\n    content: frame\n    menuBar: menuBar?.element\n    width: width\n    height: height\n\n  windowView.loadFile = handlers.loadFile\n\n  return windowView\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/outbound-clicks.coffee": {
      "path": "lib/outbound-clicks.coffee",
      "content": "{parentElementOfType} = require \"../util\"\n\n# Outbound clicker\ndocument.addEventListener \"click\", (e) ->\n  anchor = parentElementOfType(\"a\", e.target)\n\n  if anchor\n    href = anchor.getAttribute('href')\n\n    if href.match /^http/\n      e.preventDefault()\n\n      if href.match /frogfeels\\.com/\n        system.Achievement.unlock \"Feeling the frog\"\n\n      window.open href\n",
      "mode": "100644",
      "type": "blob"
    },
    "mailchimp.coffee": {
      "path": "mailchimp.coffee",
      "content": "document.head.insertAdjacentHTML \"beforeend\",\"\"\"\r\n  <link href=\"https://cdn-images.mailchimp.com/embedcode/classic-10_7.css\" rel=\"stylesheet\" type=\"text/css\">\r\n  <style type=\"text/css\">\r\n  \t#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }\r\n  </style>\r\n\"\"\"\r\n\r\nmodule.exports =\r\n  show: ->\r\n    div = document.createElement \"div\"\r\n\r\n    div.innerHTML = \"\"\"\r\n      <div id=\"mc_embed_signup\">\r\n      <form action=\"//space.us14.list-manage.com/subscribe/post?u=8946c32e9db504ccc083d3fc7&amp;id=b8b708aea6\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n          <div id=\"mc_embed_signup_scroll\">\r\n\r\n      <div class=\"mc-field-group\">\r\n      \t<label for=\"mce-EMAIL\">Email Address </label>\r\n      \t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\">\r\n      </div>\r\n      \t<div id=\"mce-responses\" class=\"clear\">\r\n      \t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n      \t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n      \t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n          <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_8946c32e9db504ccc083d3fc7_b8b708aea6\" tabindex=\"-1\" value=\"\"></div>\r\n          <div class=\"clear\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n          </div>\r\n      </form>\r\n      </div>\r\n    \"\"\"\r\n\r\n    system.UI.Modal.show div\r\n",
      "mode": "100644",
      "type": "blob"
    },
    "main.coffee": {
      "path": "main.coffee",
      "content": "require(\"analytics\").init(\"UA-3464282-16\")\n\nrequire \"./extensions\"\n\nrequire \"./lib/outbound-clicks\"\nrequire \"./lib/error-reporter\"\n\nglobal.Hamlet = require \"./lib/hamlet\"\n\nSystem = require \"./system\"\nglobal.system = System()\n\n{Style} = system.UI\nstyle = document.createElement \"style\"\nstyle.innerHTML = Style.all + \"\\n\" + require(\"./style\")\ndocument.head.appendChild style\n\n# Desktop\nExplorer = require \"./apps/explorer\"\ndocument.body.appendChild Explorer()\n\nsystem.writeFile \"feedback.exe\", new Blob [\"\"], type: \"application/exe\"\nsystem.writeFile \"issue-1/zine1.exe\", new Blob [\"\"], type: \"application/exe\"\nsystem.writeFile \"issue-2/zine2.exe\", new Blob [\"\"], type: \"application/exe\"\nsystem.writeFile \"issue-3/zine3.exe\", new Blob [\"\"], type: \"application/exe\"\n\nrequire(\"./issues/2017-03\")()\n",
      "mode": "100644",
      "type": "blob"
    },
    "os/file-io.coffee": {
      "path": "os/file-io.coffee",
      "content": "# Handle basic file saving/loading/picking, displaying modals/ui.\n\n# Host must provide the following methods\n#   `loadFile` Take a blob and load it as the application state.\n#   `saveData` Return a promise that will be fulfilled with a blob of the\n#     current application state.\n#   `newFile` Initialize the application to an empty state.\n\nmodule.exports = (I, self) ->\n  {Observable} = system\n  {Modal} = system.UI\n\n  currentPath = Observable \"\"\n  # TODO: Update saved to be false when model changes\n  saved = true\n\n  self.extend\n    currentPath: currentPath\n    new: ->\n      if saved\n        currentPath \"\"\n        self.newFile()\n      else\n        Modal.confirm \"You will lose unsaved progress, continue?\"\n        .then (result) ->\n          if result\n            saved = true\n            self.newFile()\n\n    open: ->\n      # TODO: Prompt if unsaved\n      # TODO: File browser\n      Modal.prompt \"File Path\", currentPath()\n      .then (newPath) ->\n        if newPath\n          currentPath newPath\n        else\n          throw new Error \"No path given\"\n      .then (path) ->\n        system.readFile path, true\n      .then (file) ->\n        self.loadFile file\n\n    save: ->\n      if currentPath()\n        self.saveData()\n        .then (blob) ->\n          system.writeFile currentPath(), blob, true\n        .then ->\n          currentPath()\n      else\n        self.saveAs()\n\n    saveAs: ->\n      Modal.prompt \"File Path\", currentPath()\n      .then (path) ->\n        if path\n          currentPath path\n          self.save()\n\n  return self\n",
      "mode": "100644",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "content": "dependencies:\n  ajax: \"distri/ajax:master\"\n  analytics: \"distri/google-analytics:master\"\n  bindable: \"distri/bindable:master\"\n  model: \"distri/model:master\"\n  postmaster: \"distri/postmaster:v0.5.0\"\n  ui: \"STRd6/ui:master\"\nremoteDependencies: [\n  \"https://cdnjs.cloudflare.com/ajax/libs/dexie/2.0.0-beta.7/dexie.min.js\"\n  \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ace.js\"\n  \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ext-language_tools.js\"\n  \"https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.7.1/coffee-script.min.js\"\n  \"https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.6/marked.min.js\"\n]\n",
      "mode": "100644",
      "type": "blob"
    },
    "presenters/achievement-group-progress.coffee": {
      "path": "presenters/achievement-group-progress.coffee",
      "content": "AchievementBadgeTemplate = require \"../templates/achievement-badge\"\nProgressTemplate = require \"../templates/achievement-progress\"\n\nmodule.exports = ({name, achievements}) ->\n  achieved = achievements.filter ({achieved}) ->\n    achieved\n  .length\n\n  total = achievements.length\n  value = achieved / total\n\n  ProgressTemplate\n    name: name\n    achievements: achievements\n    badges: achievements.map (cheevo) ->\n      AchievementBadgeTemplate Object.assign {}, cheevo,\n        class: ->\n          \"achieved\" if cheevo.achieved\n    fraction: \"#{achieved}/#{total}\"\n    value: value.toString()\n",
      "mode": "100644",
      "type": "blob"
    },
    "social/comment-form.jadelet": {
      "path": "social/comment-form.jadelet",
      "content": "form\n  h1 Comment\n  label\n    h3 Author\n    input(name=\"author\" value=\"Anon\")\n  label\n    h3 Body\n    textarea(name=\"body\")\n  input(type=\"hidden\" name=\"area\" value=@area)\n  button Submit\n",
      "mode": "100644",
      "type": "blob"
    },
    "social/comments.jadelet": {
      "path": "social/comments.jadelet",
      "content": "comments\n  - @forEach (comment) ->\n    comment\n      div= comment.body\n      .author= comment.author\n",
      "mode": "100644",
      "type": "blob"
    },
    "social/social.coffee": {
      "path": "social/social.coffee",
      "content": "CommentFormTemplate = require \"../social/comment-form\"\nCommentsTemplate = require \"../social/comments\"\n\nAjax = require \"ajax\"\najax = Ajax()\n\n# Includer must provide self.area() method that dictates what the comments attach to\nmodule.exports = (I, self) ->\n  {Modal} = system.UI\n\n  self.extend\n    comment: ->\n      Modal.form CommentFormTemplate\n        area: self.area()\n      .then (data) ->\n        ajax\n          url: \"https://whimsy-space.gomix.me/comments\"\n          data: JSON.stringify(data)\n          headers:\n            \"Content-Type\": \"application/json\"\n          method: \"POST\"\n      .then ->\n        self.viewComments()\n\n    viewComments: ->\n      ajax.getJSON \"https://whimsy-space.gomix.me/comments/#{self.area()}\"\n      .then (data) ->\n        data = data.reverse()\n\n        if data.length is 0\n          data = [{\n            body: \"no comments\"\n            author: \"mgmt\"\n          }]\n\n        Modal.show CommentsTemplate data\n\n    like: ->\n      system.Achievement.unlock \"Do you 'like' like me?\"\n      Modal.alert \"I like you too, but we don't have a facebook or anything yet :)\"\n    subscribe: ->\n      require(\"../mailchimp\").show()\n\nmodule.exports.menuText = \"\"\"\nS[o]cial Media\n  [V]iew Comments\n  [C]omment\n  [L]ike\n  [S]ubscribe\n\"\"\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "stories/around-the-world.coffee": {
      "path": "stories/around-the-world.coffee",
      "content": "module.exports = \"\"\"\n# Around the World in 20 Years and a Weekend\n\nThe history of human progress is rife with us entering things. [Tombs](https://en.wikipedia.org/wiki/Raiders_of_the_Lost_Ark), [dragons](https://en.wikipedia.org/wiki/Enter_the_Dragon), [voids](https://en.wikipedia.org/wiki/Enter_the_Void), even [gungeons](http://dodgeroll.com/gungeon/).\n\n\nBut have you ever stopped to think about what fuels this endless urge to ingress? Rather fearlessly, I decided to find out.\n\n![sensuous nights](https://frog-feels.s3.amazonaws.com/2016-52/391848cb-afa1-4149-b2be-054d6d86b540.png)\n\nIt's now 20 years later. I've waded through the jungles of the Amazon, skied the slopes of Norway, swam the Ganges, and braved long lines. I've lost a lot too. The years have aged me dramatically - I'm a hot mess. And I lost my phone a month ago, so my friends and family are dead to me now.\n\nHere's what I've learned on my journey,\n\n![lederhosen leroy](https://frog-feels.s3.amazonaws.com/2016-30/57b1f586-4f32-4cd5-8aea-d1a7c9400964.png)\n\nThe Freudian says we want to go in things for obvious sex reasons. Freudian? More like Fraud-ian, right? Har har.\n\n![horse confessional](https://frog-feels.s3.amazonaws.com/2016-27/75889dde-ba0c-434e-b5dd-1edda7daa97e.png)\n\nMy Peyote spirit animal is a horse. Under the desert sky he whispers in my ear that what we really want is to enter the stable of the mind. I'm not so sure though. I don't even really like normal earthly stables.\n\n![soup boy](https://frog-feels.s3.amazonaws.com/2016-32/821e8ec3-e55d-4388-8cdd-6da58d902924.png)\n\nAfter the peyote trip, things get a little fuzzy. I stumbled into a place. It was either a diner, a drive-in, or a dive. There I met TV food guy Guy Fieri. Between mouthfuls of cheese and enthusiasm, he proclaimed that we enter so that we may exit.\n\nWere all searching for something thats everything we imagine it to be.\n\n...\n\nIf I'm honest, this odyssey only really took a weekend. After that I didn't really feel like going back to work, so I just hung out for a while.\n\n![you are great](https://frog-feels.s3.amazonaws.com/2016-50/2d44fdcd-05b9-4a92-a954-ec1235ee7b1e.png)\n\n\n[ cool art made by cool people at [Frog Feels](http://frogfeels.com)]\n\"\"\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "stories/blue-light-special.coffee": {
      "path": "stories/blue-light-special.coffee",
      "content": "module.exports = \"\"\"\nBlue Light Special\n\nYou know, I really want some cookies. Elo said. She sat on a cushion on top of a tarp spread on the ground in front of their small campfire and whittled a piece of wood, periodically tossing the shavings into the fire. The warm glow bathed her deft fingers, tired face, and honey-colored hair with a soft light, and faintly illuminated the oak trees around them in the pressing darkness.\n\nWe can break camp tomorrow, move on, and see what we can find on the way, Jib replied, as he munched some popcorn and scratched his dark beard. He scooted his log seat closer to the fire and buttoned his shearling jacket to keep out the fine mist rolling in among the trees.\n\nI dont want to break camp, Elo protested. I like it here. We should stay a while. I just want to have some cookies. She looked around their camp: at Jib on his stump; at Poli beside her on the tarp, seated on her own cushion; at their reliable and well-used tent; at the horses draped with their blankets; at the clean dishes drying fireside. This was a good place. She rubbed her ever-growing abdomen. The tiny person ensconced within dragged a heel over her insides in response.\n\nOkay, we wont break camp, then. We can just go to town tomorrow. We need some other supplies anyway. Jib raised his lanky body to pass the popcorn to Poli, who took the enameled bowl and placed it between her and Elo.\n\nPoli offered the popcorn to Elo. Here, have some popcorn. That will help take your mind off the craving.\n\nElo knitted her brows. No, it wont. Its not the same and you know it.\n\nYeah, okay. I know. Its not. But its what we have, Poli smiled gently, hoping to diffuse the situation.\n\nWhy cant you just go get some now? We didnt camp that far from town, and its not that late, Elo pleaded.\n\nBecause its going to rain soon, and because Im tired, and because we decide things together, not based on whim, Jib retorted grumpily.\n\nPleeeeeease! I really, really want them. Im tired too and my back hurts from hauling this baby around and I just want to have some cookies. Is that too much to ask? Elo burst into tears.\n\nElo, please dont cry. Polis red curls bounced as she snapped her head up to glare at Jib. She enfolded Elo in a hug, and Elo sobbed harder on the petite womans shoulder.\n\nPoli, come on, Jib sighed. Get Elo settled in the tent and you and I will go tonight. Lets get moving so were not caught in too much rain on the way back.\n\n**\n\nGabe sat on a cold concrete bench at a cold, round, concrete table, eating cold pizza under a murky and unforgiving sky in which clouds entirely obscured the stars, and in which mist threatened to give way to outright rain. He reflected miserably that of all the ways to eat pizza, this was probably the second-worst. The worst would be back in the break room with the other Kmart employees, where they would have excited yet hushed conversations that did not include him, the night manager.\n\nThe table he was sitting at had recently had a fiberglass umbrella to provide meager protection against the elements. Last week, however, seven drunk teenagers had removed it to use as a boat in a very large puddle at the back of the parking lot and it had not been seen since. The sky began to spit at him, and he thought, At least the sky is doing what theyre all thinking.\n\nGabe looked up the nearly deserted road and noticed two large figures with an odd gait. They resolved into a tall, bearded man and a petite, redheaded woman, each on horseback, emerging from the mist and entering the Kmart parking lot. Amused, Gabe wondered whether the pair might tie their horses up to the bike racks, or find a parking space near a lamp post and hitch them there, or tether them to a tree.\n\nThe man and woman did none of these things. They simply rode the horses through the automatic doors and into the Kmart. Gabe took a moment to process this. He started to get up, looked at his phone, noticed ten minutes remained of his break, and sat back down.\n\n**\n\nPoli dismounted inside the doors and hitched up a shopping cart to her horse. She nimbly saddled up again, and she and Jib then began perusing the aisles of the Kmart and checking the items off their list.\n\nSir? Miss? Can I help you? an employee demanded tersely, body language suggesting the only help would be toward an exit.\n\nYes, thank you. We are looking for cookies such as would satisfy a pregnancy craving, Jib replied. He placed some batteries in their cart.\n\nCookies? Aisle 12A, the employee responded automatically, then shook her head.  The horses. You cant have them in here. Youll have to take them outside. The employee was joined by two others, all of them looking simultaneously stern and bewildered.\n\nThey reached the aisles endcap. Ooh, look, nut mixes are on sale, Poli grinned.\n\nGo ahead and get a few, Jib called to her as he rode ahead to select some prenatal vitamins and toothpaste.\n\nMiss, please. The two of you need to take the horses outside, the employee wheedled.  As if to respond, Polis horse lifted its tail and dropped a steaming load near the employees boot. The employee leapt back, dismayed.\n\nOh, no, Im afraid that wont be possible. These are our service animals, Poli chirped sweetly.\n\nThe employees huddled together. Wheres Gabe? they worried. They barked into walkie-talkies to Gabe to come over here RIGHT NOW and received no response.\n\nPoli caught up with Jib and together they loaded dry beans and rice into the cart. Suddenly, a voice spoke, as if from the heavens, and a flashing blue light punctuated the announcement:\n\nAttention, Kmart shoppers! Blue light special on Aisle 12A. Tedwich Sandwich Cookies, buy two, get one free!\n\nWe have to get those for Elo. I bet theyll be perfect! Poli shouted to Jib, and she urged her horse forward. Jib rode after her, followed by the three ineffectual employees, and an ever-growing crowd of onlookers.\n\nAisle 12A displayed an alarming variety of cookies, snack cakes, and other treats, and Poli and Jib were, for the first time, ill at ease in the Kmart. A small girl with braids and cutoff jeans approached them.\n\nHere you go, she smiled shyly, handing up a box. \n\nThank you, Jib smiled back. He tore into the box and passed a handful of the Tedwich cookies to Poli. They sampled the miniature bear-shaped cinnamon cookies sandwiching a vanilla cream filling. They were, indeed, exactly what Elo would love.\n\nCan you help us load our cart with every box there is? Poli asked.\n\nNot every box. I want to have three for myself, the girl quickly replied.\n\nDone.\n\nWith all but three boxes of Tedwich cookies in their cart, the only thing left was to find some ice cream to go with them. This expedition caused no small amount of chaos in the freezer case aisle when a small, yappy dog in a handbag spooked the horses, which in turn sent the crowd scattering in all directions. Fortunately, it also resulted in Jibs horse being perfectly positioned in front of a case containing pint after pint of ice cream. They selected one of chocolate and one of vanilla, and Jib and Poli rode to the checkout.\n\nPoli pulled a small wooden box from her canvas messenger bag and handed it down to the cashier. This is a very rare and ancient turtle, carved from an unknown precious stone to bring the bearer untold riches. It is more than enough payment for these goods in our cart.\n\nPoli and Jib rode out of the store, cart still in tow, as Gabe came back in. The two riders disappeared into the night.\n\nThe employees surrounded him. Gabe said nothing. He strolled through the store, surveying the relative lack of damage, the confused shoppers, and the piles of manure, and he grinned as he reached for his walkie-talkie.\n\nCleanup on Aisles 6, 7, 10, and 12. Better get a shovel.\n\n**\n\nElo drifted to sleep that night, completely content, filled with cookies and ice cream. She dreamed of a girl with braids and cutoff jeans, holding boxes and boxes of Tedwich cookies stacked higher than she was tall. She flew above the girl as a deep blue light bathed them both.\n\nWhat is your name? Elo asked.\n\nTheodosia, the girl answered. The girl flew up to meet Elo and they soared effortlessly through the ceiling and out into the mist.\n\nThree months later, in the middle of another rainy night, Elo gave birth to a baby girl. The child was dusted with cinnamon freckles and looked up at Elo with the bluest eyes she had ever seen. She named the girl Theodosia.\n\n\"\"\"",
      "mode": "100644",
      "type": "blob"
    },
    "stories/dungeon-dog.coffee": {
      "path": "stories/dungeon-dog.coffee",
      "content": "module.exports = \"\"\"\nDungeon Crawl with Cliffford!\n\nOne sunny day, Cliffford the big rad dog was playing at the park with his friends U-Bone and Cloe. They chased each other through the playground, around the play structures, and through the sand. Children squealed with delight to see Cliffford jump right over the swing set in his excitement. Hes so big! He can jump over things! Heehee! they giggled. THUMP! went Clifffords paws as he landed on the grassy field, and Cloe and U-Bone followed right behind.\n\nThe dogs dashed through a soccer game, U-Bone stopping to bite at the ball, and Cleo weaving her way through at least four players legs. They emerged on the other side of the field at the northernmost edge of the park, where the well-kept field gave way to a little meadow, and then the woods.\n\nCliffford flopped down in a shady spot, and Cloe and U-Bone stood panting next to him. Cool breezes blew in from the ocean, rippling the leaves on the trees and the long meadow-grass.\n\nWhat do you guys want to do now? Cliffford asked. I could really go for a nap.\nYeah, a nap sounds good, U-Bone replied, snuggling up beside him.\nWe could nap, but what about going back and trying to get that Frisbee over there? Cloe asked.\nMmphuhuhmph, U-Bone answered, already half-asleep.\nAll right, fine, Cloe huffed. Cliffford began to doze as well, so Cloe meandered away, sniffing around the meadow.\n\nCliffford? U-BONE! WAAAAAAAKE UP! Cliffford and U-Bone bolted awake, jumping to their feet.\nHAHAHAHA! Did I scare you? Cloe yipped, bouncing around in circles around her two friends as excitement practically dripped off her.\nWhats up, Cloe? U-Bone asked.\nI found something neat. Come with me!\n\nWithout looking behind her to see if the others were coming, Cloe took off at a run down a path that Cliffford and U-Bone hadnt seen until now. The path wound through the woods, the trees getting taller and closer together the further along they went. The terrain became rockier, and a few times they dodged around large boulders as they continued forward.\n\nAround a bend in the path, Cloe came into view, her tail wagging wildly. She stood in front of a large outcropping with a dark, conveniently Cliffford-sized opening in its face.\n\nThis place gives me the willies, U-Bone said, looking around. He noticed crumbling rock around the entrance, which on closer inspection, he realized were carvings of some kind of dog-dragon looking menacingly into his eyes. U-Bone decided not to inspect it further. It was definitely a dungeon.\n\nSo? Come on, guys, what do you think? Want to go inside? Cloe asked.\nYou know, Id really rather just go back and see if we can score any free snacks from the picnic blankets, U-Bone muttered, looking uncomfortable.\nYeah, Im not even sure Ill fit in there, Cliffford said.\nUh, Cliffford, did you see the part up there in the paragraph before last where it said the entrance is conveniently Cliffford-sized? Do you remember the last story where you fit into the double doors of a shopping mall? You cant worm your way out of this. Cloe looked smug. Im sure there are all kinds of interesting things to eat in there anyway, U-Bone.\nOh, all right, Cliffford and U-Bone sighed. Lets enter the dungeon.\nFuck* yeah! Cloe shouted, and ran inside.\n\n*If youre reading this to young children for some reason, have fun substituting the word of your choice. May we suggest fizzle? Forward? Finagle? Forsooth? Just say it with all the energy of a dog hopped up on self-righteousness and youll be fine.\n\nCliffford did, indeed, fit inside the entrance, as well as the tunnel just inside. There were plenty of smells wafting around, and his head whipped from side to side trying to take them all in. In doing so, he failed to look at the ground ahead, and he tripped.\n\nLook, a bone! Clifford said happily as he scrambled up off the floor. Things were beginning to look up. Cliffford picked it up and gnawed around on it as they trekked deeper into the dungeon.\n\nU-Bone noticed some orangish clingy stuff close to the bottom of the cave wall. He sniffed it. Slime mold? Dont mind if I do. He nibbled a little, and then scarfed the rest down in just a few bites. Not bad. He feels invigorated!\n\nOh, wow, another one! Cliffford shouted around the bone in his mouth as he stopped to pick up a second bone. And another! This dungeon is turning out to be pretty great.\n\nI told you! Cloe grinned. She bounded down the tunnel ahead of the other two. Come on, theres a staircase thats leading down!\n\nThe three dogs descended the stairs into near-blackness. No longer lit by the daylight streaming in from the entrance, the dungeon was distinctly murkier. Something brushed past U-Bones ear and he snapped at it.\n\nI found a torch! Cloe said. I wonder if theres any way to light it. Wed better take it with us. She grabbed the torch in her mouth and crept into the gloom.\n\nThe trio inched forward, sniffing and listening before moving along the path. Eventually, the darkness lifted a little bit, and they approached a second, lit torch set into a sconce in the wall. Even Cloe felt better once she lit their torch, which now illuminated a small circle around them.\n\nSomething else glinted in the darkness just beyond them. Cloe moved closer and the dogs saw a beautifully crafted, lightweight sword lying on the dusty floor. This ones all yours, U-Bone, Cliffford said through his mouthful of bones. U-Bone gingerly took the sword and swung it around a few times. Cliffford and Cloe saw his apprehension turn to excitement as U-Bone growled, advanced on a spiderweb, and dispatched it.\n\nU-Bone stumbled upon a sheath and baldric for the sword a short distance away, and strapped them on. BOSS! A few turns of the path later, and the dogs found another staircase down. Come on, its a dungeon crawl. Of course they found another staircase!\n\nThe dogs explored further and deeper into the dungeon. Clifffords mouth was crammed as full as possible with bones, and he looked sadly at each one he had to leave behind as they pressed on.\n\nHumuhlauhsunrrmmmuh, said the big rad dog, furrowing his brows.\nHmm? asked Cloe, through the side of her mouth around the torch.\nMmmmahhhhh! U-Bone hollered as he turned a bat into a meat icon that dropped a large leather satchel and a helmet that fit no one.\n\nCliffford pawed the satchel with his foot, turning it over. It flopped open. There was nothing inside, so he started to put his bones in his bag. He was delighted to find every single one fit, and then some. Huzzzah! A bag of holding! he shouted, and raced forward to find more.\n\nInstead, Cliffford found a kobold corpse. He sniffed it, hesitated, sniffed again, shrugged, and dug in. Any good? U-Bone asked, sheathing his sword. Ugh, no, this corpse is definitely tainted, Clifford said, not lifting his head from his meal. U-Bone sniffed the corpse and took a bite. Yeah, man, ugh, thats rank. Dont eat those guys.\n\nThe dogs began to feel thirsty from all their exertions, and conveniently the next level had some water! They descended the stairs to find themselves standing in front of an expanse of shimmering deep blue-violet, a gorgeous underground lake.\n\nIts beautiful! Cloe sighed. She bent down to drink, and U-Bone followed suit. Cliffford bent over, too, and as he drank, his stomach began to twist. Uh, guys? Cliffford said. HUUUGGGGGGHHHHHHHHHH, he retched, and vomited into the lake. He lay down in the mud on the shore.\n\nU-Bone noticed a sign nearby. Lake of Eternal Cleanliness, he read.\nDude, not anymore. HAH! Cloe barked.\n\nJust then, they heard a shout ahead of them. A small, crotchety dog-dragon-hermit thing emerged from a hovel at the edge of the lake.\n\nTHIS LAKE HAS BEEN PRISTINE FOR NINE HUNDRED THIRTY SEVEN YEARS! shouted the angry lake-keeper, shaking one fist wildly and wielding a Staff of Glowing Menace in the other. Cloe backed up, and U-Bone got his sword ready, but Cliffford still lay in the mud, groaning.\n\nJust then, Cliffford happened to twist his head at just the right angle to notice a small vial of something pink resting in the mud by his ear. He quaffed this (come on, Cliffford, stop ingesting all these questionable things!) and instantly felt not only invigorated, but also amplified! Cliffford barked an ear-poppingly loud enchanted bark, which repelled the lake-keeper and sent him splashing into the Lake of Recent Uncleanliness, and the three friends hauled ass* (*apples?) further down into the dungeon.\n\nBy the time the dogs felt like they could slow down, they had descended what felt like (and was) the umpteenth flight of stairs. They came out in front of a small, narrow opening. Cloe held the torch while U-Bone scouted inside, and he noticed that the path was twistier and turnier than the rest of the dungeon had been.\n\nI think its a labyrinth, he said, as the two smaller dogs emerged from the entrance. But Cliffford, I dont think youre going to fit.\n\nIm going to look around and see if theres any way around, Cloe said, and trotted off. She came back a few moments later with a rolled-up piece of paper.\n\nHey guys, whats this? she said, dropping it in front of the others.\nIts some kind of scroll, U-Bone said, nosing at it.\nIs that like some kind of newspaper? she asked. I love newspapers! I like to go out really early in the morning right after theyre delivered, slide them out of their plastic sleeve, and shaaaaaaaaaake them so hard that they get all shredded up! Its so funny! Cloe giggled. Im going to go for it. I think this scroll is going to be pretty satisfying too.\n\nCloe whipped her head back and forth, and the scroll unfurled, revealing the text GRRMOC UHLPROOT in old-timey writing, and she stopped. Grrmoc uhlproot? she asked, and instantly, Cliffford fell to the ground. Yeah, the scroll was totally cursed.\n\nA moment later, Cliffford was back up again, only now he was the size of a normal dog. Yup!\n\nThis was a very useful development for our plot, because they heard shouts from the top of the stairs. The angry lake-keepers scratchy toenails clicked on the stone treads as he skittered down toward them.\n\nThe dogs wasted no time, and all three dove right into the entrance to the labyrinth. They tried their best to stay together, but Clifford, unused to being tiny, lagged behind. He felt weak, and needed food badly.\n\nThe other dogs called encouragingly behind them for Cliffford to hurry the fuck* (*fart!) up, but he stopped short when he saw some meat lying in a corner. It was another kobold corpse. His brain said to him, Hey, wait a second, Cliffford, but then he discovered hed already begun to eat it.\n\nOh yeah, this ones tainted too.\n\nThe dogs all managed to find their way to the center of the labyrinth in enough time to marvel at the treasure there: the Squeaky Toy of Canidae. A lovely, fuzzy, stuffed squirrel with a magical squeaker that never, ever breaks, and that is also enchanted with legendary but vague special powers.\n\nTheir marvel was cut short by the angry lake-keeper, who barreled into the center of the labyrinth behind them, hollering. Cliffford turned to face the lake-keeper, and felt a familiar twist in his stomach as he did so.\n\nHGGGGGRRRRRRRPH! he grunted, spewing vomit all over the lake-keeper. It sizzled as it hit the lake-keeper, dealing quite a bit of damage. It also broke a curse on the lake-keeper, and from his crusty, smelly robes emerged Moc.\n\nWhat is going on? Ive been in this godforsaken cave for the last five and a half days* (*937 dog-hours!). The whole time Ive been having repeated nightmares that Im some sort of disgusting hermit encamped by a lake. He shook himself, and droplets of vomit spattered the labyrinth walls.\n\nAnd you, Cliffford, your vomit seems to be a recurring feature in my nightmares as well. Can we please get out of here? Moc huffed, as he caught a whiff of the tainted, partially digested kobold corpse clinging to his fur.\n\nHey, guys, I think Mocs curse isnt the only one thats broken!! Cliffford shouted, as he began to grow and grow. The rapid growth broke down the walls of the labyrinth, revealing a clear path to the exit.\n\nCliffford stuffed the Squeaky Toy of Canidae into his bag of holding, and all the other dogs hopped on his back and held on for dear life as Cliffford sprinted out of the dungeon and back into the sunshine of the park.\n\nAfter rolling around in the grass to get the last of the spiderwebs and vomit off themselves, the dogs went back to Clifffords doghouse, where they all feasted on the bones from Clifffords bag of holding and took turns with the Squeaky Toy of Canidae.\n\nThe friends all agreed that it was the best dungeon crawl ever!\n\nTHE END!!\n\"\"\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "stories/mystery-smell.coffee": {
      "path": "stories/mystery-smell.coffee",
      "content": "module.exports = \"\"\"\nThe Mystery Smell\n\nIve got one! Cloe shouted. Cliffford, the big rad dog, and his friends U-Bone, Cloe, Moc, Cassy, and Bub were playing their favorite game  Mystery Smell.\n\nIts smoky and garlicky and meaty, said Cloe, and its coming from a backyard! The other dogs trotted down the street, sniffing everywhere until they found the source of the smell.\n\nIts a backyard barbecue! called U-Bone from across the street. I smell carne asada!\nYou got it! Cloe answered.\n\nMy turn! said Cliffford as he caught a whiff of something on the breeze. Its strong, almost but not quite like mint, and its coming from up high.\n\nHmmm, thought the others. They passed through a park at the end of the street, and the others found the smell right away. Eucalyptus trees! Moc declared triumphantly, looking up into the tall trees that grew around the perimeter of the park.\n\nCassys nose picked up the trail of a jogger, and the dogs gleefully bounded along, following it until it ended at a house a few blocks away.\n\nI smell something citrusy! U-Bone barked, and his friends sniffed the air. They found a neighbor picking lemons off a tree in their front yard.\n\nGUYS! shouted Bub. I have one, and its amazing!\n\nWhat is it like? Cliffford wondered, and the others waited expectantly.\n\nWell, its...you know...sort of...something...with a hint of...I cant explain it. Poor Bub was just a puppy and didnt know the names of all the tantalizing smells in the neighborhood.\n\nThe other dogs sniffed their noses in all directions, hoping to help Bub name the smell he had found. Suddenly, they heard a yip! and a scratching of claws and the dogs turned to see Bub bounding away down the street.\n\nBub! shouted Cliffford. Bub kept on running. The big rad dog sighed. Bub is such a little puppy, but he always gets into BIG trouble. Wed better go after him.\n\nCliffford, U-Bone, Cloe, Moc, and Cassy took off after Bub. They practically flew over the sidewalk! They reached the end of the block to see Bubs tail disappear around the corner. They rounded the corner themselves and stopped short.\n\nWhat is that huge building? U-Bone asked. The dogs stared together at the building, which was situated in the middle of a very large, very busy parking lot.\n\nIts a shopping mall! Cloe shouted. Miss Dollar takes me there sometimes. People go there and look at things, and sometimes they take the things out in bags.\nBub just went inside, guys. Wed better go in after him, Moc said. The dogs quickly but carefully crossed the street, navigated the cars circling for parking spots, and made their way to the double doors of the BIZWELL MALL.\n\nThe mall had two floors, so the dogs split up. U-Bone and Cloe dashed for the escalators and each took one side of the top floor. Moc and Cassy stayed downstairs and each took a side. Cliffford went down the middle, with his feet on the first floor and his nose up in the second!\n\nAll five dogs dodged strollers and shopping bags, kiosks and benches, as they continued in pursuit of Bub.\n\nBub, meanwhile, was having a fantastic time. He had no idea what this huge building was, but the smells were tantalizing! He found a place with all kinds of different food, from curries to noodles to pizza to tacos, labeled Food Court. He picked up the smell of freshly baked waffle cones, and chocolate chip ice cream as he ran by a kiosk, and paused only briefly to lick the remains of a childs dropped cone.\n\nBub passed a storefront selling candy, and savored the whiffs of peppermint candy canes and caramels and chocolates coming from the entrance. He scampered by a store loaded with candles, body lotions and sprays, all with fruity and floral fragrances.\n\nShoes! squealed Bub, as he skittered past a store with hundreds of pairs of brand-new sneakers lining the walls. Bub was tempted to dive headfirst into the store selling leather handbags and wallets and belts and jackets, and chew on everything in sight, but he thought better of it. Besides, all the smells he smelled in this wondrous building were familiar. None of them were the new and enticing scent he was trying to find.\n\nPassing a coffee-and-tea kiosk and inhaling the aroma of the freshly ground beans and steaming cups of tea, Bub found himself at the other end of Bizwell Mall. He had nowhere to go but straight into the anchor store at the end, dodging displays as he kept sniffing. The scent was getting stronger  he must be almost there!\n\nWearily, the other dogs approached the anchor store as well, just in time to see Bub running headlong into it. They summoned the last of their energy, marveling at Bubs stamina, and ran through the store themselves.\n\nWell, I think weve lost him, Cliffford huffed to his friends. I dont see him anywhere, and were here at the exit.\n\nWait! Cassy shouted. Isnt that Bub outside?\n\nThe dogs burst out the doors and into the cool air, and there was Bub, happily rolling around on the ground.\n\nI found it, guys!! Bub called, as he flopped on his back once more and wriggled in the source of his scent: pine needles, fallen from hundreds of freshly cut Christmas trees, filling up a large portion of the parking lot outside the store.\nThe other dogs agreed that Christmas trees did smell very, very good. Bub had not caused any damage, only a merry chase, so they were all quite relieved. They all meandered through the tree lot, sniffing and looking.\n\nCliffford decided that he wanted to get a tree for his doghouse, and picked the biggest, tallest tree he could find. It was taller than he was! The proprietor of the Christmas tree lot wrapped it up for him with rope, making two straps that Cliffford could wear like a backpack. Bub proudly jumped up on Clifffords head as they headed for home, with the other dogs close behind.\n\nEmma was waiting back at Clifffords doghouse, hoping to read him a story, and she gaped as the dogs entered the doghouse. She laughed when she saw what they had with them, and said, I think were going to need more decorations than what we have in the garage!\n\nIn the end, it took two trips back to the mall, a hundred strands of lights, and a thousand ornaments to decorate the huge tree. The dogs gave Bub the honor of plugging it in, and they all agreed it was the best Christmas tree ever.\n\"\"\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "stories/provision.coffee": {
      "path": "stories/provision.coffee",
      "content": "module.exports = \"\"\"\nOne hundred or so years from now, when I\ndie, my descendants come across this\nrich text file while going through the\ndrawers and the suitcases in my husband\nand I's house under the pretense of\ncleaning. They will try to understand\nwho we were and if we ever were more\nthan just parents. They will have\nproblems with technology that has yet to\nbe invented; they will have kids and\nlovers that I will never meet.\n\nMy husband will die twenty or so years\nbefore me. He will fall asleep at Sam's\nClub and refuse to wake up. A\nbadly-shaken mid-level Sam's Club\nfranchise manager with kind eyes and a\npolo T-shirt and exactly one earring\nwill knock on my door and deliver the\nnews. I will feel weak and, 18 hours\nlater, I will cry.\n\nI want you to know how ordinary I was. I\nwanted to be one person and then I ended\nup being someone else. Cumulatively I\nthought I had serious fantasies about\nmarrying three different people and,\nafter college, I ended up marrying the\nsecond. I was part of a dozen thousand\nwho fled to Canada during the dark\nyears. My grocer patiently taught me how\nto say 100 words in a French-Canadian\naccent and gave me the courage to eat\nugly vegetables. I could have traveled\nmore and been happy. I could have not\ntraveled more and been happy.\n\nThe worst part about traveling is all\nthe advertisements for foreign brands.\nWalking home at night under the\nspotlights of billboards with which you\ncannot empathize is a piercing kind of\nloneliness. The best part about\ntraveling is meeting all the other\nexpats in your city, who each is tacitly\na member of a busy and tired club.\n\nMy parents were Armenian mathematicians.\nThey left their country, which gave me\nthe courage to leave mine. They were\nconstantly worried about me and, to\ndistract themselves, they bought and\nflipped real estate. The first time you\nbuy a house it seems impossible that\neach room will fill with the right\nfurniture and the each wall will have\nthe right artwork. The second time is\ntwice as easy; and the third is twice\nthat. They met one hundred or so\ndifferent people that way, which I think\nsomehow made my relationship with them\nbetter or at least easier. Toward the\nend they will play gin with their\nneighbors in the morning and watch\nArmenian television in the afternoon, on\na small satellite modem that only\nArmenians know where to buy. They forgot\nEnglish first, then walking, then\nbreathing. Acting on this information, I\nwill try to die much faster.\n\nThe early 2010s will be remembered\nfondly as a simpler time, and\nadditionally I want to add they were my\nfavorite years. The late 2040s were good\ntoo, as were the 2060s. It will become\ndifficult to separate the objective\nquality of a time period from how much\nof a burden my body becomes. Every year\nI will buy clothes that looked like all\nthe clothes I owned fifteen years ago\nuntil, one day, I throw everything out\nthat isn't white and blue. I will die in\na white blouse and blue shorts. In death\nI will stop looking cute and start\nlooking serene.\n\nThough I know some facts about the\nfuture I have a great deal of questions.\nWhat are the food trends now? Are there\nany new bands that sound like the old\nbands I liked? Do radiators still break\nduring the coldest week?\n\nMy husband and I ran into each other in\nthree different cities. The first two\ntimes we recognized in each other an\nunderstanding that the timing was off.\nThe third time we fucked in a friend's\ncloset, groping each other like we were\nyounger, beneath layers of woolen duvets\nthat we by accident pulled down. It\nseemed tawdry and sticky at the time and\nnow it's just a sentence.\n\nInto our lives we carved out space for\neach other. We put up load-bearing\nbeams. We added good thick curtains and\na little OLED display that read the\namount of humidity in the air. We agreed\nto never make the other person sleep on\nthe couch, as we wanted ours to be\nfilled with the flatulence of our\nfriends. We threw the best parties. We\nwere an unstoppable hosting machine. We\nfigured out that a party becomes the\nmemory of a party. It happens one or two\ndays after the party, when the\nconversation and the discoveries curdle\ninto something distant and bittersweet.\n\nThe city will build a subway station\nnear us in 2031 after years of private\nfunding into subterranean\ninfrastructure. The money will come from\ntech moguls looking to survive zombies\nand/or climate change, but a subway\nstation is a subway station. One late\nnight, as we step off the train on our\nway home, we will walk past a woman\nwearing a bright striped parka. I will\nturn my head to get a second look and\nshe will not be there. I will crook my\nhead to see behind the poles until my\nneck hurts, and still I will see no one.\nI will turn to my husband, who sees my\nface, and we will walk home with his\nhead lying on my shoulder and his hand\nlying on my chest so that my\ninexplicably racing heartbeat will bang\nand shudder against his hand like a\nhurricane's wind against the shutters of\na house where nobody has ever lived.\n\"\"\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "style.styl": {
      "path": "style.styl",
      "content": "body\n  overflow: hidden\n\nh1\n  line-height: 1.25em\n  margin: 0\n\nul\n  list-style-type: square\n  padding-left: 1.25em\n\nuser-select(s)\n  user-select: s\n  -moz-user-select: s\n  -webkit-user-select: s\n  -ms-user-select: s\n\ncomments, comment\n  display: block\n  padding: 1em\n\ncomment\n  border: 1px solid black\n  margin-bottom: 1em\n\n  &:last-child\n    margin-bottom: 0\n\n  > .author\n    color: gray\n    font-size: 0.75em\n    text-align: right\n\n    &::before\n      content: \"-\"\n\nexplorer\n  display: block\n  padding: 0.5em\n  user-select: none\n\n  body > &\n    height: 100%\n    width: 100%\n\n  > file, > folder\n    display: inline-block\n    padding: 0.5em\n\n    > icon\n      display: block\n      height: 32px\n      margin: auto\n      width: 32px\n\n  > file > icon\n    background-image: url(\"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAACHd3d3d3d3d3d3d3dwAAAAj///////////////cAAAAI///////////////3AAAACP///////3d///d39wAAAAj/zMzM//mZ//+Zn/cAAAAI////////l///+X/3AAAACP/MzMzM//l3d3l/9wAAAAj/////////mZmZf/cAAAAI/8zMzMzM//l/+X/3AAAACP//////////l/l/9wAAAAj/zMzMzMzM//l5f/cAAAAI////////////mX/3AAAACP/MzMzMzMzM//n/9wAAAAj///////////////cAAAAI/8zMzMzMzMzMzP/3AAAACP//////////////9wAAAAj/zMzMzMzMzMzM//cAAAAI///////////////3AAAACP8AAAAA/8zMzMz/9wAAAAj/iZD/8P////////cAAAAI/4AAAAD/zMzMzP/3AAAACP+P8Luw////////9wAAAAj/gAC7sP/MzMzM//cAAAAI/4/wu7D////////3AAAACP+P8Luw/////4AAAAAAAAj/j/AAAP////+P94AAAAAI/4/wzMD/////j3gAAAAACP+IiIiA/////4eAAAAAAAj///////////+IAAAAAAAI////////////gAAAAAAACIiIiIiIiIiIiIAAAAAA4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAP4AAAH+AAAD/gAAB/4AAA/+AAAf8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAACHd3d3d3cAAI//////9wAAj8z5//n3AACP//+ZmfcAAI/MzPn59wAAj////5n3AACPzMzM+fcAAI//////9wAAjwAPzMz3AACPmY////cAAI/Pj8zM9wAAj8+P//AAAACPiI//9/gAAI/////3gAAAiIiIiIgAAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIAHAACADwAAgB8AAA==\")\n\n  > file[type^=\"text/\"] > icon\n    background-image: url(\"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAACHd3d3d3d3d3d3dwcAAAAI//////////////9wcAAACP//////////////cHAAAAj/AAAA/////////3BwAAAI//////////////9wcAAACP8AAAD/////////cHAAAAj//////////////3BwAAAI//////////////9wcAAACP8AAAAAAAAAAAD/cHAAAAj//////////////3BwAAAI/wAAAAAAAAAAAP9wcAAACP//////////////cHAAAAj/AAAAAAAAAAAA/3BwAAAI//////////////9wcAAACP8AAAAAAAAAAAD/cHAAAAj//////////////3BwAAAI//////////////9wcAAACP8AAAD/////////cHAAAAj//////////////3BwAAAI//////////////9wcAAACP//////////////cHAAAAj/AAAA/////////3BwAAAI//////////////9wcAAACP8AAAD////w8AD/cHAAAAj//////////////3BwAAAI//////////////9wcAAACP//////////////cHAAAAjw/w/w/w/w/w/w/4BwAAAI8P8P8P8P8P8P8P+AcAAAAI+I+I+I+I+I+I+I+AAAAAAAAAAAAAAAAAAAAAAAAA8AAAH+AAAA/AAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAH4AAAD/JJJL8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAh3d3d3d3AACP//////cAAI//////9wAAj/AAAA/3AACP//////cAAI/wAAAP9wAAj//////3AACP8AAAD/cAAI//////9wAAj/AA8A/3AACP//////cAAI//////9wAAjw8PDw8PAAAA+Pj4+PAAAAAAAAAAAAAAgA8AAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAACADwAA1V8AAA==\")\n\n  > file[type=\"application/javascript\"] > icon\n    background-image: url(\"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAACHd3d3d3d3d3d3dwcAAAAI//////////////9wcAAACP//////////////cHAAAAj/AAAA////AAD//3BwAAAI////////AwsDAP9wcAAACP8AAAD//zu7uzD/cHAAAAj///////M7MDsAD3BwAAAI///////zuwgLsw9wcAAACP8AAAAAAzswOwAPcHAAAAj///////87u7sw/3BwAAAI/wAAAAAAMwsDAP9wcAAACP////////8zM///cHAAAAj/AAAAAAAAAAAA/3BwAAAI//////////////9wcAAACP8AAAAAAAAAAAD/cHAAAAj//////////////3BwAAAI//////////////9wcAAACP8AAAD/////////cHAAAAj//////////////3BwAAAI//////////////9wcAAACP//////////////cHAAAAj/AAAA/////////3BwAAAI//////////////9wcAAACP8AAAD////w8AD/cHAAAAj//////////////3BwAAAI//////////////9wcAAACP//////////////cHAAAAjw/w/w/w/w/w/w/4BwAAAI8P8P8P8P8P8P8P+AcAAAAI+I+I+I+I+I+I+I+AAAAAAAAAAAAAAAAAAAAAAAAA8AAAH+AAAA/AAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAH4AAAD/JJJL8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAACHd3d3d3cAAI//////9wAAj///Aw/3AACP8Ac7MPcAAI//87Cz9wAAj/AHOzD3AACP//9zf/cAAI/wAAAP9wAAj//////3AACP8ADwD/cAAI//////9wAAj//////3AACPDw8PDw8AAAD4+Pj48AAAAAAAAAAAAAwAcAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAADABwAA6q8AAA==\")\n\n  > folder > icon\n    background-image: url(\"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACDMzMzMzMzMzMzMzMzMzMwj7e3t7e3t7e3t7e3t7e3MI97e3t7e3t7e3t7e3t7ezCPt7e3t7e3t7e3t7e3t7cwj3t7e3t7e3t7e3t7e3t7MI+3t7e3t7e3t7e3t7e3tzCPe3t7e3t7e3t7e3t7e3swj7e3t7e3t7e3t7e3t7e3MI97e3t7e3t7e3t7e3t7ezCPt7e3t7e3t7e3t7e3t7cwj3t7e3t7e3t7e3t7e3t7MI+3t7e3t7e3t7e3t7e3tzCPe3t7e3t7e3t7e3t7e3swj7e3t7e3t7e3t7e3t7e3MI97e3t7e3t7e3t7e3t7ezCPt7e3t7e3t7e3t7e3t7cwj3t7e3t7e3t7e3t7e3t7MI+3t7e3t7e3t7e3t7e3tzCPe3t7e3t7e3t7e3t7e3swj7e3t7e3t7e3t7e3t7e3MI///////////////////wCHd3d3d3d3d4iIiIiIiIgACPt7e3t7e3gAAAAAAAAAAACPt7e3t7eAAAAAAAAAAAAACP/////4AAAAAAAAAAAAAACIiIiIgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////////gAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAP//wAH//+AD///wB/////////////8oAAAAEAAAACAAAAABAAQAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIiIiIiIiIgAj7e3t7e3uACPe3t7e3t4AI+3t7e3t7gAj3t7e3t7eACPt7e3t7e4AI97e3t7e3gAj7e3t7e3uACP///////4AIe3t7eIiIgACHt7eAAAAAAAiIiAAAAAAAAAAAAAAAAA//8AAP//AACAAQCgAAHOAAABzgAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAMAAID/AADB/wAA//8AAA==\")\n\n#modal > container\n  padding: 1em\n\nchateau\n  width: 100%\n  height: 100%\n  position: relative\n\n  > word-area\n    display: block\n    pointer-events: none\n    position: absolute\n    width: 100%\n    height: 100%\n\n    > words\n      border: 1px solid black\n      border-radius: 4px\n      background-color: white\n      padding: 0.5em\n      position: absolute\n      display: inline-block\n\n  > canvas\n    display: block\n    width: 100%\n    height: 100%\n    position: absolute\n\n  > form\n    position: absolute\n    bottom: 0\n\n  window > viewport > &\n    margin: initial\n\n\n@keyframes display-achievement\n  0%\n    bottom: -128px\n  5%\n    bottom: 2em\n  95%\n    bottom: 2em\n  100%\n    bottom: -128px\n\n@keyframes slide-left\n  0%\n    left: 100%\n  25%\n    left: 0\n  50%\n    left: -100%\n  100%\n    left: -100%\n\nachievement\n  color: white\n  background-color: blue\n  border-radius: 32px\n  bottom: -128px\n  box-shadow: 2px 2px 10px black\n  display: block\n  height: 64px\n  left: 0\n  margin: auto\n  overflow: hidden\n  padding: 8px\n  position: absolute\n  right: 0\n  width: 300px\n  z-index: 9000\n\n  &:after\n    animation: slide-left 3s linear 0.75s infinite\n    content: \"\"\n    background: linear-gradient(\n      50deg,\n      rgba(255, 255, 255, 0) 0%,\n      rgba(255, 255, 255, 0) 40%,\n      rgba(255, 255, 255, 0.95) 50%,\n      rgba(255, 255, 255, 0) 75%,\n      rgba(255, 255, 255, 0) 100%\n    )\n    height: 100%\n    position: absolute\n    top: 0\n    left: 100%\n    width: 100%\n\n  &.display\n    animation: display-achievement 6s\n\n  > h2\n    font-size: 1.25em\n    margin: 0\n\n  > p\n    margin-top: 8px\n    margin-bottom: 8px\n\n  > icon\n    background-color: white\n    border-radius: 32px\n    color: blue\n    display: inline-block\n    float: left\n    font-size: 35px\n    font-family: \"Apple Color Emoji\",\"Segoe UI Emoji\",\"NotoColorEmoji\",\"Segoe UI Symbol\",\"Android Emoji\",\"EmojiSymbols\"\n    height: 48px\n    line-height: 48px\n    margin-right: 8px\n    text-align: center\n    width: 48px\n\nachievement-badges\n  display: block\n\nachievement-progress\n  display: block\n\n  > h2\n    margin-bottom: 4px\n\nachievement-badge\n  background-color: white\n  border: 1px solid gray\n  color: gray\n  display: inline-block\n  font-size: 35px\n  font-family: \"Apple Color Emoji\",\"Segoe UI Emoji\",\"NotoColorEmoji\",\"Segoe UI Symbol\",\"Android Emoji\",\"EmojiSymbols\"\n  height: 48px\n  line-height: 48px\n  margin-right: 8px\n  margin-top: 8px\n  text-align: center\n  width: 48px\n\n  &.achieved\n    border: 1px solid blue\n    color: blue\n",
      "mode": "100644",
      "type": "blob"
    },
    "system.coffee": {
      "path": "system.coffee",
      "content": "{fileSeparator, normalizePath} = require \"./util\"\n\n# DexieDB Containing our FS\nDexieFSDB = (dbName='fs') ->\n  db = new Dexie dbName\n\n  db.version(1).stores\n  \tfiles: 'path, blob, size, type, createdAt, updatedAt'\n\n  return db\n\n# FS Wrapper to DB\nDexieFS = (db) ->\n  Files = db.files\n\n  notify = (eventType, path) ->\n    (result) ->\n      self.trigger eventType, path\n      return result\n\n  self = Model()\n  .include(Bindable)\n  .extend\n    read: (path) ->\n      Files.get(path)\n\n    write: (path, blob) ->\n      now = +new Date\n\n      Files.put\n        path: path\n        blob: blob\n        size: blob.size\n        type: blob.type\n        createdAt: now\n        updatedAt: now\n      .then notify \"write\", path\n\n    update: (path, changes) ->\n      Files.update path, changes\n      .then notify \"update\", path\n\n    delete: (path) ->\n      Files.delete(path)\n      .then notify \"delete\", path\n\n    # TODO: Collapse folders\n    # .replace(/\\/.*$/, \"/\")\n    list: (dir) ->\n      Files.where(\"path\").startsWith(dir).toArray()\n      .then (files) ->\n        files.forEach (file) ->\n          file.relativePath = file.path.replace(dir, \"\")\n\n        return files\n\nuniq = (array) ->\n  Array.from new Set array\n\nBindable = require \"bindable\"\nModel = require \"model\"\nAchievement = require \"./system/achievement\"\nAssociations = require \"./system/associations\"\nSystemModule = require \"./system/module\"\nTemplate = require \"./system/template\"\nUI = require \"ui\"\n\nmodule.exports = (dbName='zine-os') ->\n  self = Model()\n\n  fs = DexieFS(DexieFSDB(dbName))\n\n  self.include(Achievement, Associations, SystemModule, Template)\n\n  self.extend\n    fs: fs\n\n    # TODO: Allow relative paths\n    readFile: (path, userEvent) ->\n      if userEvent\n        self.Achievement.unlock \"Load a file\"\n\n      path = normalizePath \"/#{path}\"\n      fs.read(path)\n      .then ({blob}) ->\n        blob\n\n    # TODO: Allow relative paths\n    writeFile: (path, blob, userEvent) ->\n      if userEvent\n        self.Achievement.unlock \"Save a file\"\n\n      path = normalizePath \"/#{path}\"\n      fs.write path, blob\n\n    # TODO: Allow relative paths\n    deleteFile: (path) ->\n      path = normalizePath \"/#{path}\"\n      fs.delete(path)\n\n    # TODO: Allow relative paths\n    updateFile: (path, changes) ->\n      path = normalizePath \"/#{path}\"\n      fs.update(path, changes)\n\n    # NOTE: These are experimental commands to run code\n    execJS: (path) ->\n      self.readFile(path)\n      .then (file) ->\n        file.readAsText()\n      .then (programText) ->\n        Function(programText)()\n\n    Observable: UI.Observable\n    UI: UI\n\n  invokeBefore UI.Modal, \"hide\", ->\n    self.Achievement.unlock \"Dismiss modal\"\n\n  return self\n\ninvokeBefore = (receiver, method, fn) ->\n  oldFn = receiver[method]\n\n  receiver[method] = ->\n    fn()\n    oldFn.apply(receiver, arguments)\n",
      "mode": "100644",
      "type": "blob"
    },
    "system/achievement.coffee": {
      "path": "system/achievement.coffee",
      "content": "Achievement = require \"../lib/achievement\"\n\n{Observable} = UI = require \"ui\"\n\n{emptyElement} = require \"../util\"\n\n# TODO: Track unlocks, save/restore achievements\n# TODO: Only display once\n# TODO: View achievement progress grouped by area\n\nachievementData = [{\n  text: \"Issue 1\"\n  icon: \"\"\n  group: \"Issue 1\"\n  description: \"View Issue 1\"\n}, {\n  text: \"Cover-2-cover\"\n  icon: \"\"\n  group: \"Issue 1\"\n  description: \"Read the entire issue\"\n}, {\n  text: \"No rush\"\n  icon: \"\"\n  group: \"Issue 1\"\n  description: \"Patience is a virtue\"\n}, {\n  text: \"Issue 2\"\n  icon: \"\"\n  group: \"Issue 2\"\n  description: \"View Issue 2\"\n}, {\n  text: \"Lol wut\"\n  icon: \"\"\n  group: \"Issue 2\"\n  description: \"Did you know Windows Vista had a magazine?\"\n}, {\n  text: \"Cover-2-cover 2: 2 cover 2 furious\"\n  icon: \"\"\n  group: \"Issue 2\"\n  description: \"Read the entire issue\"\n}, {\n  text: \"Feeling the frog\"\n  icon: \"\"\n  group: \"Issue 2\"\n  description: \"Visit frogfeels.com\"\n}, {\n  text: \"The dungeon is in our heart\"\n  icon: \"\"\n  group: \"Issue 2\"\n  description: \"Played dungeon of sadness\"\n}, {\n  text: \"Issue 3\"\n  icon: \"\"\n  group: \"Issue 3\"\n  description: \"View Issue 3\"\n}, {\n  text: \"Cover-2-cover 3: Tokyo Drift\"\n  icon: \"\"\n  group: \"Issue 3\"\n  description: \"Read the entire issue\"\n}, {\n  text: \"Blue light special\"\n  icon: \"\"\n  group: \"Issue 3\"\n  description: \"Read 'Blue Light Special'\"\n}, { # Apps\n  text: \"Notepad.exe\"\n  icon: \"\"\n  group: \"App\"\n  description: \"Launch a text editor\"\n}, {\n  text: \"Pump up the jam\"\n  icon: \"\"\n  group: \"App\"\n  description: \"Launch audio application\"\n}, {\n  text: \"Microsoft Access 97\"\n  icon: \"\"\n  group: \"App\"\n  description: \"Launch a spreadsheet application\"\n}, {\n  text: \"Look at that\"\n  icon: \"\"\n  group: \"App\"\n  description: \"Open the image viewer\"\n}, {\n  text: \"Pixel perfect\"\n  icon: \"\"\n  group: \"App\"\n  description: \"Open the pixel editor\"\n}, {\n  text: \"Check yo' self\"\n  icon: \"\"\n  group: \"App\"\n  description: \"Check your achievement status\"\n}, { # OS\n  text: \"Save a file\"\n  icon: \"\"\n  group: \"OS\"\n  description: \"Write to the file system\"\n}, {\n  text: \"Load a file\"\n  icon: \"\"\n  group: \"OS\"\n  description: \"Read from the file system\"\n}, {\n  text: \"Execute code\"\n  icon: \"\"\n  group: \"OS\"\n  description: \"Some people like to live dangerously\"\n}, {\n  text: \"Dismiss modal\"\n  icon: \"\"\n  group: \"OS\"\n  description: \"Dismiss a modal without even reading it\"\n}, {\n  text: \"I AM ERROR\"\n  icon: \"\"\n  group: \"OS\"\n  description: \"Encountered a JavaScript error\"\n}, { # Social\n  text: \"Do you 'like' like me?\"\n  icon: \"\"\n  group: \"Social\"\n  description: \"Have fine taste\"\n}, {\n  text: \"We value your input\"\n  icon: \"\"\n  group: \"Social\"\n  description: \"View feedback form\"\n}, { # Chateau\n  text: \"Enter the Chateau\"\n  icon: \"\"\n  group: \"Chateau\"\n  description: \"Enter the Chateau\"\n}, {\n  text: \"Puttin' on the Ritz\"\n  icon: \"\"\n  group: \"Chateau\"\n  description: \"Upload custom avatar\"\n}, {\n  text: \"Paint the town red\"\n  icon: \"\"\n  group: \"Chateau\"\n  description: \"Upload a custom background\"\n}, {\n  text: \"Poutine on the Ritz\"\n  icon: \"\"\n  group: \"Chateau\"\n  description: \"Put poutine on a Ritz cracker\"\n}, {\n  text: \"It's in the cloud\"\n  icon: \"\"\n  group: \"Chateau\"\n  description: \"Upload a file\"\n}, {\n  text: \"Rawr\"\n  icon: \"\"\n  group: \"Contrasaurus\"\n  description: \"Played Contrasaurus\"\n}]\n\nrestore = ->\n  storedCheevos = []\n\n  try\n    storedCheevos = JSON.parse localStorage.cheevos\n\n  storedAchieved = {}\n  storedCheevos.forEach ({achieved, text}) ->\n    storedAchieved[text] = achieved\n\n  achievementData.forEach (cheevo) ->\n    {text} = cheevo\n\n    if storedAchieved[text]\n      cheevo.achieved = true\n\npersist = ->\n  localStorage.cheevos = JSON.stringify(achievementData)\n\nAchievementProgressPresenter = require \"../presenters/achievement-group-progress\"\n\ngroupBy = (xs, key) ->\n  xs.reduce (rv, x) ->\n    (rv[x[key]] ?= []).push(x)\n\n    rv\n  , {}\n\nmodule.exports = (I, self) ->\n  restore()\n\n  Object.assign self,\n    Achievement:\n      groupData: Observable {}\n      unlock: (name) ->\n        opts = achievementData.find ({text}) ->\n          text is name\n\n        if opts and !opts.achieved\n          opts.achieved = true\n\n          persist()\n          updateStatus()\n          Achievement.display opts\n      progressView: ->\n        content = document.createElement \"content\"\n\n        Observable ->\n          data = self.Achievement.groupData()\n\n          elements = Object.keys(data).map (group) ->\n            AchievementProgressPresenter\n              name: group\n              achievements: data[group]\n\n          emptyElement content\n          elements.forEach (element) ->\n            content.appendChild(element)\n\n        return content\n\n  updateStatus = ->\n    self.Achievement.groupData groupBy(achievementData, \"group\")\n  updateStatus()\n\n  return self\n",
      "mode": "100644",
      "type": "blob"
    },
    "system/associations.coffee": {
      "path": "system/associations.coffee",
      "content": "# TODO: Move handlers out\nAudioBro = require \"../apps/audio-bro\"\nFilter = require \"../apps/filter\"\nNotepad = require \"../apps/notepad\"\nTextEditor = require \"../apps/text-editor\"\nSpreadsheet = require \"../apps/spreadsheet\"\nPixelEditor = require \"../apps/pixel\"\nMarkdown = require \"../apps/markdown\"\nDSad = require \"../apps/dungeon-of-sadness\"\n\nopenWith = (App) ->\n  (file) ->\n    app = App()\n    app.loadFile(file.blob, file.path)\n    document.body.appendChild app.element\n\nmodule.exports = (I, self) ->\n  # TODO: Handlers that can use combined type, extension, and contents info\n  # to do the right thing\n  # Prioritize handlers falling back to others\n  handlers = [{\n    # JavaScript\n    name: \"Execute\"\n    filter: (file) ->\n      file.type is \"application/javascript\" or\n      file.path.match /\\.js$/\n    fn: (file) ->\n      file.blob.readAsText()\n      .then (sourceProgram) ->\n        system.loadModule sourceProgram, file.path\n  }, {\n    # CoffeeScript\n    name: \"Execute\"\n    filter: (file) ->\n      file.path.match /\\.coffee$/\n    fn: (file) ->\n      file.blob.readAsText()\n      .then (coffeeSource) ->\n        sourceProgram = CoffeeScript.compile coffeeSource, bare: true\n\n        system.loadModule sourceProgram, file.path\n  }, {\n    name: \"Markdown\"\n    filter: (file) ->\n      file.path.match /\\.md$/\n    fn: openWith(Markdown)\n  }, {\n    name: \"Text Editor\"\n    filter: (file) ->\n      file.type.match(/^text\\//) or\n      file.type is \"application/javascript\"\n    fn: openWith(Notepad)\n  }, {\n    name: \"Spreadsheet\"\n    filter: (file) ->\n      # TODO: This actually only handles JSON arrays\n      file.type is \"application/json\"\n    fn: openWith(Spreadsheet)\n  }, {\n    name: \"Image Viewer\"\n    filter: (file) ->\n      file.type.match /^image\\//\n    fn: openWith(Filter)\n  }, {\n    name: \"Pixel Editor\"\n    filter: (file) ->\n      file.type.match /^image\\//\n    fn: openWith(PixelEditor)\n  }, {\n    name: \"Audio Bro\"\n    filter: (file) ->\n      file.type.match /^audio\\//\n    fn: openWith(AudioBro)\n  }, {\n    name: \"dsad.exe\"\n    filter: (file) ->\n      file.path.match /dsad\\.exe$/\n    fn: ->\n      app = DSad()\n      document.body.appendChild app.element\n  }, {\n    name: \"zine1.exe\"\n    filter: (file) ->\n      file.path.match /zine1\\.exe$/\n    fn: ->\n      require(\"../issues/2016-12\")()\n  }, {\n    name: \"zine2.exe\"\n    filter: (file) ->\n      file.path.match /zine2\\.exe$/\n    fn: ->\n      require(\"../issues/2017-02\")()\n  }, {\n    name: \"zine3.exe\"\n    filter: (file) ->\n      file.path.match /zine3\\.exe$/\n    fn: ->\n      require(\"../issues/2017-03\")()\n  }, {\n    name: \"feedback.exe\"\n    filter: (file) ->\n      file.path.match /feedback\\.exe$/\n    fn: ->\n      require(\"../feedback\")()\n  }]\n\n  # Open JSON arrays in spreadsheet\n  # Open text in notepad\n  handle = (file) ->\n    handler = handlers.find ({filter}) ->\n      filter(file)\n\n    if handler\n      handler.fn(file)\n    else\n      throw new Error \"No handler for files of type #{file.type}\"\n\n  Object.assign self,\n    # Open a file\n    # TODO: Pass arguments\n    # TODO: Drop files on an app to open them in that app\n    open: (file) ->\n      handle(file)\n\n    openersFor: (file) ->\n      handlers.filter (handler) ->\n        handler.filter(file)\n\n  return self\n",
      "mode": "100644",
      "type": "blob"
    },
    "system/module.coffee": {
      "path": "system/module.coffee",
      "content": "# Handles loading and launching files from the fs\n#\n# Depends on having self.readFile defined\n\nmodule.exports = (I, self) ->\n  ###\n  Load a module from a file in the file system.\n\n  Additional properties such as a reference to the global object and some metadata\n  are exposed.\n\n  Returns a promise that is fulfilled when the module assigns its exports, or\n  rejected on error.\n\n  Caches modules so mutual includes don't get re-run per include root.\n\n  Circular includes will never reslove\n  # TODO: Fail early on circular includes, challenging because of async\n\n  # TODO: Succeed on files that don't assign module.exports\n\n  # TODO: Require .coffee/arbitrary files\n  # images, blobs, html, json\n  ###\n\n  {absolutizePath, fileSeparator, normalizePath} = require \"../util\"\n\n  # Wrap program in async include wrapper\n  # Replaces references to require('something') with local variables in an async wrapper function\n  rewriteRequires = (program) ->\n    id = 0\n    namePrefix = \"__req\"\n    requires = {}\n\n    # rewrite requires\n    rewrittenProgram = program.replace /require\\(['\"]([^'\"]+)['\"]\\)/g, (match, key) ->\n      if requires[key]\n        tmpVar = requires[key]\n      else\n        tmpVar = \"#{namePrefix}#{id}\"\n        id += 1\n        requires[key] = tmpVar\n\n      return tmpVar\n\n    tmpVars = Object.keys(requires).map (name) ->\n      requires[name]\n\n    requirePaths = Object.keys(requires)\n    requirePaths = requirePaths\n\n    \"\"\"\n      system.include(#{JSON.stringify(requirePaths)})\n      .then(function(__reqResults) {\n      (function(#{tmpVars.join(', ')}){\n      #{rewrittenProgram}\n      }).apply(this, __reqResults);\n      });\n    \"\"\"\n\n  loadModule = (content, path, state) ->\n    new Promise (resolve, reject) ->\n      program = annotateSourceURL(rewriteRequires(content), path)\n      dirname = path.split(fileSeparator)[0...-1].join(fileSeparator) or fileSeparator\n\n      # May need to scan for a module.exports to see if it is the kind of\n      # module that exports things vs just plain side effects code\n      module =\n        path: dirname\n\n      # This can return false positives if it just matches the string and isn't\n      # really exporting\n      hasExports = program.match /module\\.exports/\n\n      # Use a defineProperty setter on module.exports to trigger when the module\n      # successfully exports because it can all be async madness.\n      exports = {}\n      Object.defineProperty module, \"exports\",\n        get: ->\n          exports\n        set: (newValue) ->\n          exports = newValue\n          # Trigger complete\n          resolve(module)\n\n      # Apply relative path wrapper for system.include\n      localSystem = Object.assign {}, self,\n        include: (moduleIdentifiers) ->\n          relativeIdentifiers = moduleIdentifiers.map (identifier) ->\n            if identifier.match /^\\//\n              absolutizePath \"/\", identifier\n            else\n              absolutizePath dirname, identifier\n\n          self.include relativeIdentifiers, state\n      # TODO: Also make working directory relative paths for readFile and writeFile\n\n      context =\n        system: localSystem\n        global: global\n        module: module\n        exports: module.exports\n        __filename: path\n        __dirname: dirname\n\n      args = Object.keys(context)\n      values = args.map (name) -> context[name]\n\n      Promise.resolve()\n      .then ->\n        Function(args..., program).apply(module, values)\n      .catch reject\n\n      # Just resolve next tick if we're not specifically exporting\n      # can be fun with race conditions, but just export your biz, yo!\n      if !hasExports\n        setTimeout ->\n          resolve(module)\n        , 0\n\n  Object.assign self,\n    # still experimenting with the API\n    # Async include in the vein of require.js\n    # it's horrible but seems necessary\n\n    # This is an internal API and isn't recommended for general use\n    # The state determines an include root and should is the same for a single\n    # app or process\n    # TODO: Rename to something else because this replaces `Model#include`\n    include: (moduleIdentifiers, state={}) ->\n      state.cache ?= {}\n\n      Promise.all moduleIdentifiers.map (absolutePath) ->\n        state.cache[absolutePath] ?= self.loadProgram(absolutePath)\n        .then (sourceProgram) ->\n          loadModule sourceProgram, absolutePath, state\n        .then (module) ->\n          module.exports\n\n    loadProgram: (path, basePath=\"/\") ->\n      self.fs.read absolutizePath(basePath, path)\n      .then (file) ->\n        [compiler] = compilers.filter ({filter}) ->\n          filter file\n\n        if compiler\n          compiler.fn(file)\n        else\n          throw new Error \"Could not find a compiler for file: #{path}\"\n\n    # May want to reconsider this name\n    loadModule: (args...) ->\n      self.Achievement.unlock \"Execute code\"\n      loadModule(args...)\n\n# Compile files based on type to JS program source\ncompilers = [{\n  filter: ({path}) ->\n    path.match /\\.js/\n  fn: ({blob}) ->\n    blob.readAsText()\n}, {\n  filter: ({path}) ->\n    path.match /\\.coffee/\n  fn: ({blob}) ->\n    blob.readAsText()\n    .then (coffeeSource) ->\n      CoffeeScript.compile coffeeSource, bare: true\n}, {\n  filter: ({path}) ->\n    path.match /\\.jadelet/\n  fn: ({blob}) ->\n    blob.readAsText()\n    .then (jadeletSource) ->\n      Hamlet.compile jadeletSource,\n        compiler: CoffeeScript\n        mode: \"jade\"\n        runtime: \"Hamlet\"\n}]\n\nannotateSourceURL = (program, path) ->\n  \"\"\"\n    #{program}\n    //# sourceURL=#{path}\n  \"\"\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "system/template.coffee": {
      "path": "system/template.coffee",
      "content": "# Compile a template from source text\n\nmodule.exports = (I, self) ->\n  self.extend\n    compileTemplate: (source, mode=\"jade\") ->\n      templateSource = Hamlet.compile source,\n        compiler: CoffeeScript\n        mode: mode\n        runtime: \"Hamlet\"\n        exports: false\n\n      Function(\"return \" + templateSource)()\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/achievement-badge.jadelet": {
      "path": "templates/achievement-badge.jadelet",
      "content": "achievement-badge(title=@description @class)\n  = @icon\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/achievement-progress.jadelet": {
      "path": "templates/achievement-progress.jadelet",
      "content": "achievement-progress\n  h2= @name\n  progress(@value)\n  span= @fraction\n  achievement-badges= @badges\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/achievement.jadelet": {
      "path": "templates/achievement.jadelet",
      "content": "achievement\n  icon= @icon\n  h2= @title\n  p= @text\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/chateau.jadelet": {
      "path": "templates/chateau.jadelet",
      "content": "chateau\n  = @canvas\n  word-area\n    = @words\n  form(@submit)\n    input\n    button Speak\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/file.jadelet": {
      "path": "templates/file.jadelet",
      "content": "file(@dblclick @contextmenu @type)\n  icon\n  label= @relativePath\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/folder.jadelet": {
      "path": "templates/folder.jadelet",
      "content": "folder(@dblclick @contextmenu)\n  icon\n  label= @relativePath\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/input.jadelet": {
      "path": "templates/input.jadelet",
      "content": "input(@value @type @min @max @checked)\n",
      "mode": "100644",
      "type": "blob"
    },
    "test/system/module.coffee": {
      "path": "test/system/module.coffee",
      "content": "require \"../../extensions\"\nModel = require \"model\"\nAssociations = require \"../../system/associations\"\nSystemModule = require \"../../system/module\"\n\nglobal.Hamlet = require \"../../lib/hamlet\"\n\nmakeSystemFS = (files) ->\n  model = Model()\n  model.include SystemModule, Associations\n\n  model.fs =\n    read: (path) ->\n      Promise.resolve()\n      .then ->\n        content = files[path]\n  \n        throw new Error \"File not found: #{path}\" unless content?\n\n        path: path\n        blob: new Blob [content]\n\n  return model\n\ndescribe \"System Module\", ->\n  it \"should include modules in files async\", ->\n    model = makeSystemFS\n      \"/test.js\": \"\"\"\n        module.exports = 'yo';\n      \"\"\"\n      \"/root.js\": \"\"\"\n        var test = require('./test.js');\n        var test2 = require(\"./folder/nested.js\");\n        module.exports = test + \" 2 rad \" + test2;\n      \"\"\"\n      \"/folder/nested.js\": \"\"\"\n        module.exports = \"hella\";\n      \"\"\"\n      \"/wat.js\": \"\"\"\n        module.exports = \"wat\";\n      \"\"\"\n      \"/rand.js\": \"\"\"\n        module.exports = Math.random();\n      \"\"\"\n\n    model.include([\"/root.js\", \"/wat.js\", \"/rand.js\", \"/rand.js\"])\n    .then ([root, wat, r1, r2]) ->\n      console.log root, wat, r1, r2\n      assert.equal r1, r2\n      assert.equal root, 'yo 2 rad hella'\n\n  it \"should throw an error when requiring a file that doesn't exist\", (done) ->\n    @timeout 250\n\n    model = makeSystemFS\n      \"/a.js\": \"\"\"\n        module.exports = require(\"./b.js\")\n      \"\"\"\n\n    model.include([\"/a.js\"])\n    .catch (e) ->\n      done()\n\n  it \"should wait forever when resolving circular requires\", (done) ->\n    model = makeSystemFS\n      \"/a.js\": \"\"\"\n        module.exports = require(\"./b.js\")\n      \"\"\"\n      \"/b.js\": \"\"\"\n        module.exports = require(\"./a.js\")\n      \"\"\"\n\n    model.include([\"/a.js\"])\n    .then ([a]) ->\n      # Never get here\n      assert false\n\n    setTimeout ->\n      done()\n    , 100\n\n  it \"should work even if the file doesn't assign to module.exports\", ->\n    model = makeSystemFS\n      \"/wat.js\": \"\"\"\n        exports.yolo = \"wat\";\n      \"\"\"\n\n    model.include [\"/wat.js\"]\n    .then ([wat]) ->\n      assert.equal wat.yolo, \"wat\"\n\n  it \"should work with relative paths in subfolders\", ->\n    model = makeSystemFS\n      \"/main.js\": \"\"\"\n        module.exports = require(\"./folder/a.js\");\n      \"\"\"\n      \"/folder/a.js\": \"\"\"\n        module.exports = require(\"./b.js\");\n      \"\"\"\n      \"/folder/b.js\": \"\"\"\n        module.exports = \"b\";\n      \"\"\"\n\n    model.include [\"/main.js\"]\n    .then ([main]) ->\n      assert.equal main, \"b\"\n\n  it \"should work with absolute paths in subfolders\", ->\n    model = makeSystemFS\n      \"/main.js\": \"\"\"\n        module.exports = require(\"./folder/a.js\");\n      \"\"\"\n      \"/folder/a.js\": \"\"\"\n        module.exports = require(\"/b.js\");\n      \"\"\"\n      \"/b.js\": \"\"\"\n        module.exports = \"b\";\n      \"\"\"\n\n    model.include [\"/main.js\"]\n    .then ([main]) ->\n      assert.equal main, \"b\"\n\n  it \"should require .jadelet sources\", ->\n    model = makeSystemFS\n      \"/main.coffee\": \"\"\"\n        template = require \"./button.jadelet\"\n\n        module.exports =\n          buttonTemplate: template\n      \"\"\"\n      \"/button.jadelet\": \"\"\"\n        button(@click)= @text\n      \"\"\"\n\n    model.include [\"/main.coffee\"]\n    .then ([main]) ->\n      assert typeof main.buttonTemplate is \"function\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "util.coffee": {
      "path": "util.coffee",
      "content": "fileSeparator = \"/\"\n\nnormalizePath = (path) ->\n  path.replace(/\\/\\/+/, fileSeparator) # /// -> /\n  .replace(/\\/[^/]*\\/\\.\\./g, \"\") # /base/something/.. -> /base\n  .replace(/\\/\\.\\//g, fileSeparator) # /base/. -> /base\n\n# NOTE: Allows paths like '../..' to go above the base path\nabsolutizePath = (base, relativePath) ->\n  normalizePath \"/#{base}/#{relativePath}\"\n\nmodule.exports =\n  emptyElement: (element) ->\n    while element.lastChild\n      element.removeChild element.lastChild\n\n  fileSeparator: fileSeparator\n  normalizePath: normalizePath\n  absolutizePath: absolutizePath\n\n  parentElementOfType: (tagname, element) ->\n    tagname = tagname.toLowerCase()\n\n    if element.nodeName.toLowerCase() is tagname\n      return element\n\n    while element = element.parentNode\n      if element.nodeName.toLowerCase() is tagname\n        return element\n",
      "mode": "100644",
      "type": "blob"
    }
  },
  "distribution": {
    "apps/audio-bro": {
      "path": "apps/audio-bro",
      "content": "(function() {\n  var FileIO, Model;\n\n  FileIO = require(\"../os/file-io\");\n\n  Model = require(\"model\");\n\n  module.exports = function() {\n    var Achievement, ContextMenu, MenuBar, Modal, Progress, Window, audio, handlers, menuBar, parseMenu, windowView, _ref, _ref1;\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Progress = _ref.Progress, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    Achievement = system.Achievement;\n    Achievement.unlock(\"Pump up the jam\");\n    audio = document.createElement('audio');\n    audio.controls = true;\n    audio.autoplay = true;\n    handlers = Model().include(FileIO).extend({\n      loadFile: function(blob) {\n        return audio.src = URL.createObjectURL(blob);\n      },\n      exit: function() {\n        return windowView.element.remove();\n      }\n    });\n    menuBar = MenuBar({\n      items: parseMenu(\"[F]ile\\n  [O]pen\\n  -\\n  E[x]it\"),\n      handlers: handlers\n    });\n    windowView = Window({\n      title: \"Audio Bro\",\n      content: audio,\n      menuBar: menuBar.element,\n      width: 308,\n      height: 80\n    });\n    windowView.loadFile = handlers.loadFile;\n    return windowView;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/chateau": {
      "path": "apps/chateau",
      "content": "(function() {\n  var IFrameApp;\n\n  IFrameApp = require(\"../lib/iframe-app\");\n\n  module.exports = function() {\n    var Achievement, app;\n    Achievement = system.Achievement;\n    app = IFrameApp({\n      src: \"https://danielx.net/chateau/\",\n      width: 960,\n      height: 540,\n      title: \"Chateau\"\n    });\n    app.on(\"event\", function(name) {\n      switch (name) {\n        case \"login\":\n          return Achievement.unlock(\"Enter the Chateau\");\n        case \"custom-avatar\":\n          return Achievement.unlock(\"Puttin' on the Ritz\");\n        case \"custom-background\":\n          return Achievement.unlock(\"Paint the town red\");\n        case \"file-upload\":\n          return Achievement.unlock(\"It's in the cloud\");\n      }\n    });\n    return app;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/contrasaurus": {
      "path": "apps/contrasaurus",
      "content": "(function() {\n  var IFrameApp;\n\n  IFrameApp = require(\"../lib/iframe-app\");\n\n  module.exports = function() {\n    var Achievement, app;\n    Achievement = system.Achievement;\n    app = IFrameApp({\n      src: \"https://contrasaur.us/\",\n      width: 960,\n      height: 540,\n      title: \"Contrasaurus: Defender of the American Dream\"\n    });\n    Achievement.unlock(\"Rawr\");\n    app.on(\"event\", function(name) {\n      switch (name) {\n        case \"win\":\n          return Achievement.unlock(\"A winner is you\");\n      }\n    });\n    return app;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/dungeon-of-sadness": {
      "path": "apps/dungeon-of-sadness",
      "content": "(function() {\n  var Model;\n\n  Model = require(\"model\");\n\n  module.exports = function() {\n    var ContextMenu, MenuBar, Modal, Observable, Progress, Table, Window, frame, parseMenu, windowView, _ref, _ref1;\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Observable = _ref.Observable, Progress = _ref.Progress, Table = _ref.Table, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    frame = document.createElement(\"iframe\");\n    frame.src = \"https://danielx.net/ld33/\";\n    system.Achievement.unlock(\"The dungeon is in our heart\");\n    windowView = Window({\n      title: \"Dungeon of Sadness\",\n      content: frame,\n      menuBar: null,\n      width: 648,\n      height: 507\n    });\n    return windowView;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/explorer": {
      "path": "apps/explorer",
      "content": "(function() {\n  var Drop, Explorer, FileTemplate, FolderTemplate, emptyElement;\n\n  Drop = require(\"../lib/drop\");\n\n  FileTemplate = require(\"../templates/file\");\n\n  FolderTemplate = require(\"../templates/folder\");\n\n  emptyElement = require(\"../util\").emptyElement;\n\n  module.exports = Explorer = function(options) {\n    var ContextMenu, MenuBar, Modal, Progress, Window, addWindow, contextMenuFor, contextMenuForFolder, explorer, parseMenu, path, update, _ref, _ref1;\n    if (options == null) {\n      options = {};\n    }\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Progress = _ref.Progress, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    path = options.path;\n    if (path == null) {\n      path = '/';\n    }\n    explorer = document.createElement(\"explorer\");\n    Drop(explorer, function(e) {\n      var files;\n      files = e.dataTransfer.files;\n      if (files.length) {\n        return files.forEach(function(file) {\n          var newPath;\n          newPath = path + file.name;\n          return system.writeFile(newPath, file, true);\n        });\n      }\n    });\n    contextMenuFor = function(file, e) {\n      var contextMenu, contextMenuHandlers, openWithMenu, openerOptions, openers;\n      if (e.defaultPrevented) {\n        return;\n      }\n      e.preventDefault();\n      contextMenuHandlers = {\n        open: function() {\n          return system.open(file);\n        },\n        openWith: function() {},\n        cut: function() {},\n        copy: function() {},\n        \"delete\": function() {\n          return system.deleteFile(file.path);\n        },\n        rename: function() {\n          return Modal.prompt(\"Filename\", file.path).then(function(newPath) {\n            if (newPath) {\n              system.deleteFile(file.path);\n              return system.writeFile(newPath, file.blob);\n            }\n          });\n        },\n        properties: function() {},\n        editMIMEType: function() {\n          return Modal.prompt(\"MIME Type\", file.type).then(function(newType) {\n            if (newType) {\n              return system.updateFile(file.path, {\n                type: newType\n              }).then(console.log);\n            }\n          });\n        }\n      };\n      openers = system.openersFor(file);\n      openerOptions = openers.map(function(_arg, i) {\n        var fn, handlerName, name;\n        name = _arg.name, fn = _arg.fn;\n        handlerName = \"opener\" + i;\n        contextMenuHandlers[handlerName] = function() {\n          return fn(file);\n        };\n        return \"  \" + name + \" -> \" + handlerName;\n      }).join(\"\\n\");\n      openWithMenu = \"\";\n      if (openers.length > 0) {\n        openWithMenu = \"Open With\\n\" + openerOptions;\n      }\n      contextMenu = ContextMenu({\n        items: parseMenu(\"Open\\n\" + openWithMenu + \"\\n-\\nCut\\nCopy\\n-\\nDelete\\nRename\\n-\\nEdit MIME Type\\nProperties\"),\n        handlers: contextMenuHandlers\n      });\n      return contextMenu.display({\n        inElement: document.body,\n        x: e.pageX,\n        y: e.pageY\n      });\n    };\n    contextMenuForFolder = function(folder, e) {\n      var contextMenu;\n      if (e.defaultPrevented) {\n        return;\n      }\n      e.preventDefault();\n      contextMenu = ContextMenu({\n        items: parseMenu(\"Open\\n-\\nCut\\nCopy\\n-\\nDelete\\nRename\\n-\\nProperties\"),\n        handlers: {\n          open: function() {\n            return addWindow(folder.path);\n          },\n          \"delete\": function() {},\n          rename: function() {},\n          properties: function() {}\n        }\n      });\n      return contextMenu.display({\n        inElement: document.body,\n        x: e.pageX,\n        y: e.pageY\n      });\n    };\n    update = function() {\n      return system.fs.list(path).then(function(files) {\n        var addedFolders;\n        emptyElement(explorer);\n        addedFolders = {};\n        files.forEach(function(file) {\n          var fileElement, folderPath, url;\n          if (file.relativePath.match(/\\//)) {\n            folderPath = file.relativePath.replace(/\\/.*$/, \"\");\n            addedFolders[folderPath] = true;\n            return;\n          }\n          file.dblclick = function() {\n            console.log(\"dblclick\", file);\n            return system.open(file);\n          };\n          file.contextmenu = function(e) {\n            return contextMenuFor(file, e);\n          };\n          fileElement = FileTemplate(file);\n          if (file.type.match(/^image\\//)) {\n            url = URL.createObjectURL(file.blob);\n            fileElement.querySelector('icon').style.backgroundImage = \"url(\" + url + \")\";\n          }\n          return explorer.appendChild(fileElement);\n        });\n        return Object.keys(addedFolders).forEach(function(folderName) {\n          var folder, folderElement;\n          folder = {\n            path: \"\" + path + folderName + \"/\",\n            relativePath: folderName,\n            contextmenu: function(e) {\n              return contextMenuForFolder(folder, e);\n            },\n            dblclick: function() {\n              return addWindow(folder.path);\n            }\n          };\n          folderElement = FolderTemplate(folder);\n          return explorer.insertBefore(folderElement, explorer.firstChild);\n        });\n      });\n    };\n    update();\n    system.fs.on(\"write\", function(path) {\n      return update();\n    });\n    system.fs.on(\"delete\", function(path) {\n      return update();\n    });\n    system.fs.on(\"update\", function(path) {\n      return update();\n    });\n    addWindow = function(path) {\n      var element, windowView;\n      element = document.createElement(\"container\");\n      element.appendChild(Explorer({\n        path: path\n      }));\n      windowView = Window({\n        title: path,\n        content: element,\n        menuBar: null,\n        width: 640,\n        height: 480\n      });\n      return document.body.appendChild(windowView.element);\n    };\n    return explorer;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/filter": {
      "path": "apps/filter",
      "content": "(function() {\n  var FileIO, Model;\n\n  FileIO = require(\"../os/file-io\");\n\n  Model = require(\"model\");\n\n  module.exports = function() {\n    var ContextMenu, MenuBar, Modal, Progress, Window, canvas, context, handlers, menuBar, modalForm, parseMenu, windowView, _ref, _ref1;\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Progress = _ref.Progress, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    system.Achievement.unlock(\"Look at that\");\n    canvas = document.createElement('canvas');\n    context = canvas.getContext('2d');\n    modalForm = system.compileTemplate(\"form\\n  label\\n    h2 Width\\n    input(name=\\\"width\\\")\\n  label\\n    h2 Height\\n    input(name=\\\"height\\\")\");\n    handlers = Model().include(FileIO).extend({\n      loadFile: function(blob) {\n        return Image.fromBlob(blob).then(function(img) {\n          canvas.width = img.width;\n          canvas.height = img.height;\n          return context.drawImage(img, 0, 0);\n        });\n      },\n      saveData: function() {\n        return new Promise(function(resolve) {\n          return canvas.toBlob(resolve);\n        });\n      },\n      exit: function() {\n        return windowView.element.remove();\n      },\n      crop: function() {\n        return Modal.form(modalForm()).then(console.log);\n      }\n    });\n    menuBar = MenuBar({\n      items: parseMenu(\"[F]ile\\n  [O]pen\\n  [S]ave\\n  Save [A]s\\n  -\\n  E[x]it\\n[E]dit\\n  [C]rop\\n  [F]ilter\"),\n      handlers: handlers\n    });\n    windowView = Window({\n      title: \"Spectacle Image Viewer\",\n      content: canvas,\n      menuBar: menuBar.element,\n      width: 640,\n      height: 480\n    });\n    windowView.loadFile = handlers.loadFile;\n    return windowView;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/markdown": {
      "path": "apps/markdown",
      "content": "(function() {\n  var FileIO, Model;\n\n  FileIO = require(\"../os/file-io\");\n\n  Model = require(\"model\");\n\n  module.exports = function() {\n    var ContextMenu, MenuBar, Modal, Progress, Window, container, handlers, menuBar, parseMenu, windowView, _ref, _ref1;\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Progress = _ref.Progress, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    container = document.createElement('container');\n    container.style.padding = \"1em\";\n    handlers = Model().include(FileIO).extend({\n      loadFile: function(blob) {\n        return blob.readAsText().then(function(textContent) {\n          return container.innerHTML = marked(textContent);\n        });\n      },\n      saveData: function() {},\n      exit: function() {\n        return windowView.element.remove();\n      }\n    });\n    menuBar = MenuBar({\n      items: parseMenu(\"[F]ile\\n  [O]pen\\n  -\\n  E[x]it\"),\n      handlers: handlers\n    });\n    windowView = Window({\n      title: \"Markdown\",\n      content: container,\n      menuBar: menuBar.element,\n      width: 720,\n      height: 480\n    });\n    windowView.loadFile = handlers.loadFile;\n    return windowView;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/notepad": {
      "path": "apps/notepad",
      "content": "(function() {\n  var FileIO, Model;\n\n  FileIO = require(\"../os/file-io\");\n\n  Model = require(\"model\");\n\n  module.exports = function() {\n    var ContextMenu, MenuBar, Modal, Progress, TODO, Window, exec, handlers, menuBar, parseMenu, textarea, windowView, _ref, _ref1;\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Progress = _ref.Progress, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    system.Achievement.unlock(\"Notepad.exe\");\n    exec = function(cmd) {\n      return function() {\n        textarea.focus();\n        return document.execCommand(cmd);\n      };\n    };\n    TODO = function() {\n      return console.log(\"TODO\");\n    };\n    textarea = document.createElement(\"textarea\");\n    textarea.spellcheck = false;\n    handlers = Model().include(FileIO).extend({\n      loadFile: function(blob, path) {\n        return blob.readAsText().then(function(text) {\n          handlers.currentPath(path);\n          return textarea.value = text;\n        });\n      },\n      newFile: function() {\n        return textarea.value = \"\";\n      },\n      saveData: function() {\n        var data;\n        data = new Blob([textarea.value], {\n          type: \"text/plain\"\n        });\n        return Promise.resolve(data);\n      },\n      pageSetup: TODO,\n      print: TODO,\n      exit: function() {\n        return windowView.element.remove();\n      },\n      undo: exec(\"undo\"),\n      redo: exec(\"redo\"),\n      cut: exec(\"cut\"),\n      copy: exec(\"copy\"),\n      paste: exec(\"paste\"),\n      \"delete\": exec(\"delete\"),\n      find: TODO,\n      findNext: TODO,\n      replace: TODO,\n      goTo: TODO,\n      selectAll: function() {\n        return textarea.select();\n      },\n      timeDate: function() {\n        var dateText;\n        textarea.focus();\n        dateText = (new Date).toString().split(\" \").slice(0, -4).join(\" \");\n        return document.execCommand(\"insertText\", false, dateText);\n      },\n      wordWrap: TODO,\n      font: function() {\n        return Modal.prompt(\"Font\", textarea.style.fontFamily || \"monospace\").then(function(font) {\n          if (font) {\n            return textarea.style.fontFamily = font;\n          }\n        });\n      },\n      statusBar: TODO,\n      viewHelp: TODO,\n      aboutNotepad: TODO\n    });\n    menuBar = MenuBar({\n      items: parseMenu(\"[F]ile\\n  [N]ew\\n  [O]pen\\n  [S]ave\\n  Save [A]s\\n  -\\n  Page Set[u]p\\n  [P]rint\\n  -\\n  E[x]it\\n[E]dit\\n  [U]ndo\\n  Redo\\n  -\\n  Cu[t]\\n  [C]opy\\n  [P]aste\\n  De[l]ete\\n  -\\n  [F]ind\\n  Find [N]ext\\n  [R]eplace\\n  [G]o To\\n  -\\n  Select [A]ll\\n  Time/[D]ate\\nF[o]rmat\\n  [W]ord Wrap\\n  [F]ont...\\n[V]iew\\n  [S]tatus Bar\\n[H]elp\\n  View [H]elp\\n  -\\n  [A]bout Notepad\"),\n      handlers: handlers\n    });\n    windowView = Window({\n      title: function() {\n        var path;\n        path = handlers.currentPath();\n        if (path) {\n          return \"Notepad.exe [\" + path + \"]\";\n        } else {\n          return \"Notepad.exe\";\n        }\n      },\n      content: textarea,\n      menuBar: menuBar.element,\n      width: 640,\n      height: 480\n    });\n    windowView.loadFile = handlers.loadFile;\n    return windowView;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/pixel": {
      "path": "apps/pixel",
      "content": "(function() {\n  var FileIO, Model, Postmaster;\n\n  Model = require(\"model\");\n\n  Postmaster = require(\"postmaster\");\n\n  FileIO = require(\"../os/file-io\");\n\n  module.exports = function() {\n    var ContextMenu, MenuBar, Modal, Observable, Progress, Table, Window, frame, handlers, loadedPromise, menuBar, parseMenu, postmaster, resolveLoaded, windowView, _ref, _ref1;\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Observable = _ref.Observable, Progress = _ref.Progress, Table = _ref.Table, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    frame = document.createElement(\"iframe\");\n    frame.src = \"https://danielx.net/pixel-editor/\";\n    resolveLoaded = null;\n    loadedPromise = new Promise(function(resolve) {\n      return resolveLoaded = resolve;\n    });\n    postmaster = Postmaster();\n    postmaster.remoteTarget = function() {\n      return frame.contentWindow;\n    };\n    Object.assign(postmaster, {\n      childLoaded: function() {\n        console.log(\"child loaded\");\n        return resolveLoaded();\n      },\n      save: function() {\n        return handlers.save();\n      }\n    });\n    handlers = Model().include(FileIO).extend({\n      loadFile: function(blob) {\n        return loadedPromise.then(function() {\n          return postmaster.invokeRemote(\"loadFile\", blob);\n        });\n      },\n      newFile: function() {},\n      saveData: function() {\n        return postmaster.invokeRemote(\"getBlob\");\n      }\n    });\n    menuBar = MenuBar({\n      items: parseMenu(\"[F]ile\\n  [N]ew\\n  [O]pen\\n  [S]ave\\n  Save [A]s\\n  -\\n  E[x]it\\n[H]elp\\n  View [H]elp\\n  -\\n  [A]bout\"),\n      handlers: handlers\n    });\n    windowView = Window({\n      title: Observable(\"Pixie Paint\"),\n      content: frame,\n      menuBar: menuBar.element,\n      width: 640,\n      height: 480\n    });\n    windowView.loadFile = handlers.loadFile;\n    system.Achievement.unlock(\"Pixel perfect\");\n    return windowView;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/spreadsheet": {
      "path": "apps/spreadsheet",
      "content": "(function() {\n  var FileIO, Model,\n    __slice = [].slice;\n\n  FileIO = require(\"../os/file-io\");\n\n  Model = require(\"model\");\n\n  module.exports = function() {\n    var ContextMenu, InputTemplate, MenuBar, Modal, Observable, Progress, RowElement, RowModel, Table, Window, element, handlers, headers, menuBar, models, parseMenu, sourceData, tableView, windowView, _ref, _ref1;\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Observable = _ref.Observable, Progress = _ref.Progress, Table = _ref.Table, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    system.Achievement.unlock(\"Microsoft Access 97\");\n    sourceData = [];\n    headers = [\"id\", \"name\", \"color\"];\n    RowModel = function(datum) {\n      var _ref2;\n      return (_ref2 = Model(datum)).attrObservable.apply(_ref2, headers);\n    };\n    models = sourceData.map(RowModel);\n    InputTemplate = require(\"../templates/input\");\n    RowElement = function(datum) {\n      var tr, types;\n      tr = document.createElement(\"tr\");\n      types = [\"number\", \"text\", \"color\"];\n      headers.forEach(function(key, i) {\n        var td;\n        td = document.createElement(\"td\");\n        td.appendChild(InputTemplate({\n          value: datum[key],\n          type: types[i]\n        }));\n        return tr.appendChild(td);\n      });\n      return tr;\n    };\n    element = (tableView = Table({\n      data: models,\n      RowElement: RowElement,\n      headers: headers\n    })).element;\n    handlers = Model().include(FileIO).extend({\n      loadFile: function(blob) {\n        return blob.readAsJSON().then(function(json) {\n          console.log(json);\n          if (!Array.isArray(json)) {\n            throw new Error(\"Data must be an array\");\n          }\n          sourceData = json;\n          models.splice.apply(models, [0, models.length].concat(__slice.call(sourceData.map(RowModel))));\n          return tableView.render();\n        });\n      },\n      newFile: function() {},\n      saveData: function() {\n        return Promise.resolve(new Blob([JSON.stringify(sourceData)], {\n          type: \"application/json\"\n        }));\n      },\n      about: function() {\n        return Modal.alert(\"Spreadsheet v0.0.1 by Daniel X Moore\");\n      },\n      insertRow: function() {\n        var datum;\n        datum = {\n          id: 0,\n          name: \"new\",\n          color: \"#FF00FF\"\n        };\n        sourceData.push(datum);\n        models.push(RowModel(datum));\n        return tableView.render();\n      },\n      exit: function() {\n        return windowView.element.remove();\n      }\n    });\n    menuBar = MenuBar({\n      items: parseMenu(\"[F]ile\\n  [N]ew\\n  [O]pen\\n  [S]ave\\n  Save [A]s\\n  -\\n  E[x]it\\nInsert\\n  Row -> insertRow\\nHelp\\n  About\"),\n      handlers: handlers\n    });\n    windowView = Window({\n      title: \"MS Access 97 [DEMO VERSION]\",\n      content: element,\n      menuBar: menuBar.element,\n      width: 640,\n      height: 480\n    });\n    windowView.loadFile = handlers.loadFile;\n    return windowView;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "apps/text-editor": {
      "path": "apps/text-editor",
      "content": "(function() {\n  var FileIO, Model, extraModes, mode;\n\n  Model = require(\"model\");\n\n  FileIO = require(\"../os/file-io\");\n\n  ace.require(\"ace/ext/language_tools\");\n\n  extraModes = {\n    jadelet: \"jade\"\n  };\n\n  mode = function(mode) {\n    return extraModes[mode] || mode;\n  };\n\n  module.exports = function() {\n    var ContextMenu, MenuBar, Modal, Observable, Progress, Table, Window, aceEditor, aceElement, aceWrap, handlers, initSession, menuBar, parseMenu, session, windowView, _ref, _ref1;\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Observable = _ref.Observable, Progress = _ref.Progress, Table = _ref.Table, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    system.Achievement.unlock(\"Notepad.exe\");\n    aceWrap = document.createElement(\"div\");\n    aceWrap.style.width = aceWrap.style.height = \"100%\";\n    aceElement = document.createElement(\"div\");\n    aceElement.style.width = aceElement.style.height = \"100%\";\n    aceWrap.appendChild(aceElement);\n    aceEditor = ace.edit(aceElement);\n    aceEditor.$blockScrolling = Infinity;\n    aceEditor.setOptions({\n      fontSize: \"16px\",\n      enableBasicAutocompletion: true,\n      enableLiveAutocompletion: true,\n      highlightActiveLine: true\n    });\n    session = aceEditor.getSession();\n    session.setUseSoftTabs(true);\n    session.setTabSize(2);\n    mode = \"coffee\";\n    session.setMode(\"ace/mode/\" + mode);\n    global.aceEditor = aceEditor;\n    initSession = function(file, path) {\n      return file.readAsText().then(function(content) {\n        if (path) {\n          handlers.currentFile(path);\n        }\n        session.setValue(content);\n        mode = \"coffee\";\n        return session.setMode(\"ace/mode/\" + mode);\n      });\n    };\n    handlers = Model().include(FileIO).extend({\n      loadFile: initSession,\n      newFile: function() {\n        return session.setValue(\"\");\n      },\n      saveData: function() {\n        var data;\n        data = new Blob([session.getValue()], {\n          type: \"text/plain\"\n        });\n        return Promise.resolve(data);\n      }\n    });\n    menuBar = MenuBar({\n      items: parseMenu(\"[F]ile\\n  [N]ew\\n  [O]pen\\n  [S]ave\\n  Save [A]s\\n  -\\n  E[x]it\\n[H]elp\\n  View [H]elp\\n  -\\n  [A]bout\"),\n      handlers: handlers\n    });\n    windowView = Window({\n      title: Observable(\"Ace\"),\n      content: aceWrap,\n      menuBar: menuBar.element,\n      width: 640,\n      height: 480\n    });\n    windowView.loadFile = initSession;\n    windowView.on(\"resize\", function() {\n      return aceEditor.resize();\n    });\n    return windowView;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "extensions": {
      "path": "extensions",
      "content": "(function() {\n  var _base,\n    __slice = [].slice;\n\n  Blob.prototype.readAsText = function() {\n    var file;\n    file = this;\n    return new Promise(function(resolve, reject) {\n      var reader;\n      reader = new FileReader;\n      reader.onload = function() {\n        return resolve(reader.result);\n      };\n      reader.onerror = reject;\n      return reader.readAsText(file);\n    });\n  };\n\n  Blob.prototype.readAsJSON = function() {\n    return this.readAsText().then(JSON.parse);\n  };\n\n  Blob.prototype.readAsDataURL = function() {\n    var file;\n    file = this;\n    return new Promise(function(resolve, reject) {\n      var reader;\n      reader = new FileReader;\n      reader.onload = function() {\n        return resolve(reader.result);\n      };\n      reader.onerror = reject;\n      return reader.readAsDataURL(file);\n    });\n  };\n\n  Image.fromBlob = function(blob) {\n    return new Promise(function(resolve, reject) {\n      var img;\n      img = new Image;\n      img.onload = function() {\n        return resolve(img);\n      };\n      img.onerror = reject;\n      return img.src = URL.createObjectURL(blob);\n    });\n  };\n\n  if ((_base = FileList.prototype).forEach == null) {\n    _base.forEach = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return Array.prototype.forEach.apply(this, args);\n    };\n  }\n\n}).call(this);\n",
      "type": "blob"
    },
    "feedback": {
      "path": "feedback",
      "content": "(function() {\n  module.exports = function() {\n    var Window, iframe, windowView;\n    iframe = document.createElement(\"iframe\");\n    iframe.src = \"https://docs.google.com/forms/d/e/1FAIpQLSfAK8ZYmMd4-XsDqyTK4soYGWApGD9R33nReuqwG-TxjXaGFg/viewform?embedded=true\";\n    Window = system.UI.Window;\n    windowView = Window({\n      title: \"Whimsy Space Feedback\",\n      content: iframe,\n      menuBar: null,\n      width: 600,\n      height: 500\n    });\n    system.Achievement.unlock(\"We value your input\");\n    return document.body.appendChild(windowView.element);\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "issues/2016-12": {
      "path": "issues/2016-12",
      "content": "(function() {\n  var Ajax, CommentFormTemplate, CommentsTemplate, Notepad, ajax, issueTag;\n\n  Notepad = require(\"../apps/notepad\");\n\n  CommentFormTemplate = require(\"../social/comment-form\");\n\n  CommentsTemplate = require(\"../social/comments\");\n\n  Ajax = require(\"ajax\");\n\n  ajax = Ajax();\n\n  issueTag = \"2016-12\";\n\n  module.exports = function() {\n    var ContextMenu, MenuBar, Modal, Progress, Window, handlers, img, menuBar, parseMenu, windowView, _ref, _ref1;\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Progress = _ref.Progress, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    system.Achievement.unlock(\"Issue 1\");\n    img = document.createElement(\"img\");\n    img.src = \"https://68.media.tumblr.com/6a141d69564a29ac7d4071df5d519808/tumblr_o0rbb4TA1k1urr1ryo1_500.gif\";\n    handlers = {\n      waitAroundForABit: function() {\n        var initialMessage, intervalId, progressView;\n        initialMessage = \"Waiting\";\n        progressView = Progress({\n          value: 0,\n          max: 2,\n          message: initialMessage\n        });\n        Modal.show(progressView.element, {\n          cancellable: false\n        });\n        return intervalId = setInterval(function() {\n          var ellipses, ellipsesCount, newValue, _i, _results;\n          newValue = progressView.value() + 1 / 60;\n          ellipsesCount = Math.floor(newValue * 4) % 4;\n          ellipses = (function() {\n            _results = [];\n            for (var _i = 0; 0 <= ellipsesCount ? _i < ellipsesCount : _i > ellipsesCount; 0 <= ellipsesCount ? _i++ : _i--){ _results.push(_i); }\n            return _results;\n          }).apply(this).map(function() {\n            return \".\";\n          }).join(\"\");\n          progressView.value(newValue);\n          progressView.message(initialMessage + ellipses);\n          if (newValue > 2) {\n            system.Achievement.unlock(\"No rush\");\n            clearInterval(intervalId);\n            return Modal.hide();\n          }\n        }, 15);\n      },\n      comment: function() {\n        return Modal.form(CommentFormTemplate({\n          area: issueTag\n        })).then(function(data) {\n          return ajax({\n            url: \"https://whimsy-space.gomix.me/comments\",\n            data: JSON.stringify(data),\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\"\n          });\n        }).then(function() {\n          return handlers.viewComments();\n        });\n      },\n      viewComments: function() {\n        return ajax.getJSON(\"https://whimsy-space.gomix.me/comments/\" + issueTag).then(function(data) {\n          data = data.reverse();\n          if (data.length === 0) {\n            data = [\n              {\n                body: \"no comments\",\n                author: \"mgmt\"\n              }\n            ];\n          }\n          return Modal.show(CommentsTemplate(data));\n        });\n      },\n      like: function() {\n        return Modal.alert(\"I like you too, but we don't have a facebook or anything yet :)\");\n      },\n      subscribe: function() {\n        return require(\"../mailchimp\").show();\n      },\n      notepadexe: function() {\n        var app;\n        app = Notepad();\n        return document.body.appendChild(app.element);\n      },\n      mSAccess97: function() {\n        var app;\n        app = Spreadsheet();\n        return document.body.appendChild(app.element);\n      },\n      mysterySmell: function() {\n        var div, storyWindow;\n        system.Achievement.unlock(\"Cover-2-cover\");\n        div = document.createElement(\"div\");\n        div.textContent = require(\"../stories/mystery-smell\");\n        div.style.padding = \"1em\";\n        div.style.whiteSpace = \"pre-wrap\";\n        div.style.textAlign = \"justify\";\n        storyWindow = Window({\n          title: \"Mystery Smell\",\n          content: div,\n          width: 380,\n          height: 480\n        });\n        return document.body.appendChild(storyWindow.element);\n      }\n    };\n    menuBar = MenuBar({\n      items: parseMenu(\"[H]ello\\n  [W]ait Around For A Bit\\n[A]pps\\n  [N]otepad.exe\\n[S]tories\\n  [M]ystery Smell\\nS[o]cial Media\\n  [V]iew Comments\\n  [C]omment\\n  [L]ike\\n  [S]ubscribe\"),\n      handlers: handlers\n    });\n    windowView = Window({\n      title: \"ZineOS Volume 1 | Issue 1 | December 2016\",\n      content: img,\n      menuBar: menuBar.element,\n      width: 508,\n      height: 604\n    });\n    return document.body.appendChild(windowView.element);\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "issues/2017-02": {
      "path": "issues/2017-02",
      "content": "(function() {\n  var Achievement, Chateau, Model, PixiePaint, Social, Spreadsheet, TextEditor, emptyElement, parentElementOfType, _ref;\n\n  Achievement = require(\"../lib/achievement\");\n\n  Model = require(\"model\");\n\n  Chateau = require(\"../apps/chateau\");\n\n  PixiePaint = require(\"../apps/pixel\");\n\n  Spreadsheet = require(\"../apps/spreadsheet\");\n\n  TextEditor = require(\"../apps/text-editor\");\n\n  Social = require(\"../social/social\");\n\n  _ref = require(\"../util\"), parentElementOfType = _ref.parentElementOfType, emptyElement = _ref.emptyElement;\n\n  module.exports = function() {\n    var ContextMenu, MenuBar, Modal, Progress, Window, container, currentPage, displayPage, handlers, menuBar, nextPage, pages, parseMenu, visited, windowView, _ref1, _ref2;\n    _ref1 = system.UI, ContextMenu = _ref1.ContextMenu, MenuBar = _ref1.MenuBar, Modal = _ref1.Modal, Progress = _ref1.Progress, (_ref2 = _ref1.Util, parseMenu = _ref2.parseMenu), Window = _ref1.Window;\n    container = document.createElement(\"container\");\n    system.Achievement.unlock(\"Issue 2\");\n    system.writeFile(\"issue-2/around.md\", new Blob([require(\"../stories/around-the-world\")], {\n      type: \"text/markdown\"\n    }));\n    system.writeFile(\"issue-2/provision.txt\", new Blob([require(\"../stories/provision\")], {\n      type: \"text/plain\"\n    }));\n    system.writeFile(\"issue-2/dungeon-dog.txt\", new Blob([require(\"../stories/dungeon-dog\")], {\n      type: \"text/plain\"\n    }));\n    system.writeFile(\"issue-2/dsad.exe\", new Blob([\"\"], {\n      type: \"application/exe\"\n    }));\n    pages = {\n      front: \"a(href=\\\"#vista\\\")\\n  img(src=\\\"https://s-media-cache-ak0.pinimg.com/originals/a3/ba/56/a3ba56cef667d14b54023cd624d4e070.jpg\\\")\",\n      vista: \"a(href=\\\"#table\\\")\\n  img(width=640 height=\\\"auto\\\" src=\\\"https://books.google.com/books/content?id=2cgDAAAAMBAJ&rview=1&pg=PA10&img=1&zoom=3&hl=en&sig=ACfU3U3477L46r0KxSQusJrQ6w9qxIQ70w&w=1280\\\")\",\n      table: \"div(style=\\\"padding: 1em;\\\")\\n  h1 Table of Contents\\n  ul\\n    li\\n      a(href=\\\"#front\\\") Cover\\n    li\\n      a(href=\\\"#vista\\\") Excerpt from Windows Vista Magazine\\n    li\\n      a(href=\\\"#table\\\") Table of Contents\\n    li\\n      a(href=\\\"#random\\\") Random Thoughts\\n    li\\n      a(href=\\\"#cheevos\\\") Cheevos\\n    li\\n      a(href=\\\"#contributors\\\") Contributors\",\n      random: \"div(style=\\\"padding: 1em;\\\")\\n  h1 Random Thoughts\\n  p Don't you hate it when you're cooking something and you look at the stove clock and think it's 3:75 and you're late for your appointment but it was just the temperature and also 3:75 isn't even a real time?\\n  p I suggest you bone up a bit on torts before the next attempt at the bar exam.\\n  p Does anyone remember thepalace.com avatar based chat and virtual worlds?\\n  p Those spreadsheets you like are going back in style.\",\n      cheevos: \"div(style=\\\"padding: 1em;\\\")\\n  h1 Cheevos\\n\\n  p No matter if you guy/girl or whatever, Cheevos impress people. It's almost like saying 'Well, I got tons of Cheevos. There are tons of people online that are interested and respect me.\\\"\\n\\n  p You might be thinking 'Oh that's complete BS, I personally don't care about Cheevos when dating'. And yeah, you are probably telling the truth, but it's in your sub-concious.  Sort of like how girls always like the bad guy, but never admit it.\\n\\n  p Braggin about your Cheevos sometimes makes you look conceited, but that's a good thing.  It like how celebraties look conceited because they're rolling VIP into clubs and you're stuck in line.\\n\\n  p 'Brewer' asks 'What happens if you're cheevo talking at a bar, club or party and someone says they have more cheevos that you?'\\n\\n  p Well, hopefully they are just hating and are lying. First look up their score with your cellphone, make sure you have a page bookmarked where you can check. If you catch them in a lie, you look even better. If they are telling the truth and have more Cheevos than you, leave. Nothing else you can do. Buy the person a drink and leave, unless you're willing to look 2nd best. If you brought a date, odds are she's going to be impressed with the higher gamer score and ditch you. Get out as soon as you can and go to some other party.\\n\\n  p\\n    a(href=\\\"http://cheevos.com\\\") Learn more about cheevos from Bboy360 at cheevos.com\\n\",\n      contributors: \"div(style=\\\"padding: 1em;\\\")\\n  h1 Contributors\\n  ul\\n    li Daniel X\\n    li Lan\\n    li pketh\\n    li Mayor\\n    li and you!\\n\\n  p\\n    a(href=\\\"#table\\\") Return to table of contents\"\n    };\n    Object.keys(pages).forEach(function(pageName) {\n      var value;\n      value = pages[pageName];\n      return pages[pageName] = system.compileTemplate(value)({});\n    });\n    pages.cheevos.appendChild(system.Achievement.progressView());\n    handlers = Model().include(Social).extend({\n      area: function() {\n        return \"2017-01\";\n      },\n      mSAccess97: function() {\n        var app;\n        app = Spreadsheet(system);\n        return document.body.appendChild(app.element);\n      },\n      textEditor: function() {\n        var app;\n        app = TextEditor(system);\n        return document.body.appendChild(app.element);\n      },\n      pixiePaint: function() {\n        var app;\n        app = PixiePaint(system);\n        return document.body.appendChild(app.element);\n      },\n      chateau: function() {\n        var app;\n        app = Chateau(system);\n        return document.body.appendChild(app.element);\n      },\n      credits: function() {\n        return displayPage(\"contributors\");\n      },\n      tableofContents: function() {\n        return displayPage(\"table\");\n      }\n    });\n    menuBar = MenuBar({\n      items: parseMenu(\"[A]pps\\n  [T]ext Editor\\n  [P]ixie Paint\\n\" + Social.menuText + \"\\nH[e]lp\\n  [T]able of Contents\\n  [C]redits\"),\n      handlers: handlers\n    });\n    windowView = Window({\n      title: \"ZineOS Volume 1 | Issue 2 | ENTER THE DUNGEON | February 2017\",\n      content: container,\n      menuBar: menuBar.element,\n      width: 1228,\n      height: 936,\n      x: 32,\n      y: 32\n    });\n    windowView.element.addEventListener(\"click\", function(e) {\n      var anchor, next, page;\n      anchor = parentElementOfType(\"a\", e.target);\n      if (anchor) {\n        next = anchor.getAttribute('href');\n        if (next.match(/^\\#/)) {\n          e.preventDefault();\n          page = next.substr(1);\n          return displayPage(page);\n        }\n      }\n    });\n    currentPage = \"front\";\n    visited = {};\n    displayPage = function(page) {\n      if (!page) {\n        return;\n      }\n      visited[page] = true;\n      if (Object.keys(visited).length === Object.keys(pages).length) {\n        system.Achievement.unlock(\"Cover-2-cover 2: 2 cover 2 furious\");\n      }\n      if (page === \"vista\") {\n        system.Achievement.unlock(\"Lol wut\");\n      }\n      if (page === \"cheevos\") {\n        system.Achievement.unlock(\"Check yo' self\");\n      }\n      emptyElement(container);\n      container.appendChild(pages[page]);\n      return currentPage = page;\n    };\n    displayPage(currentPage);\n    nextPage = function(n) {\n      var nextIndex, pageKeys;\n      if (n == null) {\n        n = 1;\n      }\n      pageKeys = Object.keys(pages);\n      nextIndex = pageKeys.indexOf(currentPage) + n;\n      return pageKeys[nextIndex];\n    };\n    windowView.element.addEventListener(\"keydown\", function(e) {\n      switch (e.key) {\n        case \"Enter\":\n        case \"ArrowRight\":\n        case \" \":\n          return displayPage(nextPage());\n        case \"ArrowLeft\":\n          return displayPage(nextPage(-1));\n      }\n    });\n    document.body.appendChild(windowView.element);\n    windowView.element.tabIndex = 0;\n    return windowView.element.focus();\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "issues/2017-03": {
      "path": "issues/2017-03",
      "content": "(function() {\n  var Chateau, Contrasaurus, Model, PixiePaint, Social, Spreadsheet, StoryWindow, TextEditor, emptyElement, parentElementOfType, _ref;\n\n  Model = require(\"model\");\n\n  Chateau = require(\"../apps/chateau\");\n\n  Contrasaurus = require(\"../apps/contrasaurus\");\n\n  PixiePaint = require(\"../apps/pixel\");\n\n  Spreadsheet = require(\"../apps/spreadsheet\");\n\n  TextEditor = require(\"../apps/text-editor\");\n\n  Social = require(\"../social/social\");\n\n  _ref = require(\"../util\"), parentElementOfType = _ref.parentElementOfType, emptyElement = _ref.emptyElement;\n\n  module.exports = function() {\n    var Achievement, ContextMenu, MenuBar, Modal, Progress, Window, handlers, kmartGif, menuBar, parseMenu, visit, visitedAreas, windowView, _ref1, _ref2;\n    _ref1 = system.UI, ContextMenu = _ref1.ContextMenu, MenuBar = _ref1.MenuBar, Modal = _ref1.Modal, Progress = _ref1.Progress, (_ref2 = _ref1.Util, parseMenu = _ref2.parseMenu), Window = _ref1.Window;\n    Achievement = system.Achievement;\n    visitedAreas = {\n      blue: false,\n      csaur: false,\n      chateau: false,\n      cheevo: false,\n      evan: false\n    };\n    visit = function(area) {\n      var visitedAll;\n      visitedAreas[area] = true;\n      visitedAll = Object.keys(visitedAreas).every(function(key) {\n        return visitedAreas[key];\n      });\n      if (visitedAll) {\n        return Achievement.unlock(\"Cover-2-cover 3: Tokyo Drift\");\n      }\n    };\n    system.writeFile(\"issue-3/blue-light-special.txt\", new Blob([require(\"../stories/blue-light-special\")], {\n      type: \"text/plain\"\n    }));\n    system.Achievement.unlock(\"Issue 3\");\n    handlers = Model().include(Social).extend({\n      area: function() {\n        return \"2017-03\";\n      },\n      mSAccess97: function() {\n        var app;\n        app = Spreadsheet(system);\n        return document.body.appendChild(app.element);\n      },\n      chateau: function() {\n        var app;\n        visit(\"chateau\");\n        app = Chateau(system);\n        return document.body.appendChild(app.element);\n      },\n      contrasaurus: function() {\n        visit(\"csaur\");\n        return document.body.appendChild(Contrasaurus(system).element);\n      },\n      achievementStatus: function() {\n        var cheevoElement, windowView;\n        visit(\"cheevo\");\n        cheevoElement = system.Achievement.progressView();\n        cheevoElement.style.width = \"100%\";\n        cheevoElement.style.padding = \"1em\";\n        system.Achievement.unlock(\"Check yo' self\");\n        windowView = Window({\n          title: \"Cheevos\",\n          content: cheevoElement,\n          width: 640,\n          height: 480\n        });\n        return document.body.appendChild(windowView.element);\n      },\n      evanAndMore: function() {\n        var element, img, url;\n        visit(\"evan\");\n        url = \"https://s3.amazonaws.com/whimsyspace-databucket-1g3p6d9lcl6x1/danielx/IMG_9794.JPG\";\n        img = document.createElement(\"img\");\n        img.src = url;\n        element = system.UI.Window({\n          title: \"Evan And More\",\n          content: img,\n          width: 600,\n          height: 480\n        }).element;\n        return document.body.appendChild(element);\n      },\n      blueLightSpecial: function() {\n        var storyWindow;\n        Achievement.unlock(\"Blue light special\");\n        visit(\"blue\");\n        storyWindow = StoryWindow(\"Blue Light Special\", require(\"../stories/blue-light-special\"));\n        return document.body.appendChild(storyWindow.element);\n      }\n    });\n    menuBar = MenuBar({\n      items: parseMenu(\"[A]pps\\n  [C]hateau\\n  Contra[s]aurus\\n[S]tories\\n  [B]lue Light Special\\n  [E]van And More\\n\" + Social.menuText + \"\\n[H]elp\\n  [A]chievement Status\"),\n      handlers: handlers\n    });\n    kmartGif = document.createElement(\"img\");\n    kmartGif.src = \"http://media.boingboing.net/wp-content/uploads/2015/07/m66DBJ.gif\";\n    kmartGif.style = \"width: 100%; height: 100%\";\n    windowView = Window({\n      title: \"ZineOS Volume 1 | Issue 3 | ATTN: K-Mart Shoppers | March 2017\",\n      content: kmartGif,\n      menuBar: menuBar.element,\n      width: 800,\n      height: 600,\n      x: 32,\n      y: 32\n    });\n    return document.body.appendChild(windowView.element);\n  };\n\n  StoryWindow = function(title, text) {\n    var div;\n    div = document.createElement(\"div\");\n    div.textContent = text;\n    div.style.padding = \"1em\";\n    div.style.whiteSpace = \"pre-wrap\";\n    div.style.textAlign = \"justify\";\n    return system.UI.Window({\n      title: title,\n      content: div,\n      width: 380,\n      height: 480\n    });\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/achievement": {
      "path": "lib/achievement",
      "content": "(function() {\n  var Achievement, AchievementTemplate, audioPath, displaying, pending, playSound;\n\n  AchievementTemplate = require(\"../templates/achievement\");\n\n  pending = [];\n\n  displaying = false;\n\n  audioPath = \"https://cdn.gomix.com/294e834f-223f-4792-9323-5b1fa8d0402b/unlock2.mp3\";\n\n  playSound = function() {\n    var audio;\n    audio = new Audio(audioPath);\n    audio.autoplay = true;\n    return audio;\n  };\n\n  module.exports = Achievement = {\n    display: function(options) {\n      var achievementElement;\n      if (options == null) {\n        options = {};\n      }\n      if (displaying) {\n        return pending.push(options);\n      }\n      if (options.title == null) {\n        options.title = \"Achievement Unlocked\";\n      }\n      achievementElement = AchievementTemplate(options);\n      document.body.appendChild(achievementElement);\n      achievementElement.classList.add(\"display\");\n      achievementElement.appendChild(playSound());\n      displaying = true;\n      achievementElement.addEventListener(\"animationend\", function(e) {\n        achievementElement.remove();\n        displaying = false;\n        if (pending.length) {\n          return Achievement.display(pending.shift());\n        }\n      }, false);\n      return achievementElement;\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/drop": {
      "path": "lib/drop",
      "content": "(function() {\n  module.exports = function(element, handler) {\n    var cancel;\n    cancel = function(e) {\n      e.preventDefault();\n      return false;\n    };\n    element.addEventListener(\"dragover\", cancel);\n    element.addEventListener(\"dragenter\", cancel);\n    return element.addEventListener(\"drop\", function(e) {\n      e.preventDefault();\n      handler(e);\n      return false;\n    });\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/error-reporter": {
      "path": "lib/error-reporter",
      "content": "(function() {\n  window.addEventListener(\"error\", function(e) {\n    return system.Achievement.unlock(\"I AM ERROR\");\n  });\n\n  window.addEventListener(\"unhandledrejection\", function(e) {\n    return system.Achievement.unlock(\"I AM ERROR\");\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/hamlet": {
      "path": "lib/hamlet",
      "content": "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Hamlet = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  var Hamlet, compile;\n\n  Hamlet = require(\"./runtime\");\n\n  compile = require(\"hamlet-compiler\").compile;\n\n  Hamlet.compile = compile;\n\n  module.exports = Hamlet;\n\n}).call(this);\n\n},{\"./runtime\":2,\"hamlet-compiler\":5}],2:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  \"use strict\";\n  var Observable, Runtime, bindEvent, bindObservable, bufferTo, classes, createElement, empty, eventNames, get, id, isEvent, isFragment, makeElement, observeAttribute, observeAttributes, observeContent, specialBindings, valueBind, valueIndexOf;\n\n  Observable = require(\"o_0\");\n\n  eventNames = \"abort\\nblur\\nchange\\nclick\\ncontextmenu\\ndblclick\\ndrag\\ndragend\\ndragenter\\ndragexit\\ndragleave\\ndragover\\ndragstart\\ndrop\\nerror\\nfocus\\ninput\\nkeydown\\nkeypress\\nkeyup\\nload\\nmousedown\\nmousemove\\nmouseout\\nmouseover\\nmouseup\\nreset\\nresize\\nscroll\\nselect\\nsubmit\\ntouchcancel\\ntouchend\\ntouchenter\\ntouchleave\\ntouchmove\\ntouchstart\\nunload\".split(\"\\n\");\n\n  isEvent = function(name) {\n    return eventNames.indexOf(name) !== -1;\n  };\n\n  isFragment = function(node) {\n    return (node != null ? node.nodeType : void 0) === 11;\n  };\n\n  valueBind = function(element, value, context) {\n    Observable(function() {\n      var update;\n      value = Observable(value, context);\n      switch (element.nodeName) {\n        case \"SELECT\":\n          element.oninput = element.onchange = function() {\n            var optionValue, _ref, _value;\n            _ref = this.children[this.selectedIndex], optionValue = _ref.value, _value = _ref._value;\n            return value(_value || optionValue);\n          };\n          update = function(newValue) {\n            var options;\n            element._value = newValue;\n            if ((options = element._options)) {\n              if (newValue.value != null) {\n                return element.value = (typeof newValue.value === \"function\" ? newValue.value() : void 0) || newValue.value;\n              } else {\n                return element.selectedIndex = valueIndexOf(options, newValue);\n              }\n            } else {\n              return element.value = newValue;\n            }\n          };\n          return bindObservable(element, value, context, update);\n        default:\n          element.oninput = element.onchange = function() {\n            return value(element.value);\n          };\n          if (typeof element.attachEvent === \"function\") {\n            element.attachEvent(\"onkeydown\", function() {\n              return setTimeout(function() {\n                return value(element.value);\n              }, 0);\n            });\n          }\n          return bindObservable(element, value, context, function(newValue) {\n            if (element.value !== newValue) {\n              return element.value = newValue;\n            }\n          });\n      }\n    });\n  };\n\n  specialBindings = {\n    INPUT: {\n      checked: function(element, value, context) {\n        element.onchange = function() {\n          return typeof value === \"function\" ? value(element.checked) : void 0;\n        };\n        return bindObservable(element, value, context, function(newValue) {\n          return element.checked = newValue;\n        });\n      }\n    },\n    SELECT: {\n      options: function(element, values, context) {\n        var updateValues;\n        values = Observable(values, context);\n        updateValues = function(values) {\n          empty(element);\n          element._options = values;\n          return values.map(function(value, index) {\n            var option, optionName, optionValue;\n            option = createElement(\"option\");\n            option._value = value;\n            if (typeof value === \"object\") {\n              optionValue = (value != null ? value.value : void 0) || index;\n            } else {\n              optionValue = value.toString();\n            }\n            bindObservable(option, optionValue, value, function(newValue) {\n              return option.value = newValue;\n            });\n            optionName = (value != null ? value.name : void 0) || value;\n            bindObservable(option, optionName, value, function(newValue) {\n              return option.textContent = option.innerText = newValue;\n            });\n            element.appendChild(option);\n            if (value === element._value) {\n              element.selectedIndex = index;\n            }\n            return option;\n          });\n        };\n        return bindObservable(element, values, context, updateValues);\n      }\n    }\n  };\n\n  observeAttribute = function(element, context, name, value) {\n    var binding, nodeName, _ref;\n    nodeName = element.nodeName;\n    if (name === \"value\") {\n      valueBind(element, value);\n    } else if (binding = (_ref = specialBindings[nodeName]) != null ? _ref[name] : void 0) {\n      binding(element, value, context);\n    } else if (name.match(/^on/) && isEvent(name.substr(2))) {\n      bindEvent(element, name, value, context);\n    } else if (isEvent(name)) {\n      bindEvent(element, \"on\" + name, value, context);\n    } else {\n      bindObservable(element, value, context, function(newValue) {\n        if ((newValue != null) && newValue !== false) {\n          return element.setAttribute(name, newValue);\n        } else {\n          return element.removeAttribute(name);\n        }\n      });\n    }\n    return element;\n  };\n\n  observeAttributes = function(element, context, attributes) {\n    return Object.keys(attributes).forEach(function(name) {\n      var value;\n      value = attributes[name];\n      return observeAttribute(element, context, name, value);\n    });\n  };\n\n  bindObservable = function(element, value, context, update) {\n    var observable, observe, unobserve;\n    observable = Observable(value, context);\n    observe = function() {\n      observable.observe(update);\n      return update(observable());\n    };\n    unobserve = function() {\n      return observable.stopObserving(update);\n    };\n    observe();\n    return element;\n  };\n\n  bindEvent = function(element, name, fn, context) {\n    return element[name] = function() {\n      return fn.apply(context, arguments);\n    };\n  };\n\n  id = function(element, context, sources) {\n    var lastId, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(newId) {\n      return element.id = newId;\n    };\n    lastId = function() {\n      return value.last();\n    };\n    return bindObservable(element, lastId, context, update);\n  };\n\n  classes = function(element, context, sources) {\n    var classNames, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(classNames) {\n      return element.className = classNames;\n    };\n    classNames = function() {\n      return value.join(\" \");\n    };\n    return bindObservable(element, classNames, context, update);\n  };\n\n  createElement = function(name) {\n    return document.createElement(name);\n  };\n\n  observeContent = function(element, context, contentFn) {\n    var append, contents, update;\n    contents = [];\n    contentFn.call(context, {\n      buffer: bufferTo(context, contents),\n      element: makeElement\n    });\n    append = function(item) {\n      if (item == null) {\n\n      } else if (typeof item === \"string\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"number\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"boolean\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item.each === \"function\") {\n        return item.each(append);\n      } else if (typeof item.forEach === \"function\") {\n        return item.forEach(append);\n      } else {\n        return element.appendChild(item);\n      }\n    };\n    update = function(contents) {\n      empty(element);\n      return contents.forEach(append);\n    };\n    return update(contents);\n  };\n\n  bufferTo = function(context, collection) {\n    return function(content) {\n      if (typeof content === 'function') {\n        content = Observable(content, context);\n      }\n      collection.push(content);\n      return content;\n    };\n  };\n\n  makeElement = function(name, context, attributes, fn) {\n    var element;\n    if (attributes == null) {\n      attributes = {};\n    }\n    element = createElement(name);\n    Observable(function() {\n      if (attributes.id != null) {\n        id(element, context, attributes.id);\n        return delete attributes.id;\n      }\n    });\n    Observable(function() {\n      if (attributes[\"class\"] != null) {\n        classes(element, context, attributes[\"class\"]);\n        return delete attributes[\"class\"];\n      }\n    });\n    Observable(function() {\n      return observeAttributes(element, context, attributes);\n    }, context);\n    if (element.nodeName !== \"SELECT\") {\n      Observable(function() {\n        return observeContent(element, context, fn);\n      }, context);\n    }\n    return element;\n  };\n\n  Runtime = function(context) {\n    var self;\n    self = {\n      buffer: function(content) {\n        if (self.root) {\n          throw \"Cannot have multiple root elements\";\n        }\n        return self.root = content;\n      },\n      element: makeElement,\n      filter: function(name, content) {}\n    };\n    return self;\n  };\n\n  Runtime.VERSION = require(\"../package.json\").version;\n\n  Runtime.Observable = Observable;\n\n  module.exports = Runtime;\n\n  empty = function(node) {\n    var child, _results;\n    _results = [];\n    while (child = node.firstChild) {\n      _results.push(node.removeChild(child));\n    }\n    return _results;\n  };\n\n  valueIndexOf = function(options, value) {\n    if (typeof value === \"object\") {\n      return options.indexOf(value);\n    } else {\n      return options.map(function(option) {\n        return option.toString();\n      }).indexOf(value.toString());\n    }\n  };\n\n  get = function(x) {\n    if (typeof x === 'function') {\n      return x();\n    } else {\n      return x;\n    }\n  };\n\n}).call(this);\n\n},{\"../package.json\":13,\"o_0\":10}],3:[function(require,module,exports){\n\n},{}],4:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  var ROOT_NAME, indentText, util;\n\n  indentText = function(text, indent) {\n    if (indent == null) {\n      indent = \"  \";\n    }\n    return indent + text.replace(/\\n/g, \"\\n\" + indent);\n  };\n\n  ROOT_NAME = \"__root\";\n\n  util = {\n    indent: indentText,\n    filters: {\n      verbatim: function(content, compiler) {\n        return compiler.buffer('\"\"\"' + content.replace(/(#|\")/g, \"\\\\$1\") + '\"\"\"');\n      },\n      plain: function(content, compiler) {\n        return compiler.buffer(JSON.stringify(content));\n      },\n      coffeescript: function(content, compiler) {\n        return [content];\n      },\n      javascript: function(content, compiler) {\n        return [\"`\", compiler.indent(content), \"`\"];\n      }\n    },\n    element: function(tag, attributes, contents) {\n      var lines;\n      if (attributes == null) {\n        attributes = [];\n      }\n      if (contents == null) {\n        contents = [];\n      }\n      return lines = [\"\" + ROOT_NAME + \".buffer \" + ROOT_NAME + \".element \" + (JSON.stringify(tag)) + \", this, {\" + (attributes.join('\\n')) + \"}, (\" + ROOT_NAME + \") ->\", indentText(contents.join(\"\\n\")), \"  return\"];\n    },\n    buffer: function(value) {\n      return [\"\" + ROOT_NAME + \".buffer \" + value];\n    },\n    attributes: function(node) {\n      var attributeLines, attributes, classes, id, ids, idsAndClasses;\n      id = node.id, classes = node.classes, attributes = node.attributes;\n      if (id) {\n        ids = [JSON.stringify(id)];\n      } else {\n        ids = [];\n      }\n      classes = (classes || []).map(JSON.stringify);\n      if (attributes) {\n        attributes = attributes.filter(function(_arg) {\n          var name, value;\n          name = _arg.name, value = _arg.value;\n          if (name === \"class\") {\n            classes.push(value);\n            return false;\n          } else if (name === \"id\") {\n            ids.push(value);\n            return false;\n          } else {\n            return true;\n          }\n        });\n      } else {\n        attributes = [];\n      }\n      idsAndClasses = [];\n      if (ids.length) {\n        idsAndClasses.push(\"id: [\" + (ids.join(', ')) + \"]\");\n      }\n      if (classes.length) {\n        idsAndClasses.push(\"class: [\" + (classes.join(', ')) + \"]\");\n      }\n      attributeLines = attributes.map(function(_arg) {\n        var name, value;\n        name = _arg.name, value = _arg.value;\n        name = JSON.stringify(name);\n        return \"\" + name + \": \" + value;\n      });\n      return idsAndClasses.concat(attributeLines);\n    },\n    render: function(node) {\n      var filter, tag, text;\n      tag = node.tag, filter = node.filter, text = node.text;\n      if (tag) {\n        return this.tag(node);\n      } else if (filter) {\n        return this.filter(node);\n      } else {\n        return this.contents(node);\n      }\n    },\n    filter: function(node) {\n      var filter, filterName;\n      filterName = node.filter;\n      if (filter = this.filters[filterName]) {\n        return [].concat.apply([], this.filters[filterName](node.content, this));\n      } else {\n        return [\"\" + ROOT_NAME + \".filter(\" + (JSON.stringify(filterName)) + \", \" + (JSON.stringify(node.content)) + \")\"];\n      }\n    },\n    contents: function(node) {\n      var bufferedCode, childContent, children, contents, indent, text, unbufferedCode;\n      children = node.children, bufferedCode = node.bufferedCode, unbufferedCode = node.unbufferedCode, text = node.text;\n      if (unbufferedCode) {\n        indent = true;\n        contents = [unbufferedCode];\n      } else if (bufferedCode) {\n        contents = this.buffer(bufferedCode);\n      } else if (text) {\n        contents = this.buffer(JSON.stringify(text));\n      } else if (node.tag) {\n        contents = [];\n      } else if (node.comment) {\n        return [];\n      } else {\n        contents = [];\n        console.warn(\"No content for node:\", node);\n      }\n      if (children) {\n        childContent = this.renderNodes(children);\n        if (indent) {\n          childContent = this.indent(childContent.join(\"\\n\"));\n        }\n        contents = contents.concat(childContent);\n      }\n      return contents;\n    },\n    renderNodes: function(nodes) {\n      return [].concat.apply([], nodes.map(this.render, this));\n    },\n    tag: function(node) {\n      var tag;\n      tag = node.tag;\n      return this.element(tag, this.attributes(node), this.contents(node));\n    }\n  };\n\n  exports.compile = function(parseTree, _arg) {\n    var compiler, exports, items, options, program, programSource, runtime, source, _ref;\n    _ref = _arg != null ? _arg : {}, compiler = _ref.compiler, runtime = _ref.runtime, exports = _ref.exports;\n    if (runtime == null) {\n      runtime = \"require\" + \"(\\\"hamlet-runtime\\\")\";\n    }\n    if (exports == null) {\n      exports = \"module.exports\";\n    }\n    items = util.renderNodes(parseTree);\n    if (exports) {\n      exports = \"\" + exports + \" = \";\n    } else {\n      exports = \"\";\n    }\n    source = \"\" + exports + \"(data) ->\\n  \\\"use strict\\\"\\n  (->\\n    \" + ROOT_NAME + \" = \" + runtime + \"(this)\\n\\n\" + (util.indent(items.join(\"\\n\"), \"    \")) + \"\\n    return \" + ROOT_NAME + \".root\\n  ).call(data)\";\n    options = {\n      bare: true\n    };\n    programSource = source;\n    program = compiler.compile(programSource, options);\n    return program;\n  };\n\n}).call(this);\n\n},{}],5:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  var compile, parser;\n\n  compile = require(\"./compiler\").compile;\n\n  parser = require(\"hamlet-parser\");\n\n  module.exports = {\n    compile: function(input, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (typeof input === \"string\") {\n        input = parser.parse(input, options.mode);\n      }\n      return compile(input, options);\n    }\n  };\n\n}).call(this);\n\n},{\"./compiler\":4,\"hamlet-parser\":8}],6:[function(require,module,exports){\n/* generated by jison-lex 0.2.1 */\nvar haml_lexer = (function(){\nvar lexer = {\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"moduleName\":\"haml_lexer\"},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return 'SEPARATOR';\nbreak;\ncase 1:this.popState(); return 'RIGHT_PARENTHESIS';\nbreak;\ncase 2:return 'ATTRIBUTE';\nbreak;\ncase 3:this.begin('value'); return 'EQUAL';\nbreak;\ncase 4:return 'AT_ATTRIBUTE';\nbreak;\ncase 5:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 6:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 7:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 8:yy.indent = 0; this.popState(); return 'NEWLINE';\nbreak;\ncase 9:return 'FILTER_LINE';\nbreak;\ncase 10:yy.indent = 0; return 'NEWLINE';\nbreak;\ncase 11:yy.indent += 1; if(yy.indent > yy.filterIndent){this.begin('filter'); }; return 'INDENT';\nbreak;\ncase 12:this.begin(\"parentheses_attributes\"); return 'LEFT_PARENTHESIS';\nbreak;\ncase 13:yy_.yytext = yy_.yytext.substring(1); return 'COMMENT';\nbreak;\ncase 14:yy.filterIndent = yy.indent; yy_.yytext = yy_.yytext.substring(1); return 'FILTER';\nbreak;\ncase 15:yy_.yytext = yy_.yytext.substring(1); return 'ID';\nbreak;\ncase 16:yy_.yytext = yy_.yytext.substring(1); return 'CLASS';\nbreak;\ncase 17:yy_.yytext = yy_.yytext.substring(1); return 'TAG';\nbreak;\ncase 18:yy_.yytext = yy_.yytext.substring(1).trim(); return 'BUFFERED_CODE';\nbreak;\ncase 19:yy_.yytext = yy_.yytext.substring(1).trim(); return 'UNBUFFERED_CODE';\nbreak;\ncase 20:yy_.yytext = yy_.yytext.trim(); return 'TEXT';\nbreak;\n}\n},\nrules: [/^(?:[ \\t]+)/,/^(?:\\))/,/^(?:([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:=)/,/^(?:@([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:'(\\\\.|[^\\\\'])*')/,/^(?:[^ \\t\\)]*)/,/^(?:(\\n|$))/,/^(?:[^\\n]*)/,/^(?:\\s*(\\n|$))/,/^(?:(  |\\\\t))/,/^(?:\\()/,/^(?:\\/.*)/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:#((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:\\.((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:%((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:=.*)/,/^(?:-.*)/,/^(?:.*)/],\nconditions: {\"filter\":{\"rules\":[8,9],\"inclusive\":false},\"value\":{\"rules\":[5,6,7],\"inclusive\":false},\"parentheses_attributes\":{\"rules\":[0,1,2,3,4],\"inclusive\":false},\"INITIAL\":{\"rules\":[10,11,12,13,14,15,16,17,18,19,20],\"inclusive\":true}}\n};\nreturn lexer;\n})();module.exports = haml_lexer;\n\n},{}],7:[function(require,module,exports){\n/* generated by jison-lex 0.2.1 */\nvar jade_lexer = (function(){\nvar lexer = {\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"moduleName\":\"jade_lexer\"},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return 'SEPARATOR';\nbreak;\ncase 1:this.popState(); return 'RIGHT_PARENTHESIS';\nbreak;\ncase 2:return 'ATTRIBUTE';\nbreak;\ncase 3:this.begin('value'); return 'EQUAL';\nbreak;\ncase 4:return 'AT_ATTRIBUTE';\nbreak;\ncase 5:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 6:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 7:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 8:yy.indent = 0; this.popState(); return 'NEWLINE';\nbreak;\ncase 9:return 'FILTER_LINE';\nbreak;\ncase 10:yy.indent = 0; return 'NEWLINE';\nbreak;\ncase 11:yy.indent += 1; if(yy.indent > yy.filterIndent){this.begin('filter'); }; return 'INDENT';\nbreak;\ncase 12:this.begin(\"parentheses_attributes\"); return 'LEFT_PARENTHESIS';\nbreak;\ncase 13:yy_.yytext = yy_.yytext.substring(2); return 'COMMENT';\nbreak;\ncase 14:yy.filterIndent = yy.indent; yy_.yytext = yy_.yytext.substring(1); return 'FILTER';\nbreak;\ncase 15:yy_.yytext = yy_.yytext.substring(1); return 'ID';\nbreak;\ncase 16:yy_.yytext = yy_.yytext.substring(1); return 'CLASS';\nbreak;\ncase 17:return 'TAG';\nbreak;\ncase 18:yy_.yytext = yy_.yytext.substring(1).trim(); return 'BUFFERED_CODE';\nbreak;\ncase 19:yy_.yytext = yy_.yytext.substring(1).trim(); return 'UNBUFFERED_CODE';\nbreak;\ncase 20:yy_.yytext = yy_.yytext.trim(); return 'TEXT';\nbreak;\n}\n},\nrules: [/^(?:[ \\t]+)/,/^(?:\\))/,/^(?:([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:=)/,/^(?:@([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:'(\\\\.|[^\\\\'])*')/,/^(?:[^ \\t\\)]*)/,/^(?:(\\n|$))/,/^(?:[^\\n]*)/,/^(?:\\s*(\\n|$))/,/^(?:(  |\\\\t))/,/^(?:\\()/,/^(?:\\/\\/.*)/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:#((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:\\.((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:=.*)/,/^(?:-.*)/,/^(?:.*)/],\nconditions: {\"filter\":{\"rules\":[8,9],\"inclusive\":false},\"value\":{\"rules\":[5,6,7],\"inclusive\":false},\"parentheses_attributes\":{\"rules\":[0,1,2,3,4],\"inclusive\":false},\"INITIAL\":{\"rules\":[10,11,12,13,14,15,16,17,18,19,20],\"inclusive\":true}}\n};\nreturn lexer;\n})();module.exports = jade_lexer;\n\n},{}],8:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  var extend, lexers, oldParse, parser,\n    __slice = [].slice;\n\n  parser = require(\"./parser\").parser;\n\n  lexers = {\n    haml: require(\"./haml_lexer\"),\n    jade: require(\"./jade_lexer\")\n  };\n\n  extend = function() {\n    var name, source, sources, target, _i, _len;\n    target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    for (_i = 0, _len = sources.length; _i < _len; _i++) {\n      source = sources[_i];\n      for (name in source) {\n        target[name] = source[name];\n      }\n    }\n    return target;\n  };\n\n  oldParse = parser.parse;\n\n  extend(parser, {\n    parse: function(input, mode) {\n      if (mode == null) {\n        mode = \"haml\";\n      }\n      parser.lexer = lexers[mode];\n      extend(parser.yy, {\n        indent: 0,\n        nodePath: [\n          {\n            children: []\n          }\n        ],\n        filterIndent: void 0\n      });\n      return oldParse.call(parser, input);\n    }\n  });\n\n  extend(parser.yy, {\n    extend: extend,\n    newline: function() {\n      var lastNode;\n      lastNode = this.nodePath[this.nodePath.length - 1];\n      if (lastNode.filter) {\n        return this.appendFilterContent(lastNode, \"\");\n      }\n    },\n    lastParent: function(indentation) {\n      var parent;\n      while (!(parent = this.nodePath[indentation])) {\n        indentation -= 1;\n      }\n      return parent;\n    },\n    append: function(node, indentation) {\n      var index, lastNode, parent;\n      if (indentation == null) {\n        indentation = 0;\n      }\n      if (node.filterLine) {\n        lastNode = this.nodePath[this.nodePath.length - 1];\n        this.appendFilterContent(lastNode, node.filterLine);\n        return;\n      }\n      parent = this.lastParent(indentation);\n      this.appendChild(parent, node);\n      index = indentation + 1;\n      this.nodePath[index] = node;\n      this.nodePath.length = index + 1;\n      return node;\n    },\n    appendChild: function(parent, child) {\n      if (!child.filter) {\n        this.filterIndent = void 0;\n        this.lexer.popState();\n      }\n      parent.children || (parent.children = []);\n      return parent.children.push(child);\n    },\n    appendFilterContent: function(filter, content) {\n      filter.content || (filter.content = \"\");\n      return filter.content += \"\" + content + \"\\n\";\n    }\n  });\n\n  module.exports = parser;\n\n}).call(this);\n\n},{\"./haml_lexer\":6,\"./jade_lexer\":7,\"./parser\":9}],9:[function(require,module,exports){\n(function (process){\n/* parser generated by jison 0.4.6 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"lines\":4,\"line\":5,\"indentation\":6,\"indentationLevel\":7,\"INDENT\":8,\"lineMain\":9,\"end\":10,\"tag\":11,\"rest\":12,\"COMMENT\":13,\"FILTER\":14,\"FILTER_LINE\":15,\"NEWLINE\":16,\"name\":17,\"tagComponents\":18,\"attributes\":19,\"idComponent\":20,\"classComponents\":21,\"ID\":22,\"CLASS\":23,\"LEFT_PARENTHESIS\":24,\"attributePairs\":25,\"RIGHT_PARENTHESIS\":26,\"SEPARATOR\":27,\"attributePair\":28,\"ATTRIBUTE\":29,\"EQUAL\":30,\"ATTRIBUTE_VALUE\":31,\"AT_ATTRIBUTE\":32,\"TAG\":33,\"BUFFERED_CODE\":34,\"UNBUFFERED_CODE\":35,\"TEXT\":36,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",8:\"INDENT\",13:\"COMMENT\",14:\"FILTER\",15:\"FILTER_LINE\",16:\"NEWLINE\",22:\"ID\",23:\"CLASS\",24:\"LEFT_PARENTHESIS\",26:\"RIGHT_PARENTHESIS\",27:\"SEPARATOR\",29:\"ATTRIBUTE\",30:\"EQUAL\",31:\"ATTRIBUTE_VALUE\",32:\"AT_ATTRIBUTE\",33:\"TAG\",34:\"BUFFERED_CODE\",35:\"UNBUFFERED_CODE\",36:\"TEXT\"},\nproductions_: [0,[3,1],[4,2],[4,1],[6,0],[6,1],[7,2],[7,1],[5,3],[5,1],[9,2],[9,1],[9,1],[9,1],[9,1],[9,1],[10,1],[11,2],[11,2],[11,1],[11,1],[18,3],[18,2],[18,2],[18,2],[18,1],[18,1],[20,1],[21,2],[21,1],[19,3],[25,3],[25,1],[28,3],[28,1],[17,1],[12,1],[12,1],[12,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:return this.$ = yy.nodePath[0].children;\nbreak;\ncase 2:this.$ = $$[$0-1];\nbreak;\ncase 3:this.$ = $$[$0];\nbreak;\ncase 4:this.$ = 0;\nbreak;\ncase 5:this.$ = $$[$0];\nbreak;\ncase 6:this.$ = $$[$0-1] + 1;\nbreak;\ncase 7:this.$ = 1;\nbreak;\ncase 8:this.$ = yy.append($$[$0-1], $$[$0-2]);\nbreak;\ncase 9:this.$ = (function () {\n        if ($$[$0].newline) {\n          return yy.newline();\n        }\n      }());\nbreak;\ncase 10:this.$ = yy.extend($$[$0-1], $$[$0]);\nbreak;\ncase 11:this.$ = $$[$0];\nbreak;\ncase 12:this.$ = $$[$0];\nbreak;\ncase 13:this.$ = {\n          comment: $$[$0]\n        };\nbreak;\ncase 14:this.$ = {\n          filter: $$[$0]\n        };\nbreak;\ncase 15:this.$ = {\n          filterLine: $$[$0]\n        };\nbreak;\ncase 16:this.$ = {\n          newline: true\n        };\nbreak;\ncase 17:this.$ = (function () {\n        $$[$0].tag = $$[$0-1];\n        return $$[$0];\n      }());\nbreak;\ncase 18:this.$ = {\n          tag: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 19:this.$ = {\n          tag: $$[$0]\n        };\nbreak;\ncase 20:this.$ = yy.extend($$[$0], {\n          tag: \"div\"\n        });\nbreak;\ncase 21:this.$ = {\n          id: $$[$0-2],\n          classes: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 22:this.$ = {\n          id: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 23:this.$ = {\n          classes: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 24:this.$ = {\n          id: $$[$0-1],\n          classes: $$[$0]\n        };\nbreak;\ncase 25:this.$ = {\n          id: $$[$0]\n        };\nbreak;\ncase 26:this.$ = {\n          classes: $$[$0]\n        };\nbreak;\ncase 27:this.$ = $$[$0];\nbreak;\ncase 28:this.$ = $$[$0-1].concat($$[$0]);\nbreak;\ncase 29:this.$ = [$$[$0]];\nbreak;\ncase 30:this.$ = $$[$0-1];\nbreak;\ncase 31:this.$ = $$[$0-2].concat($$[$0]);\nbreak;\ncase 32:this.$ = [$$[$0]];\nbreak;\ncase 33:this.$ = {\n          name: $$[$0-2],\n          value: $$[$0]\n        };\nbreak;\ncase 34:this.$ = {\n          name: $$[$0].substring(1),\n          value: $$[$0]\n        };\nbreak;\ncase 35:this.$ = $$[$0];\nbreak;\ncase 36:this.$ = {\n          bufferedCode: $$[$0]\n        };\nbreak;\ncase 37:this.$ = {\n          unbufferedCode: $$[$0]\n        };\nbreak;\ncase 38:this.$ = {\n          text: $$[$0] + \"\\n\"\n        };\nbreak;\n}\n},\ntable: [{3:1,4:2,5:3,6:4,7:6,8:[1,8],10:5,13:[2,4],14:[2,4],15:[2,4],16:[1,7],22:[2,4],23:[2,4],33:[2,4],34:[2,4],35:[2,4],36:[2,4]},{1:[3]},{1:[2,1],5:9,6:4,7:6,8:[1,8],10:5,13:[2,4],14:[2,4],15:[2,4],16:[1,7],22:[2,4],23:[2,4],33:[2,4],34:[2,4],35:[2,4],36:[2,4]},{1:[2,3],8:[2,3],13:[2,3],14:[2,3],15:[2,3],16:[2,3],22:[2,3],23:[2,3],33:[2,3],34:[2,3],35:[2,3],36:[2,3]},{9:10,11:11,12:12,13:[1,13],14:[1,14],15:[1,15],17:16,18:17,20:22,21:23,22:[1,24],23:[1,25],33:[1,21],34:[1,18],35:[1,19],36:[1,20]},{1:[2,9],8:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[2,9],22:[2,9],23:[2,9],33:[2,9],34:[2,9],35:[2,9],36:[2,9]},{8:[1,26],13:[2,5],14:[2,5],15:[2,5],22:[2,5],23:[2,5],33:[2,5],34:[2,5],35:[2,5],36:[2,5]},{1:[2,16],8:[2,16],13:[2,16],14:[2,16],15:[2,16],16:[2,16],22:[2,16],23:[2,16],33:[2,16],34:[2,16],35:[2,16],36:[2,16]},{8:[2,7],13:[2,7],14:[2,7],15:[2,7],22:[2,7],23:[2,7],33:[2,7],34:[2,7],35:[2,7],36:[2,7]},{1:[2,2],8:[2,2],13:[2,2],14:[2,2],15:[2,2],16:[2,2],22:[2,2],23:[2,2],33:[2,2],34:[2,2],35:[2,2],36:[2,2]},{10:27,16:[1,7]},{12:28,16:[2,11],34:[1,18],35:[1,19],36:[1,20]},{16:[2,12]},{16:[2,13]},{16:[2,14]},{16:[2,15]},{16:[2,19],18:29,19:30,20:22,21:23,22:[1,24],23:[1,25],24:[1,31],34:[2,19],35:[2,19],36:[2,19]},{16:[2,20],34:[2,20],35:[2,20],36:[2,20]},{16:[2,36]},{16:[2,37]},{16:[2,38]},{16:[2,35],22:[2,35],23:[2,35],24:[2,35],34:[2,35],35:[2,35],36:[2,35]},{16:[2,25],19:33,21:32,23:[1,25],24:[1,31],34:[2,25],35:[2,25],36:[2,25]},{16:[2,26],19:34,23:[1,35],24:[1,31],34:[2,26],35:[2,26],36:[2,26]},{16:[2,27],23:[2,27],24:[2,27],34:[2,27],35:[2,27],36:[2,27]},{16:[2,29],23:[2,29],24:[2,29],34:[2,29],35:[2,29],36:[2,29]},{8:[2,6],13:[2,6],14:[2,6],15:[2,6],22:[2,6],23:[2,6],33:[2,6],34:[2,6],35:[2,6],36:[2,6]},{1:[2,8],8:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[2,8],22:[2,8],23:[2,8],33:[2,8],34:[2,8],35:[2,8],36:[2,8]},{16:[2,10]},{16:[2,17],34:[2,17],35:[2,17],36:[2,17]},{16:[2,18],34:[2,18],35:[2,18],36:[2,18]},{25:36,28:37,29:[1,38],32:[1,39]},{16:[2,24],19:40,23:[1,35],24:[1,31],34:[2,24],35:[2,24],36:[2,24]},{16:[2,22],34:[2,22],35:[2,22],36:[2,22]},{16:[2,23],34:[2,23],35:[2,23],36:[2,23]},{16:[2,28],23:[2,28],24:[2,28],34:[2,28],35:[2,28],36:[2,28]},{26:[1,41],27:[1,42]},{26:[2,32],27:[2,32]},{30:[1,43]},{26:[2,34],27:[2,34]},{16:[2,21],34:[2,21],35:[2,21],36:[2,21]},{16:[2,30],34:[2,30],35:[2,30],36:[2,30]},{28:44,29:[1,38],32:[1,39]},{31:[1,45]},{26:[2,31],27:[2,31]},{26:[2,33],27:[2,33]}],\ndefaultActions: {12:[2,12],13:[2,13],14:[2,14],15:[2,15],18:[2,36],19:[2,37],20:[2,38],28:[2,10]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        throw new Error(str);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    this.yy.parser = this;\n    if (typeof this.lexer.yylloc == 'undefined') {\n        this.lexer.yylloc = {};\n    }\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = this.lexer.options && this.lexer.options.ranges;\n    if (typeof this.yy.parseError === 'function') {\n        this.parseError = this.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    function lex() {\n        var token;\n        token = self.lexer.lex() || EOF;\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + this.lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: this.lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: this.lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(this.lexer.yytext);\n            lstack.push(this.lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\nundefined\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}\n}).call(this,require('_process'))\n},{\"_process\":12,\"fs\":3,\"path\":11}],10:[function(require,module,exports){\n(function (global){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],11:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n},{\"_process\":12}],12:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],13:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"hamlet.coffee\",\n  \"version\": \"0.7.6\",\n  \"description\": \"Truly amazing templating!\",\n  \"devDependencies\": {\n    \"browserify\": \"^12.0.1\",\n    \"coffee-script\": \"~1.7.1\",\n    \"jsdom\": \"^7.2.0\",\n    \"mocha\": \"^2.3.3\"\n  },\n  \"dependencies\": {\n    \"hamlet-compiler\": \"0.7.0\",\n    \"o_0\": \"0.3.8\"\n  },\n  \"homepage\": \"hamlet.coffee\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/dr-coffee-labs/hamlet.git\"\n  },\n  \"scripts\": {\n    \"prepublish\": \"script/prepublish\",\n    \"test\": \"script/test\"\n  },\n  \"files\": [\n    \"dist/\"\n  ],\n  \"main\": \"dist/runtime.js\"\n}\n\n},{}]},{},[1])(1)\n});",
      "type": "blob"
    },
    "lib/iframe-app": {
      "path": "lib/iframe-app",
      "content": "(function() {\n  var FileIO, Model, Postmaster,\n    __slice = [].slice;\n\n  Model = require(\"model\");\n\n  Postmaster = require(\"postmaster\");\n\n  FileIO = require(\"../os/file-io\");\n\n  module.exports = function(opts) {\n    var ContextMenu, MenuBar, Modal, Observable, Progress, Table, Window, frame, handlers, height, loadedPromise, menuBar, parseMenu, postmaster, resolveLoaded, src, title, width, windowView, _ref, _ref1;\n    if (opts == null) {\n      opts = {};\n    }\n    _ref = system.UI, ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Observable = _ref.Observable, Progress = _ref.Progress, Table = _ref.Table, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Window = _ref.Window;\n    height = opts.height, menuBar = opts.menuBar, src = opts.src, title = opts.title, width = opts.width;\n    frame = document.createElement(\"iframe\");\n    frame.src = src;\n    resolveLoaded = null;\n    loadedPromise = new Promise(function(resolve) {\n      return resolveLoaded = resolve;\n    });\n    postmaster = Postmaster();\n    postmaster.remoteTarget = function() {\n      return frame.contentWindow;\n    };\n    Object.assign(postmaster, {\n      childLoaded: function() {\n        console.log(\"child loaded\");\n        return resolveLoaded();\n      },\n      event: function() {\n        windowView.trigger.apply(windowView, [\"event\"].concat(__slice.call(arguments)));\n      }\n    });\n    handlers = Model().include(FileIO).extend({\n      loadFile: function(blob) {\n        return loadedPromise.then(function() {\n          return postmaster.invokeRemote(\"loadFile\", blob);\n        });\n      }\n    });\n    windowView = Window({\n      title: title,\n      content: frame,\n      menuBar: menuBar != null ? menuBar.element : void 0,\n      width: width,\n      height: height\n    });\n    windowView.loadFile = handlers.loadFile;\n    return windowView;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/outbound-clicks": {
      "path": "lib/outbound-clicks",
      "content": "(function() {\n  var parentElementOfType;\n\n  parentElementOfType = require(\"../util\").parentElementOfType;\n\n  document.addEventListener(\"click\", function(e) {\n    var anchor, href;\n    anchor = parentElementOfType(\"a\", e.target);\n    if (anchor) {\n      href = anchor.getAttribute('href');\n      if (href.match(/^http/)) {\n        e.preventDefault();\n        if (href.match(/frogfeels\\.com/)) {\n          system.Achievement.unlock(\"Feeling the frog\");\n        }\n        return window.open(href);\n      }\n    }\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "mailchimp": {
      "path": "mailchimp",
      "content": "(function() {\n  document.head.insertAdjacentHTML(\"beforeend\", \"<link href=\\\"https://cdn-images.mailchimp.com/embedcode/classic-10_7.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n<style type=\\\"text/css\\\">\\n\t#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }\\n</style>\");\n\n  module.exports = {\n    show: function() {\n      var div;\n      div = document.createElement(\"div\");\n      div.innerHTML = \"<div id=\\\"mc_embed_signup\\\">\\n<form action=\\\"//space.us14.list-manage.com/subscribe/post?u=8946c32e9db504ccc083d3fc7&amp;id=b8b708aea6\\\" method=\\\"post\\\" id=\\\"mc-embedded-subscribe-form\\\" name=\\\"mc-embedded-subscribe-form\\\" class=\\\"validate\\\" target=\\\"_blank\\\" novalidate>\\n    <div id=\\\"mc_embed_signup_scroll\\\">\\n\\n<div class=\\\"mc-field-group\\\">\\n\t<label for=\\\"mce-EMAIL\\\">Email Address </label>\\n\t<input type=\\\"email\\\" value=\\\"\\\" name=\\\"EMAIL\\\" class=\\\"required email\\\" id=\\\"mce-EMAIL\\\">\\n</div>\\n\t<div id=\\\"mce-responses\\\" class=\\\"clear\\\">\\n\t\t<div class=\\\"response\\\" id=\\\"mce-error-response\\\" style=\\\"display:none\\\"></div>\\n\t\t<div class=\\\"response\\\" id=\\\"mce-success-response\\\" style=\\\"display:none\\\"></div>\\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\\n    <div style=\\\"position: absolute; left: -5000px;\\\" aria-hidden=\\\"true\\\"><input type=\\\"text\\\" name=\\\"b_8946c32e9db504ccc083d3fc7_b8b708aea6\\\" tabindex=\\\"-1\\\" value=\\\"\\\"></div>\\n    <div class=\\\"clear\\\"><input type=\\\"submit\\\" value=\\\"Subscribe\\\" name=\\\"subscribe\\\" id=\\\"mc-embedded-subscribe\\\" class=\\\"button\\\"></div>\\n    </div>\\n</form>\\n</div>\";\n      return system.UI.Modal.show(div);\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "main": {
      "path": "main",
      "content": "(function() {\n  var Explorer, Style, System, style;\n\n  require(\"analytics\").init(\"UA-3464282-16\");\n\n  require(\"./extensions\");\n\n  require(\"./lib/outbound-clicks\");\n\n  require(\"./lib/error-reporter\");\n\n  global.Hamlet = require(\"./lib/hamlet\");\n\n  System = require(\"./system\");\n\n  global.system = System();\n\n  Style = system.UI.Style;\n\n  style = document.createElement(\"style\");\n\n  style.innerHTML = Style.all + \"\\n\" + require(\"./style\");\n\n  document.head.appendChild(style);\n\n  Explorer = require(\"./apps/explorer\");\n\n  document.body.appendChild(Explorer());\n\n  system.writeFile(\"feedback.exe\", new Blob([\"\"], {\n    type: \"application/exe\"\n  }));\n\n  system.writeFile(\"issue-1/zine1.exe\", new Blob([\"\"], {\n    type: \"application/exe\"\n  }));\n\n  system.writeFile(\"issue-2/zine2.exe\", new Blob([\"\"], {\n    type: \"application/exe\"\n  }));\n\n  system.writeFile(\"issue-3/zine3.exe\", new Blob([\"\"], {\n    type: \"application/exe\"\n  }));\n\n  require(\"./issues/2017-03\")();\n\n}).call(this);\n",
      "type": "blob"
    },
    "os/file-io": {
      "path": "os/file-io",
      "content": "(function() {\n  module.exports = function(I, self) {\n    var Modal, Observable, currentPath, saved;\n    Observable = system.Observable;\n    Modal = system.UI.Modal;\n    currentPath = Observable(\"\");\n    saved = true;\n    self.extend({\n      currentPath: currentPath,\n      \"new\": function() {\n        if (saved) {\n          currentPath(\"\");\n          return self.newFile();\n        } else {\n          return Modal.confirm(\"You will lose unsaved progress, continue?\").then(function(result) {\n            if (result) {\n              saved = true;\n              return self.newFile();\n            }\n          });\n        }\n      },\n      open: function() {\n        return Modal.prompt(\"File Path\", currentPath()).then(function(newPath) {\n          if (newPath) {\n            return currentPath(newPath);\n          } else {\n            throw new Error(\"No path given\");\n          }\n        }).then(function(path) {\n          return system.readFile(path, true);\n        }).then(function(file) {\n          return self.loadFile(file);\n        });\n      },\n      save: function() {\n        if (currentPath()) {\n          return self.saveData().then(function(blob) {\n            return system.writeFile(currentPath(), blob, true);\n          }).then(function() {\n            return currentPath();\n          });\n        } else {\n          return self.saveAs();\n        }\n      },\n      saveAs: function() {\n        return Modal.prompt(\"File Path\", currentPath()).then(function(path) {\n          if (path) {\n            currentPath(path);\n            return self.save();\n          }\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "pixie": {
      "path": "pixie",
      "content": "module.exports = {\"dependencies\":{\"ajax\":\"distri/ajax:master\",\"analytics\":\"distri/google-analytics:master\",\"bindable\":\"distri/bindable:master\",\"model\":\"distri/model:master\",\"postmaster\":\"distri/postmaster:v0.5.0\",\"ui\":\"STRd6/ui:master\"},\"remoteDependencies\":[\"https://cdnjs.cloudflare.com/ajax/libs/dexie/2.0.0-beta.7/dexie.min.js\",\"https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ace.js\",\"https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ext-language_tools.js\",\"https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.7.1/coffee-script.min.js\",\"https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.6/marked.min.js\"]};",
      "type": "blob"
    },
    "presenters/achievement-group-progress": {
      "path": "presenters/achievement-group-progress",
      "content": "(function() {\n  var AchievementBadgeTemplate, ProgressTemplate;\n\n  AchievementBadgeTemplate = require(\"../templates/achievement-badge\");\n\n  ProgressTemplate = require(\"../templates/achievement-progress\");\n\n  module.exports = function(_arg) {\n    var achieved, achievements, name, total, value;\n    name = _arg.name, achievements = _arg.achievements;\n    achieved = achievements.filter(function(_arg1) {\n      var achieved;\n      achieved = _arg1.achieved;\n      return achieved;\n    }).length;\n    total = achievements.length;\n    value = achieved / total;\n    return ProgressTemplate({\n      name: name,\n      achievements: achievements,\n      badges: achievements.map(function(cheevo) {\n        return AchievementBadgeTemplate(Object.assign({}, cheevo, {\n          \"class\": function() {\n            if (cheevo.achieved) {\n              return \"achieved\";\n            }\n          }\n        }));\n      }),\n      fraction: \"\" + achieved + \"/\" + total,\n      value: value.toString()\n    });\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "social/comment-form": {
      "path": "social/comment-form",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"form\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"h1\", this, {}, function(__root) {\n        __root.buffer(\"Comment\\n\");\n      }));\n      __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"h3\", this, {}, function(__root) {\n          __root.buffer(\"Author\\n\");\n        }));\n        __root.buffer(__root.element(\"input\", this, {\n          \"name\": \"author\",\n          \"value\": \"Anon\"\n        }, function(__root) {}));\n      }));\n      __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"h3\", this, {}, function(__root) {\n          __root.buffer(\"Body\\n\");\n        }));\n        __root.buffer(__root.element(\"textarea\", this, {\n          \"name\": \"body\"\n        }, function(__root) {}));\n      }));\n      __root.buffer(__root.element(\"input\", this, {\n        \"type\": \"hidden\",\n        \"name\": \"area\",\n        \"value\": this.area\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"button\", this, {}, function(__root) {\n        __root.buffer(\"Submit\\n\");\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "social/comments": {
      "path": "social/comments",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"comments\", this, {}, function(__root) {\n      this.forEach(function(comment) {\n        return __root.buffer(__root.element(\"comment\", this, {}, function(__root) {\n          __root.buffer(__root.element(\"div\", this, {}, function(__root) {\n            __root.buffer(comment.body);\n          }));\n          __root.buffer(__root.element(\"div\", this, {\n            \"class\": [\"author\"]\n          }, function(__root) {\n            __root.buffer(comment.author);\n          }));\n        }));\n      });\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "social/social": {
      "path": "social/social",
      "content": "(function() {\n  var Ajax, CommentFormTemplate, CommentsTemplate, ajax;\n\n  CommentFormTemplate = require(\"../social/comment-form\");\n\n  CommentsTemplate = require(\"../social/comments\");\n\n  Ajax = require(\"ajax\");\n\n  ajax = Ajax();\n\n  module.exports = function(I, self) {\n    var Modal;\n    Modal = system.UI.Modal;\n    return self.extend({\n      comment: function() {\n        return Modal.form(CommentFormTemplate({\n          area: self.area()\n        })).then(function(data) {\n          return ajax({\n            url: \"https://whimsy-space.gomix.me/comments\",\n            data: JSON.stringify(data),\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\"\n          });\n        }).then(function() {\n          return self.viewComments();\n        });\n      },\n      viewComments: function() {\n        return ajax.getJSON(\"https://whimsy-space.gomix.me/comments/\" + (self.area())).then(function(data) {\n          data = data.reverse();\n          if (data.length === 0) {\n            data = [\n              {\n                body: \"no comments\",\n                author: \"mgmt\"\n              }\n            ];\n          }\n          return Modal.show(CommentsTemplate(data));\n        });\n      },\n      like: function() {\n        system.Achievement.unlock(\"Do you 'like' like me?\");\n        return Modal.alert(\"I like you too, but we don't have a facebook or anything yet :)\");\n      },\n      subscribe: function() {\n        return require(\"../mailchimp\").show();\n      }\n    });\n  };\n\n  module.exports.menuText = \"S[o]cial Media\\n  [V]iew Comments\\n  [C]omment\\n  [L]ike\\n  [S]ubscribe\";\n\n}).call(this);\n",
      "type": "blob"
    },
    "stories/around-the-world": {
      "path": "stories/around-the-world",
      "content": "(function() {\n  module.exports = \"# Around the World in 20 Years and a Weekend\\n\\nThe history of human progress is rife with us entering things. [Tombs](https://en.wikipedia.org/wiki/Raiders_of_the_Lost_Ark), [dragons](https://en.wikipedia.org/wiki/Enter_the_Dragon), [voids](https://en.wikipedia.org/wiki/Enter_the_Void), even [gungeons](http://dodgeroll.com/gungeon/).\\n\\n\\nBut have you ever stopped to think about what fuels this endless urge to ingress? Rather fearlessly, I decided to find out.\\n\\n![sensuous nights](https://frog-feels.s3.amazonaws.com/2016-52/391848cb-afa1-4149-b2be-054d6d86b540.png)\\n\\nIt's now 20 years later. I've waded through the jungles of the Amazon, skied the slopes of Norway, swam the Ganges, and braved long lines. I've lost a lot too. The years have aged me dramatically - I'm a hot mess. And I lost my phone a month ago, so my friends and family are dead to me now.\\n\\nHere's what I've learned on my journey,\\n\\n![lederhosen leroy](https://frog-feels.s3.amazonaws.com/2016-30/57b1f586-4f32-4cd5-8aea-d1a7c9400964.png)\\n\\nThe Freudian says we want to go in things for obvious sex reasons. Freudian? More like Fraud-ian, right? Har har.\\n\\n![horse confessional](https://frog-feels.s3.amazonaws.com/2016-27/75889dde-ba0c-434e-b5dd-1edda7daa97e.png)\\n\\nMy Peyote spirit animal is a horse. Under the desert sky he whispers in my ear that what we really want is to enter the stable of the mind. I'm not so sure though. I don't even really like normal earthly stables.\\n\\n![soup boy](https://frog-feels.s3.amazonaws.com/2016-32/821e8ec3-e55d-4388-8cdd-6da58d902924.png)\\n\\nAfter the peyote trip, things get a little fuzzy. I stumbled into a place. It was either a diner, a drive-in, or a dive. There I met TV food guy Guy Fieri. Between mouthfuls of cheese and enthusiasm, he proclaimed that we enter so that we may exit.\\n\\nWere all searching for something thats everything we imagine it to be.\\n\\n...\\n\\nIf I'm honest, this odyssey only really took a weekend. After that I didn't really feel like going back to work, so I just hung out for a while.\\n\\n![you are great](https://frog-feels.s3.amazonaws.com/2016-50/2d44fdcd-05b9-4a92-a954-ec1235ee7b1e.png)\\n\\n\\n[ cool art made by cool people at [Frog Feels](http://frogfeels.com)]\";\n\n}).call(this);\n",
      "type": "blob"
    },
    "stories/blue-light-special": {
      "path": "stories/blue-light-special",
      "content": "(function() {\n  module.exports = \"Blue Light Special\\n\\nYou know, I really want some cookies. Elo said. She sat on a cushion on top of a tarp spread on the ground in front of their small campfire and whittled a piece of wood, periodically tossing the shavings into the fire. The warm glow bathed her deft fingers, tired face, and honey-colored hair with a soft light, and faintly illuminated the oak trees around them in the pressing darkness.\\n\\nWe can break camp tomorrow, move on, and see what we can find on the way, Jib replied, as he munched some popcorn and scratched his dark beard. He scooted his log seat closer to the fire and buttoned his shearling jacket to keep out the fine mist rolling in among the trees.\\n\\nI dont want to break camp, Elo protested. I like it here. We should stay a while. I just want to have some cookies. She looked around their camp: at Jib on his stump; at Poli beside her on the tarp, seated on her own cushion; at their reliable and well-used tent; at the horses draped with their blankets; at the clean dishes drying fireside. This was a good place. She rubbed her ever-growing abdomen. The tiny person ensconced within dragged a heel over her insides in response.\\n\\nOkay, we wont break camp, then. We can just go to town tomorrow. We need some other supplies anyway. Jib raised his lanky body to pass the popcorn to Poli, who took the enameled bowl and placed it between her and Elo.\\n\\nPoli offered the popcorn to Elo. Here, have some popcorn. That will help take your mind off the craving.\\n\\nElo knitted her brows. No, it wont. Its not the same and you know it.\\n\\nYeah, okay. I know. Its not. But its what we have, Poli smiled gently, hoping to diffuse the situation.\\n\\nWhy cant you just go get some now? We didnt camp that far from town, and its not that late, Elo pleaded.\\n\\nBecause its going to rain soon, and because Im tired, and because we decide things together, not based on whim, Jib retorted grumpily.\\n\\nPleeeeeease! I really, really want them. Im tired too and my back hurts from hauling this baby around and I just want to have some cookies. Is that too much to ask? Elo burst into tears.\\n\\nElo, please dont cry. Polis red curls bounced as she snapped her head up to glare at Jib. She enfolded Elo in a hug, and Elo sobbed harder on the petite womans shoulder.\\n\\nPoli, come on, Jib sighed. Get Elo settled in the tent and you and I will go tonight. Lets get moving so were not caught in too much rain on the way back.\\n\\n**\\n\\nGabe sat on a cold concrete bench at a cold, round, concrete table, eating cold pizza under a murky and unforgiving sky in which clouds entirely obscured the stars, and in which mist threatened to give way to outright rain. He reflected miserably that of all the ways to eat pizza, this was probably the second-worst. The worst would be back in the break room with the other Kmart employees, where they would have excited yet hushed conversations that did not include him, the night manager.\\n\\nThe table he was sitting at had recently had a fiberglass umbrella to provide meager protection against the elements. Last week, however, seven drunk teenagers had removed it to use as a boat in a very large puddle at the back of the parking lot and it had not been seen since. The sky began to spit at him, and he thought, At least the sky is doing what theyre all thinking.\\n\\nGabe looked up the nearly deserted road and noticed two large figures with an odd gait. They resolved into a tall, bearded man and a petite, redheaded woman, each on horseback, emerging from the mist and entering the Kmart parking lot. Amused, Gabe wondered whether the pair might tie their horses up to the bike racks, or find a parking space near a lamp post and hitch them there, or tether them to a tree.\\n\\nThe man and woman did none of these things. They simply rode the horses through the automatic doors and into the Kmart. Gabe took a moment to process this. He started to get up, looked at his phone, noticed ten minutes remained of his break, and sat back down.\\n\\n**\\n\\nPoli dismounted inside the doors and hitched up a shopping cart to her horse. She nimbly saddled up again, and she and Jib then began perusing the aisles of the Kmart and checking the items off their list.\\n\\nSir? Miss? Can I help you? an employee demanded tersely, body language suggesting the only help would be toward an exit.\\n\\nYes, thank you. We are looking for cookies such as would satisfy a pregnancy craving, Jib replied. He placed some batteries in their cart.\\n\\nCookies? Aisle 12A, the employee responded automatically, then shook her head.  The horses. You cant have them in here. Youll have to take them outside. The employee was joined by two others, all of them looking simultaneously stern and bewildered.\\n\\nThey reached the aisles endcap. Ooh, look, nut mixes are on sale, Poli grinned.\\n\\nGo ahead and get a few, Jib called to her as he rode ahead to select some prenatal vitamins and toothpaste.\\n\\nMiss, please. The two of you need to take the horses outside, the employee wheedled.  As if to respond, Polis horse lifted its tail and dropped a steaming load near the employees boot. The employee leapt back, dismayed.\\n\\nOh, no, Im afraid that wont be possible. These are our service animals, Poli chirped sweetly.\\n\\nThe employees huddled together. Wheres Gabe? they worried. They barked into walkie-talkies to Gabe to come over here RIGHT NOW and received no response.\\n\\nPoli caught up with Jib and together they loaded dry beans and rice into the cart. Suddenly, a voice spoke, as if from the heavens, and a flashing blue light punctuated the announcement:\\n\\nAttention, Kmart shoppers! Blue light special on Aisle 12A. Tedwich Sandwich Cookies, buy two, get one free!\\n\\nWe have to get those for Elo. I bet theyll be perfect! Poli shouted to Jib, and she urged her horse forward. Jib rode after her, followed by the three ineffectual employees, and an ever-growing crowd of onlookers.\\n\\nAisle 12A displayed an alarming variety of cookies, snack cakes, and other treats, and Poli and Jib were, for the first time, ill at ease in the Kmart. A small girl with braids and cutoff jeans approached them.\\n\\nHere you go, she smiled shyly, handing up a box. \\n\\nThank you, Jib smiled back. He tore into the box and passed a handful of the Tedwich cookies to Poli. They sampled the miniature bear-shaped cinnamon cookies sandwiching a vanilla cream filling. They were, indeed, exactly what Elo would love.\\n\\nCan you help us load our cart with every box there is? Poli asked.\\n\\nNot every box. I want to have three for myself, the girl quickly replied.\\n\\nDone.\\n\\nWith all but three boxes of Tedwich cookies in their cart, the only thing left was to find some ice cream to go with them. This expedition caused no small amount of chaos in the freezer case aisle when a small, yappy dog in a handbag spooked the horses, which in turn sent the crowd scattering in all directions. Fortunately, it also resulted in Jibs horse being perfectly positioned in front of a case containing pint after pint of ice cream. They selected one of chocolate and one of vanilla, and Jib and Poli rode to the checkout.\\n\\nPoli pulled a small wooden box from her canvas messenger bag and handed it down to the cashier. This is a very rare and ancient turtle, carved from an unknown precious stone to bring the bearer untold riches. It is more than enough payment for these goods in our cart.\\n\\nPoli and Jib rode out of the store, cart still in tow, as Gabe came back in. The two riders disappeared into the night.\\n\\nThe employees surrounded him. Gabe said nothing. He strolled through the store, surveying the relative lack of damage, the confused shoppers, and the piles of manure, and he grinned as he reached for his walkie-talkie.\\n\\nCleanup on Aisles 6, 7, 10, and 12. Better get a shovel.\\n\\n**\\n\\nElo drifted to sleep that night, completely content, filled with cookies and ice cream. She dreamed of a girl with braids and cutoff jeans, holding boxes and boxes of Tedwich cookies stacked higher than she was tall. She flew above the girl as a deep blue light bathed them both.\\n\\nWhat is your name? Elo asked.\\n\\nTheodosia, the girl answered. The girl flew up to meet Elo and they soared effortlessly through the ceiling and out into the mist.\\n\\nThree months later, in the middle of another rainy night, Elo gave birth to a baby girl. The child was dusted with cinnamon freckles and looked up at Elo with the bluest eyes she had ever seen. She named the girl Theodosia.\\n\";\n\n}).call(this);\n",
      "type": "blob"
    },
    "stories/dungeon-dog": {
      "path": "stories/dungeon-dog",
      "content": "(function() {\n  module.exports = \"Dungeon Crawl with Cliffford!\\n\\nOne sunny day, Cliffford the big rad dog was playing at the park with his friends U-Bone and Cloe. They chased each other through the playground, around the play structures, and through the sand. Children squealed with delight to see Cliffford jump right over the swing set in his excitement. Hes so big! He can jump over things! Heehee! they giggled. THUMP! went Clifffords paws as he landed on the grassy field, and Cloe and U-Bone followed right behind.\\n\\nThe dogs dashed through a soccer game, U-Bone stopping to bite at the ball, and Cleo weaving her way through at least four players legs. They emerged on the other side of the field at the northernmost edge of the park, where the well-kept field gave way to a little meadow, and then the woods.\\n\\nCliffford flopped down in a shady spot, and Cloe and U-Bone stood panting next to him. Cool breezes blew in from the ocean, rippling the leaves on the trees and the long meadow-grass.\\n\\nWhat do you guys want to do now? Cliffford asked. I could really go for a nap.\\nYeah, a nap sounds good, U-Bone replied, snuggling up beside him.\\nWe could nap, but what about going back and trying to get that Frisbee over there? Cloe asked.\\nMmphuhuhmph, U-Bone answered, already half-asleep.\\nAll right, fine, Cloe huffed. Cliffford began to doze as well, so Cloe meandered away, sniffing around the meadow.\\n\\nCliffford? U-BONE! WAAAAAAAKE UP! Cliffford and U-Bone bolted awake, jumping to their feet.\\nHAHAHAHA! Did I scare you? Cloe yipped, bouncing around in circles around her two friends as excitement practically dripped off her.\\nWhats up, Cloe? U-Bone asked.\\nI found something neat. Come with me!\\n\\nWithout looking behind her to see if the others were coming, Cloe took off at a run down a path that Cliffford and U-Bone hadnt seen until now. The path wound through the woods, the trees getting taller and closer together the further along they went. The terrain became rockier, and a few times they dodged around large boulders as they continued forward.\\n\\nAround a bend in the path, Cloe came into view, her tail wagging wildly. She stood in front of a large outcropping with a dark, conveniently Cliffford-sized opening in its face.\\n\\nThis place gives me the willies, U-Bone said, looking around. He noticed crumbling rock around the entrance, which on closer inspection, he realized were carvings of some kind of dog-dragon looking menacingly into his eyes. U-Bone decided not to inspect it further. It was definitely a dungeon.\\n\\nSo? Come on, guys, what do you think? Want to go inside? Cloe asked.\\nYou know, Id really rather just go back and see if we can score any free snacks from the picnic blankets, U-Bone muttered, looking uncomfortable.\\nYeah, Im not even sure Ill fit in there, Cliffford said.\\nUh, Cliffford, did you see the part up there in the paragraph before last where it said the entrance is conveniently Cliffford-sized? Do you remember the last story where you fit into the double doors of a shopping mall? You cant worm your way out of this. Cloe looked smug. Im sure there are all kinds of interesting things to eat in there anyway, U-Bone.\\nOh, all right, Cliffford and U-Bone sighed. Lets enter the dungeon.\\nFuck* yeah! Cloe shouted, and ran inside.\\n\\n*If youre reading this to young children for some reason, have fun substituting the word of your choice. May we suggest fizzle? Forward? Finagle? Forsooth? Just say it with all the energy of a dog hopped up on self-righteousness and youll be fine.\\n\\nCliffford did, indeed, fit inside the entrance, as well as the tunnel just inside. There were plenty of smells wafting around, and his head whipped from side to side trying to take them all in. In doing so, he failed to look at the ground ahead, and he tripped.\\n\\nLook, a bone! Clifford said happily as he scrambled up off the floor. Things were beginning to look up. Cliffford picked it up and gnawed around on it as they trekked deeper into the dungeon.\\n\\nU-Bone noticed some orangish clingy stuff close to the bottom of the cave wall. He sniffed it. Slime mold? Dont mind if I do. He nibbled a little, and then scarfed the rest down in just a few bites. Not bad. He feels invigorated!\\n\\nOh, wow, another one! Cliffford shouted around the bone in his mouth as he stopped to pick up a second bone. And another! This dungeon is turning out to be pretty great.\\n\\nI told you! Cloe grinned. She bounded down the tunnel ahead of the other two. Come on, theres a staircase thats leading down!\\n\\nThe three dogs descended the stairs into near-blackness. No longer lit by the daylight streaming in from the entrance, the dungeon was distinctly murkier. Something brushed past U-Bones ear and he snapped at it.\\n\\nI found a torch! Cloe said. I wonder if theres any way to light it. Wed better take it with us. She grabbed the torch in her mouth and crept into the gloom.\\n\\nThe trio inched forward, sniffing and listening before moving along the path. Eventually, the darkness lifted a little bit, and they approached a second, lit torch set into a sconce in the wall. Even Cloe felt better once she lit their torch, which now illuminated a small circle around them.\\n\\nSomething else glinted in the darkness just beyond them. Cloe moved closer and the dogs saw a beautifully crafted, lightweight sword lying on the dusty floor. This ones all yours, U-Bone, Cliffford said through his mouthful of bones. U-Bone gingerly took the sword and swung it around a few times. Cliffford and Cloe saw his apprehension turn to excitement as U-Bone growled, advanced on a spiderweb, and dispatched it.\\n\\nU-Bone stumbled upon a sheath and baldric for the sword a short distance away, and strapped them on. BOSS! A few turns of the path later, and the dogs found another staircase down. Come on, its a dungeon crawl. Of course they found another staircase!\\n\\nThe dogs explored further and deeper into the dungeon. Clifffords mouth was crammed as full as possible with bones, and he looked sadly at each one he had to leave behind as they pressed on.\\n\\nHumuhlauhsunrrmmmuh, said the big rad dog, furrowing his brows.\\nHmm? asked Cloe, through the side of her mouth around the torch.\\nMmmmahhhhh! U-Bone hollered as he turned a bat into a meat icon that dropped a large leather satchel and a helmet that fit no one.\\n\\nCliffford pawed the satchel with his foot, turning it over. It flopped open. There was nothing inside, so he started to put his bones in his bag. He was delighted to find every single one fit, and then some. Huzzzah! A bag of holding! he shouted, and raced forward to find more.\\n\\nInstead, Cliffford found a kobold corpse. He sniffed it, hesitated, sniffed again, shrugged, and dug in. Any good? U-Bone asked, sheathing his sword. Ugh, no, this corpse is definitely tainted, Clifford said, not lifting his head from his meal. U-Bone sniffed the corpse and took a bite. Yeah, man, ugh, thats rank. Dont eat those guys.\\n\\nThe dogs began to feel thirsty from all their exertions, and conveniently the next level had some water! They descended the stairs to find themselves standing in front of an expanse of shimmering deep blue-violet, a gorgeous underground lake.\\n\\nIts beautiful! Cloe sighed. She bent down to drink, and U-Bone followed suit. Cliffford bent over, too, and as he drank, his stomach began to twist. Uh, guys? Cliffford said. HUUUGGGGGGHHHHHHHHHH, he retched, and vomited into the lake. He lay down in the mud on the shore.\\n\\nU-Bone noticed a sign nearby. Lake of Eternal Cleanliness, he read.\\nDude, not anymore. HAH! Cloe barked.\\n\\nJust then, they heard a shout ahead of them. A small, crotchety dog-dragon-hermit thing emerged from a hovel at the edge of the lake.\\n\\nTHIS LAKE HAS BEEN PRISTINE FOR NINE HUNDRED THIRTY SEVEN YEARS! shouted the angry lake-keeper, shaking one fist wildly and wielding a Staff of Glowing Menace in the other. Cloe backed up, and U-Bone got his sword ready, but Cliffford still lay in the mud, groaning.\\n\\nJust then, Cliffford happened to twist his head at just the right angle to notice a small vial of something pink resting in the mud by his ear. He quaffed this (come on, Cliffford, stop ingesting all these questionable things!) and instantly felt not only invigorated, but also amplified! Cliffford barked an ear-poppingly loud enchanted bark, which repelled the lake-keeper and sent him splashing into the Lake of Recent Uncleanliness, and the three friends hauled ass* (*apples?) further down into the dungeon.\\n\\nBy the time the dogs felt like they could slow down, they had descended what felt like (and was) the umpteenth flight of stairs. They came out in front of a small, narrow opening. Cloe held the torch while U-Bone scouted inside, and he noticed that the path was twistier and turnier than the rest of the dungeon had been.\\n\\nI think its a labyrinth, he said, as the two smaller dogs emerged from the entrance. But Cliffford, I dont think youre going to fit.\\n\\nIm going to look around and see if theres any way around, Cloe said, and trotted off. She came back a few moments later with a rolled-up piece of paper.\\n\\nHey guys, whats this? she said, dropping it in front of the others.\\nIts some kind of scroll, U-Bone said, nosing at it.\\nIs that like some kind of newspaper? she asked. I love newspapers! I like to go out really early in the morning right after theyre delivered, slide them out of their plastic sleeve, and shaaaaaaaaaake them so hard that they get all shredded up! Its so funny! Cloe giggled. Im going to go for it. I think this scroll is going to be pretty satisfying too.\\n\\nCloe whipped her head back and forth, and the scroll unfurled, revealing the text GRRMOC UHLPROOT in old-timey writing, and she stopped. Grrmoc uhlproot? she asked, and instantly, Cliffford fell to the ground. Yeah, the scroll was totally cursed.\\n\\nA moment later, Cliffford was back up again, only now he was the size of a normal dog. Yup!\\n\\nThis was a very useful development for our plot, because they heard shouts from the top of the stairs. The angry lake-keepers scratchy toenails clicked on the stone treads as he skittered down toward them.\\n\\nThe dogs wasted no time, and all three dove right into the entrance to the labyrinth. They tried their best to stay together, but Clifford, unused to being tiny, lagged behind. He felt weak, and needed food badly.\\n\\nThe other dogs called encouragingly behind them for Cliffford to hurry the fuck* (*fart!) up, but he stopped short when he saw some meat lying in a corner. It was another kobold corpse. His brain said to him, Hey, wait a second, Cliffford, but then he discovered hed already begun to eat it.\\n\\nOh yeah, this ones tainted too.\\n\\nThe dogs all managed to find their way to the center of the labyrinth in enough time to marvel at the treasure there: the Squeaky Toy of Canidae. A lovely, fuzzy, stuffed squirrel with a magical squeaker that never, ever breaks, and that is also enchanted with legendary but vague special powers.\\n\\nTheir marvel was cut short by the angry lake-keeper, who barreled into the center of the labyrinth behind them, hollering. Cliffford turned to face the lake-keeper, and felt a familiar twist in his stomach as he did so.\\n\\nHGGGGGRRRRRRRPH! he grunted, spewing vomit all over the lake-keeper. It sizzled as it hit the lake-keeper, dealing quite a bit of damage. It also broke a curse on the lake-keeper, and from his crusty, smelly robes emerged Moc.\\n\\nWhat is going on? Ive been in this godforsaken cave for the last five and a half days* (*937 dog-hours!). The whole time Ive been having repeated nightmares that Im some sort of disgusting hermit encamped by a lake. He shook himself, and droplets of vomit spattered the labyrinth walls.\\n\\nAnd you, Cliffford, your vomit seems to be a recurring feature in my nightmares as well. Can we please get out of here? Moc huffed, as he caught a whiff of the tainted, partially digested kobold corpse clinging to his fur.\\n\\nHey, guys, I think Mocs curse isnt the only one thats broken!! Cliffford shouted, as he began to grow and grow. The rapid growth broke down the walls of the labyrinth, revealing a clear path to the exit.\\n\\nCliffford stuffed the Squeaky Toy of Canidae into his bag of holding, and all the other dogs hopped on his back and held on for dear life as Cliffford sprinted out of the dungeon and back into the sunshine of the park.\\n\\nAfter rolling around in the grass to get the last of the spiderwebs and vomit off themselves, the dogs went back to Clifffords doghouse, where they all feasted on the bones from Clifffords bag of holding and took turns with the Squeaky Toy of Canidae.\\n\\nThe friends all agreed that it was the best dungeon crawl ever!\\n\\nTHE END!!\";\n\n}).call(this);\n",
      "type": "blob"
    },
    "stories/mystery-smell": {
      "path": "stories/mystery-smell",
      "content": "(function() {\n  module.exports = \"The Mystery Smell\\n\\nIve got one! Cloe shouted. Cliffford, the big rad dog, and his friends U-Bone, Cloe, Moc, Cassy, and Bub were playing their favorite game  Mystery Smell.\\n\\nIts smoky and garlicky and meaty, said Cloe, and its coming from a backyard! The other dogs trotted down the street, sniffing everywhere until they found the source of the smell.\\n\\nIts a backyard barbecue! called U-Bone from across the street. I smell carne asada!\\nYou got it! Cloe answered.\\n\\nMy turn! said Cliffford as he caught a whiff of something on the breeze. Its strong, almost but not quite like mint, and its coming from up high.\\n\\nHmmm, thought the others. They passed through a park at the end of the street, and the others found the smell right away. Eucalyptus trees! Moc declared triumphantly, looking up into the tall trees that grew around the perimeter of the park.\\n\\nCassys nose picked up the trail of a jogger, and the dogs gleefully bounded along, following it until it ended at a house a few blocks away.\\n\\nI smell something citrusy! U-Bone barked, and his friends sniffed the air. They found a neighbor picking lemons off a tree in their front yard.\\n\\nGUYS! shouted Bub. I have one, and its amazing!\\n\\nWhat is it like? Cliffford wondered, and the others waited expectantly.\\n\\nWell, its...you know...sort of...something...with a hint of...I cant explain it. Poor Bub was just a puppy and didnt know the names of all the tantalizing smells in the neighborhood.\\n\\nThe other dogs sniffed their noses in all directions, hoping to help Bub name the smell he had found. Suddenly, they heard a yip! and a scratching of claws and the dogs turned to see Bub bounding away down the street.\\n\\nBub! shouted Cliffford. Bub kept on running. The big rad dog sighed. Bub is such a little puppy, but he always gets into BIG trouble. Wed better go after him.\\n\\nCliffford, U-Bone, Cloe, Moc, and Cassy took off after Bub. They practically flew over the sidewalk! They reached the end of the block to see Bubs tail disappear around the corner. They rounded the corner themselves and stopped short.\\n\\nWhat is that huge building? U-Bone asked. The dogs stared together at the building, which was situated in the middle of a very large, very busy parking lot.\\n\\nIts a shopping mall! Cloe shouted. Miss Dollar takes me there sometimes. People go there and look at things, and sometimes they take the things out in bags.\\nBub just went inside, guys. Wed better go in after him, Moc said. The dogs quickly but carefully crossed the street, navigated the cars circling for parking spots, and made their way to the double doors of the BIZWELL MALL.\\n\\nThe mall had two floors, so the dogs split up. U-Bone and Cloe dashed for the escalators and each took one side of the top floor. Moc and Cassy stayed downstairs and each took a side. Cliffford went down the middle, with his feet on the first floor and his nose up in the second!\\n\\nAll five dogs dodged strollers and shopping bags, kiosks and benches, as they continued in pursuit of Bub.\\n\\nBub, meanwhile, was having a fantastic time. He had no idea what this huge building was, but the smells were tantalizing! He found a place with all kinds of different food, from curries to noodles to pizza to tacos, labeled Food Court. He picked up the smell of freshly baked waffle cones, and chocolate chip ice cream as he ran by a kiosk, and paused only briefly to lick the remains of a childs dropped cone.\\n\\nBub passed a storefront selling candy, and savored the whiffs of peppermint candy canes and caramels and chocolates coming from the entrance. He scampered by a store loaded with candles, body lotions and sprays, all with fruity and floral fragrances.\\n\\nShoes! squealed Bub, as he skittered past a store with hundreds of pairs of brand-new sneakers lining the walls. Bub was tempted to dive headfirst into the store selling leather handbags and wallets and belts and jackets, and chew on everything in sight, but he thought better of it. Besides, all the smells he smelled in this wondrous building were familiar. None of them were the new and enticing scent he was trying to find.\\n\\nPassing a coffee-and-tea kiosk and inhaling the aroma of the freshly ground beans and steaming cups of tea, Bub found himself at the other end of Bizwell Mall. He had nowhere to go but straight into the anchor store at the end, dodging displays as he kept sniffing. The scent was getting stronger  he must be almost there!\\n\\nWearily, the other dogs approached the anchor store as well, just in time to see Bub running headlong into it. They summoned the last of their energy, marveling at Bubs stamina, and ran through the store themselves.\\n\\nWell, I think weve lost him, Cliffford huffed to his friends. I dont see him anywhere, and were here at the exit.\\n\\nWait! Cassy shouted. Isnt that Bub outside?\\n\\nThe dogs burst out the doors and into the cool air, and there was Bub, happily rolling around on the ground.\\n\\nI found it, guys!! Bub called, as he flopped on his back once more and wriggled in the source of his scent: pine needles, fallen from hundreds of freshly cut Christmas trees, filling up a large portion of the parking lot outside the store.\\nThe other dogs agreed that Christmas trees did smell very, very good. Bub had not caused any damage, only a merry chase, so they were all quite relieved. They all meandered through the tree lot, sniffing and looking.\\n\\nCliffford decided that he wanted to get a tree for his doghouse, and picked the biggest, tallest tree he could find. It was taller than he was! The proprietor of the Christmas tree lot wrapped it up for him with rope, making two straps that Cliffford could wear like a backpack. Bub proudly jumped up on Clifffords head as they headed for home, with the other dogs close behind.\\n\\nEmma was waiting back at Clifffords doghouse, hoping to read him a story, and she gaped as the dogs entered the doghouse. She laughed when she saw what they had with them, and said, I think were going to need more decorations than what we have in the garage!\\n\\nIn the end, it took two trips back to the mall, a hundred strands of lights, and a thousand ornaments to decorate the huge tree. The dogs gave Bub the honor of plugging it in, and they all agreed it was the best Christmas tree ever.\";\n\n}).call(this);\n",
      "type": "blob"
    },
    "stories/provision": {
      "path": "stories/provision",
      "content": "(function() {\n  module.exports = \"One hundred or so years from now, when I\\ndie, my descendants come across this\\nrich text file while going through the\\ndrawers and the suitcases in my husband\\nand I's house under the pretense of\\ncleaning. They will try to understand\\nwho we were and if we ever were more\\nthan just parents. They will have\\nproblems with technology that has yet to\\nbe invented; they will have kids and\\nlovers that I will never meet.\\n\\nMy husband will die twenty or so years\\nbefore me. He will fall asleep at Sam's\\nClub and refuse to wake up. A\\nbadly-shaken mid-level Sam's Club\\nfranchise manager with kind eyes and a\\npolo T-shirt and exactly one earring\\nwill knock on my door and deliver the\\nnews. I will feel weak and, 18 hours\\nlater, I will cry.\\n\\nI want you to know how ordinary I was. I\\nwanted to be one person and then I ended\\nup being someone else. Cumulatively I\\nthought I had serious fantasies about\\nmarrying three different people and,\\nafter college, I ended up marrying the\\nsecond. I was part of a dozen thousand\\nwho fled to Canada during the dark\\nyears. My grocer patiently taught me how\\nto say 100 words in a French-Canadian\\naccent and gave me the courage to eat\\nugly vegetables. I could have traveled\\nmore and been happy. I could have not\\ntraveled more and been happy.\\n\\nThe worst part about traveling is all\\nthe advertisements for foreign brands.\\nWalking home at night under the\\nspotlights of billboards with which you\\ncannot empathize is a piercing kind of\\nloneliness. The best part about\\ntraveling is meeting all the other\\nexpats in your city, who each is tacitly\\na member of a busy and tired club.\\n\\nMy parents were Armenian mathematicians.\\nThey left their country, which gave me\\nthe courage to leave mine. They were\\nconstantly worried about me and, to\\ndistract themselves, they bought and\\nflipped real estate. The first time you\\nbuy a house it seems impossible that\\neach room will fill with the right\\nfurniture and the each wall will have\\nthe right artwork. The second time is\\ntwice as easy; and the third is twice\\nthat. They met one hundred or so\\ndifferent people that way, which I think\\nsomehow made my relationship with them\\nbetter or at least easier. Toward the\\nend they will play gin with their\\nneighbors in the morning and watch\\nArmenian television in the afternoon, on\\na small satellite modem that only\\nArmenians know where to buy. They forgot\\nEnglish first, then walking, then\\nbreathing. Acting on this information, I\\nwill try to die much faster.\\n\\nThe early 2010s will be remembered\\nfondly as a simpler time, and\\nadditionally I want to add they were my\\nfavorite years. The late 2040s were good\\ntoo, as were the 2060s. It will become\\ndifficult to separate the objective\\nquality of a time period from how much\\nof a burden my body becomes. Every year\\nI will buy clothes that looked like all\\nthe clothes I owned fifteen years ago\\nuntil, one day, I throw everything out\\nthat isn't white and blue. I will die in\\na white blouse and blue shorts. In death\\nI will stop looking cute and start\\nlooking serene.\\n\\nThough I know some facts about the\\nfuture I have a great deal of questions.\\nWhat are the food trends now? Are there\\nany new bands that sound like the old\\nbands I liked? Do radiators still break\\nduring the coldest week?\\n\\nMy husband and I ran into each other in\\nthree different cities. The first two\\ntimes we recognized in each other an\\nunderstanding that the timing was off.\\nThe third time we fucked in a friend's\\ncloset, groping each other like we were\\nyounger, beneath layers of woolen duvets\\nthat we by accident pulled down. It\\nseemed tawdry and sticky at the time and\\nnow it's just a sentence.\\n\\nInto our lives we carved out space for\\neach other. We put up load-bearing\\nbeams. We added good thick curtains and\\na little OLED display that read the\\namount of humidity in the air. We agreed\\nto never make the other person sleep on\\nthe couch, as we wanted ours to be\\nfilled with the flatulence of our\\nfriends. We threw the best parties. We\\nwere an unstoppable hosting machine. We\\nfigured out that a party becomes the\\nmemory of a party. It happens one or two\\ndays after the party, when the\\nconversation and the discoveries curdle\\ninto something distant and bittersweet.\\n\\nThe city will build a subway station\\nnear us in 2031 after years of private\\nfunding into subterranean\\ninfrastructure. The money will come from\\ntech moguls looking to survive zombies\\nand/or climate change, but a subway\\nstation is a subway station. One late\\nnight, as we step off the train on our\\nway home, we will walk past a woman\\nwearing a bright striped parka. I will\\nturn my head to get a second look and\\nshe will not be there. I will crook my\\nhead to see behind the poles until my\\nneck hurts, and still I will see no one.\\nI will turn to my husband, who sees my\\nface, and we will walk home with his\\nhead lying on my shoulder and his hand\\nlying on my chest so that my\\ninexplicably racing heartbeat will bang\\nand shudder against his hand like a\\nhurricane's wind against the shutters of\\na house where nobody has ever lived.\";\n\n}).call(this);\n",
      "type": "blob"
    },
    "style": {
      "path": "style",
      "content": "module.exports = \"body {\\n  overflow: hidden;\\n}\\nh1 {\\n  line-height: 1.25em;\\n  margin: 0;\\n}\\nul {\\n  list-style-type: square;\\n  padding-left: 1.25em;\\n}\\ncomments,\\ncomment {\\n  display: block;\\n  padding: 1em;\\n}\\ncomment {\\n  border: 1px solid #000;\\n  margin-bottom: 1em;\\n}\\ncomment:last-child {\\n  margin-bottom: 0;\\n}\\ncomment > .author {\\n  color: #808080;\\n  font-size: 0.75em;\\n  text-align: right;\\n}\\ncomment > .author::before {\\n  content: \\\"-\\\";\\n}\\nexplorer {\\n  display: block;\\n  padding: 0.5em;\\n  user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n}\\nbody > explorer {\\n  height: 100%;\\n  width: 100%;\\n}\\nexplorer > file,\\nexplorer > folder {\\n  display: inline-block;\\n  padding: 0.5em;\\n}\\nexplorer > file > icon,\\nexplorer > folder > icon {\\n  display: block;\\n  height: 32px;\\n  margin: auto;\\n  width: 32px;\\n}\\nexplorer > file > icon {\\n  background-image: url(\\\"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAACHd3d3d3d3d3d3d3dwAAAAj///////////////cAAAAI///////////////3AAAACP///////3d///d39wAAAAj/zMzM//mZ//+Zn/cAAAAI////////l///+X/3AAAACP/MzMzM//l3d3l/9wAAAAj/////////mZmZf/cAAAAI/8zMzMzM//l/+X/3AAAACP//////////l/l/9wAAAAj/zMzMzMzM//l5f/cAAAAI////////////mX/3AAAACP/MzMzMzMzM//n/9wAAAAj///////////////cAAAAI/8zMzMzMzMzMzP/3AAAACP//////////////9wAAAAj/zMzMzMzMzMzM//cAAAAI///////////////3AAAACP8AAAAA/8zMzMz/9wAAAAj/iZD/8P////////cAAAAI/4AAAAD/zMzMzP/3AAAACP+P8Luw////////9wAAAAj/gAC7sP/MzMzM//cAAAAI/4/wu7D////////3AAAACP+P8Luw/////4AAAAAAAAj/j/AAAP////+P94AAAAAI/4/wzMD/////j3gAAAAACP+IiIiA/////4eAAAAAAAj///////////+IAAAAAAAI////////////gAAAAAAACIiIiIiIiIiIiIAAAAAA4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAP4AAAH+AAAD/gAAB/4AAA/+AAAf8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAACHd3d3d3cAAI//////9wAAj8z5//n3AACP//+ZmfcAAI/MzPn59wAAj////5n3AACPzMzM+fcAAI//////9wAAjwAPzMz3AACPmY////cAAI/Pj8zM9wAAj8+P//AAAACPiI//9/gAAI/////3gAAAiIiIiIgAAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIAHAACADwAAgB8AAA==\\\");\\n}\\nexplorer > file[type^=\\\"text/\\\"] > icon {\\n  background-image: url(\\\"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAACHd3d3d3d3d3d3dwcAAAAI//////////////9wcAAACP//////////////cHAAAAj/AAAA/////////3BwAAAI//////////////9wcAAACP8AAAD/////////cHAAAAj//////////////3BwAAAI//////////////9wcAAACP8AAAAAAAAAAAD/cHAAAAj//////////////3BwAAAI/wAAAAAAAAAAAP9wcAAACP//////////////cHAAAAj/AAAAAAAAAAAA/3BwAAAI//////////////9wcAAACP8AAAAAAAAAAAD/cHAAAAj//////////////3BwAAAI//////////////9wcAAACP8AAAD/////////cHAAAAj//////////////3BwAAAI//////////////9wcAAACP//////////////cHAAAAj/AAAA/////////3BwAAAI//////////////9wcAAACP8AAAD////w8AD/cHAAAAj//////////////3BwAAAI//////////////9wcAAACP//////////////cHAAAAjw/w/w/w/w/w/w/4BwAAAI8P8P8P8P8P8P8P+AcAAAAI+I+I+I+I+I+I+I+AAAAAAAAAAAAAAAAAAAAAAAAA8AAAH+AAAA/AAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAH4AAAD/JJJL8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAh3d3d3d3AACP//////cAAI//////9wAAj/AAAA/3AACP//////cAAI/wAAAP9wAAj//////3AACP8AAAD/cAAI//////9wAAj/AA8A/3AACP//////cAAI//////9wAAjw8PDw8PAAAA+Pj4+PAAAAAAAAAAAAAAgA8AAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAACADwAA1V8AAA==\\\");\\n}\\nexplorer > file[type=\\\"application/javascript\\\"] > icon {\\n  background-image: url(\\\"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAACHd3d3d3d3d3d3dwcAAAAI//////////////9wcAAACP//////////////cHAAAAj/AAAA////AAD//3BwAAAI////////AwsDAP9wcAAACP8AAAD//zu7uzD/cHAAAAj///////M7MDsAD3BwAAAI///////zuwgLsw9wcAAACP8AAAAAAzswOwAPcHAAAAj///////87u7sw/3BwAAAI/wAAAAAAMwsDAP9wcAAACP////////8zM///cHAAAAj/AAAAAAAAAAAA/3BwAAAI//////////////9wcAAACP8AAAAAAAAAAAD/cHAAAAj//////////////3BwAAAI//////////////9wcAAACP8AAAD/////////cHAAAAj//////////////3BwAAAI//////////////9wcAAACP//////////////cHAAAAj/AAAA/////////3BwAAAI//////////////9wcAAACP8AAAD////w8AD/cHAAAAj//////////////3BwAAAI//////////////9wcAAACP//////////////cHAAAAjw/w/w/w/w/w/w/4BwAAAI8P8P8P8P8P8P8P+AcAAAAI+I+I+I+I+I+I+I+AAAAAAAAAAAAAAAAAAAAAAAAA8AAAH+AAAA/AAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAH4AAAD/JJJL8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAACHd3d3d3cAAI//////9wAAj///Aw/3AACP8Ac7MPcAAI//87Cz9wAAj/AHOzD3AACP//9zf/cAAI/wAAAP9wAAj//////3AACP8ADwD/cAAI//////9wAAj//////3AACPDw8PDw8AAAD4+Pj48AAAAAAAAAAAAAwAcAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAADABwAA6q8AAA==\\\");\\n}\\nexplorer > folder > icon {\\n  background-image: url(\\\"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACDMzMzMzMzMzMzMzMzMzMwj7e3t7e3t7e3t7e3t7e3MI97e3t7e3t7e3t7e3t7ezCPt7e3t7e3t7e3t7e3t7cwj3t7e3t7e3t7e3t7e3t7MI+3t7e3t7e3t7e3t7e3tzCPe3t7e3t7e3t7e3t7e3swj7e3t7e3t7e3t7e3t7e3MI97e3t7e3t7e3t7e3t7ezCPt7e3t7e3t7e3t7e3t7cwj3t7e3t7e3t7e3t7e3t7MI+3t7e3t7e3t7e3t7e3tzCPe3t7e3t7e3t7e3t7e3swj7e3t7e3t7e3t7e3t7e3MI97e3t7e3t7e3t7e3t7ezCPt7e3t7e3t7e3t7e3t7cwj3t7e3t7e3t7e3t7e3t7MI+3t7e3t7e3t7e3t7e3tzCPe3t7e3t7e3t7e3t7e3swj7e3t7e3t7e3t7e3t7e3MI///////////////////wCHd3d3d3d3d4iIiIiIiIgACPt7e3t7e3gAAAAAAAAAAACPt7e3t7eAAAAAAAAAAAAACP/////4AAAAAAAAAAAAAACIiIiIgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////////gAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAP//wAH//+AD///wB/////////////8oAAAAEAAAACAAAAABAAQAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIiIiIiIiIgAj7e3t7e3uACPe3t7e3t4AI+3t7e3t7gAj3t7e3t7eACPt7e3t7e4AI97e3t7e3gAj7e3t7e3uACP///////4AIe3t7eIiIgACHt7eAAAAAAAiIiAAAAAAAAAAAAAAAAA//8AAP//AACAAQCgAAHOAAABzgAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAMAAID/AADB/wAA//8AAA==\\\");\\n}\\n#modal > container {\\n  padding: 1em;\\n}\\nchateau {\\n  width: 100%;\\n  height: 100%;\\n  position: relative;\\n}\\nchateau > word-area {\\n  display: block;\\n  pointer-events: none;\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n}\\nchateau > word-area > words {\\n  border: 1px solid #000;\\n  border-radius: 4px;\\n  background-color: #fff;\\n  padding: 0.5em;\\n  position: absolute;\\n  display: inline-block;\\n}\\nchateau > canvas {\\n  display: block;\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n}\\nchateau > form {\\n  position: absolute;\\n  bottom: 0;\\n}\\nwindow > viewport > chateau {\\n  margin: initial;\\n}\\nachievement {\\n  color: #fff;\\n  background-color: #00f;\\n  border-radius: 32px;\\n  bottom: -128px;\\n  box-shadow: 2px 2px 10px #000;\\n  display: block;\\n  height: 64px;\\n  left: 0;\\n  margin: auto;\\n  overflow: hidden;\\n  padding: 8px;\\n  position: absolute;\\n  right: 0;\\n  width: 300px;\\n  z-index: 9000;\\n}\\nachievement:after {\\n  animation: slide-left 3s linear 0.75s infinite;\\n  content: \\\"\\\";\\n  background: linear-gradient(50deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0) 40%, rgba(255,255,255,0.95) 50%, rgba(255,255,255,0) 75%, rgba(255,255,255,0) 100%);\\n  height: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 100%;\\n  width: 100%;\\n}\\nachievement.display {\\n  animation: display-achievement 6s;\\n}\\nachievement > h2 {\\n  font-size: 1.25em;\\n  margin: 0;\\n}\\nachievement > p {\\n  margin-top: 8px;\\n  margin-bottom: 8px;\\n}\\nachievement > icon {\\n  background-color: #fff;\\n  border-radius: 32px;\\n  color: #00f;\\n  display: inline-block;\\n  float: left;\\n  font-size: 35px;\\n  font-family: \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"NotoColorEmoji\\\", \\\"Segoe UI Symbol\\\", \\\"Android Emoji\\\", \\\"EmojiSymbols\\\";\\n  height: 48px;\\n  line-height: 48px;\\n  margin-right: 8px;\\n  text-align: center;\\n  width: 48px;\\n}\\nachievement-badges {\\n  display: block;\\n}\\nachievement-progress {\\n  display: block;\\n}\\nachievement-progress > h2 {\\n  margin-bottom: 4px;\\n}\\nachievement-badge {\\n  background-color: #fff;\\n  border: 1px solid #808080;\\n  color: #808080;\\n  display: inline-block;\\n  font-size: 35px;\\n  font-family: \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"NotoColorEmoji\\\", \\\"Segoe UI Symbol\\\", \\\"Android Emoji\\\", \\\"EmojiSymbols\\\";\\n  height: 48px;\\n  line-height: 48px;\\n  margin-right: 8px;\\n  margin-top: 8px;\\n  text-align: center;\\n  width: 48px;\\n}\\nachievement-badge.achieved {\\n  border: 1px solid #00f;\\n  color: #00f;\\n}\\n@-moz-keyframes display-achievement {\\n  0% {\\n    bottom: -128px;\\n  }\\n  5% {\\n    bottom: 2em;\\n  }\\n  95% {\\n    bottom: 2em;\\n  }\\n  100% {\\n    bottom: -128px;\\n  }\\n}\\n@-webkit-keyframes display-achievement {\\n  0% {\\n    bottom: -128px;\\n  }\\n  5% {\\n    bottom: 2em;\\n  }\\n  95% {\\n    bottom: 2em;\\n  }\\n  100% {\\n    bottom: -128px;\\n  }\\n}\\n@-o-keyframes display-achievement {\\n  0% {\\n    bottom: -128px;\\n  }\\n  5% {\\n    bottom: 2em;\\n  }\\n  95% {\\n    bottom: 2em;\\n  }\\n  100% {\\n    bottom: -128px;\\n  }\\n}\\n@keyframes display-achievement {\\n  0% {\\n    bottom: -128px;\\n  }\\n  5% {\\n    bottom: 2em;\\n  }\\n  95% {\\n    bottom: 2em;\\n  }\\n  100% {\\n    bottom: -128px;\\n  }\\n}\\n@-moz-keyframes slide-left {\\n  0% {\\n    left: 100%;\\n  }\\n  25% {\\n    left: 0;\\n  }\\n  50% {\\n    left: -100%;\\n  }\\n  100% {\\n    left: -100%;\\n  }\\n}\\n@-webkit-keyframes slide-left {\\n  0% {\\n    left: 100%;\\n  }\\n  25% {\\n    left: 0;\\n  }\\n  50% {\\n    left: -100%;\\n  }\\n  100% {\\n    left: -100%;\\n  }\\n}\\n@-o-keyframes slide-left {\\n  0% {\\n    left: 100%;\\n  }\\n  25% {\\n    left: 0;\\n  }\\n  50% {\\n    left: -100%;\\n  }\\n  100% {\\n    left: -100%;\\n  }\\n}\\n@keyframes slide-left {\\n  0% {\\n    left: 100%;\\n  }\\n  25% {\\n    left: 0;\\n  }\\n  50% {\\n    left: -100%;\\n  }\\n  100% {\\n    left: -100%;\\n  }\\n}\\n\";",
      "type": "blob"
    },
    "system": {
      "path": "system",
      "content": "(function() {\n  var Achievement, Associations, Bindable, DexieFS, DexieFSDB, Model, SystemModule, Template, UI, fileSeparator, invokeBefore, normalizePath, uniq, _ref;\n\n  _ref = require(\"./util\"), fileSeparator = _ref.fileSeparator, normalizePath = _ref.normalizePath;\n\n  DexieFSDB = function(dbName) {\n    var db;\n    if (dbName == null) {\n      dbName = 'fs';\n    }\n    db = new Dexie(dbName);\n    db.version(1).stores({\n      files: 'path, blob, size, type, createdAt, updatedAt'\n    });\n    return db;\n  };\n\n  DexieFS = function(db) {\n    var Files, notify, self;\n    Files = db.files;\n    notify = function(eventType, path) {\n      return function(result) {\n        self.trigger(eventType, path);\n        return result;\n      };\n    };\n    return self = Model().include(Bindable).extend({\n      read: function(path) {\n        return Files.get(path);\n      },\n      write: function(path, blob) {\n        var now;\n        now = +(new Date);\n        return Files.put({\n          path: path,\n          blob: blob,\n          size: blob.size,\n          type: blob.type,\n          createdAt: now,\n          updatedAt: now\n        }).then(notify(\"write\", path));\n      },\n      update: function(path, changes) {\n        return Files.update(path, changes).then(notify(\"update\", path));\n      },\n      \"delete\": function(path) {\n        return Files[\"delete\"](path).then(notify(\"delete\", path));\n      },\n      list: function(dir) {\n        return Files.where(\"path\").startsWith(dir).toArray().then(function(files) {\n          files.forEach(function(file) {\n            return file.relativePath = file.path.replace(dir, \"\");\n          });\n          return files;\n        });\n      }\n    });\n  };\n\n  uniq = function(array) {\n    return Array.from(new Set(array));\n  };\n\n  Bindable = require(\"bindable\");\n\n  Model = require(\"model\");\n\n  Achievement = require(\"./system/achievement\");\n\n  Associations = require(\"./system/associations\");\n\n  SystemModule = require(\"./system/module\");\n\n  Template = require(\"./system/template\");\n\n  UI = require(\"ui\");\n\n  module.exports = function(dbName) {\n    var fs, self;\n    if (dbName == null) {\n      dbName = 'zine-os';\n    }\n    self = Model();\n    fs = DexieFS(DexieFSDB(dbName));\n    self.include(Achievement, Associations, SystemModule, Template);\n    self.extend({\n      fs: fs,\n      readFile: function(path, userEvent) {\n        if (userEvent) {\n          self.Achievement.unlock(\"Load a file\");\n        }\n        path = normalizePath(\"/\" + path);\n        return fs.read(path).then(function(_arg) {\n          var blob;\n          blob = _arg.blob;\n          return blob;\n        });\n      },\n      writeFile: function(path, blob, userEvent) {\n        if (userEvent) {\n          self.Achievement.unlock(\"Save a file\");\n        }\n        path = normalizePath(\"/\" + path);\n        return fs.write(path, blob);\n      },\n      deleteFile: function(path) {\n        path = normalizePath(\"/\" + path);\n        return fs[\"delete\"](path);\n      },\n      updateFile: function(path, changes) {\n        path = normalizePath(\"/\" + path);\n        return fs.update(path, changes);\n      },\n      execJS: function(path) {\n        return self.readFile(path).then(function(file) {\n          return file.readAsText();\n        }).then(function(programText) {\n          return Function(programText)();\n        });\n      },\n      Observable: UI.Observable,\n      UI: UI\n    });\n    invokeBefore(UI.Modal, \"hide\", function() {\n      return self.Achievement.unlock(\"Dismiss modal\");\n    });\n    return self;\n  };\n\n  invokeBefore = function(receiver, method, fn) {\n    var oldFn;\n    oldFn = receiver[method];\n    return receiver[method] = function() {\n      fn();\n      return oldFn.apply(receiver, arguments);\n    };\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "system/achievement": {
      "path": "system/achievement",
      "content": "(function() {\n  var Achievement, AchievementProgressPresenter, Observable, UI, achievementData, emptyElement, groupBy, persist, restore;\n\n  Achievement = require(\"../lib/achievement\");\n\n  Observable = (UI = require(\"ui\")).Observable;\n\n  emptyElement = require(\"../util\").emptyElement;\n\n  achievementData = [\n    {\n      text: \"Issue 1\",\n      icon: \"\",\n      group: \"Issue 1\",\n      description: \"View Issue 1\"\n    }, {\n      text: \"Cover-2-cover\",\n      icon: \"\",\n      group: \"Issue 1\",\n      description: \"Read the entire issue\"\n    }, {\n      text: \"No rush\",\n      icon: \"\",\n      group: \"Issue 1\",\n      description: \"Patience is a virtue\"\n    }, {\n      text: \"Issue 2\",\n      icon: \"\",\n      group: \"Issue 2\",\n      description: \"View Issue 2\"\n    }, {\n      text: \"Lol wut\",\n      icon: \"\",\n      group: \"Issue 2\",\n      description: \"Did you know Windows Vista had a magazine?\"\n    }, {\n      text: \"Cover-2-cover 2: 2 cover 2 furious\",\n      icon: \"\",\n      group: \"Issue 2\",\n      description: \"Read the entire issue\"\n    }, {\n      text: \"Feeling the frog\",\n      icon: \"\",\n      group: \"Issue 2\",\n      description: \"Visit frogfeels.com\"\n    }, {\n      text: \"The dungeon is in our heart\",\n      icon: \"\",\n      group: \"Issue 2\",\n      description: \"Played dungeon of sadness\"\n    }, {\n      text: \"Issue 3\",\n      icon: \"\",\n      group: \"Issue 3\",\n      description: \"View Issue 3\"\n    }, {\n      text: \"Cover-2-cover 3: Tokyo Drift\",\n      icon: \"\",\n      group: \"Issue 3\",\n      description: \"Read the entire issue\"\n    }, {\n      text: \"Blue light special\",\n      icon: \"\",\n      group: \"Issue 3\",\n      description: \"Read 'Blue Light Special'\"\n    }, {\n      text: \"Notepad.exe\",\n      icon: \"\",\n      group: \"App\",\n      description: \"Launch a text editor\"\n    }, {\n      text: \"Pump up the jam\",\n      icon: \"\",\n      group: \"App\",\n      description: \"Launch audio application\"\n    }, {\n      text: \"Microsoft Access 97\",\n      icon: \"\",\n      group: \"App\",\n      description: \"Launch a spreadsheet application\"\n    }, {\n      text: \"Look at that\",\n      icon: \"\",\n      group: \"App\",\n      description: \"Open the image viewer\"\n    }, {\n      text: \"Pixel perfect\",\n      icon: \"\",\n      group: \"App\",\n      description: \"Open the pixel editor\"\n    }, {\n      text: \"Check yo' self\",\n      icon: \"\",\n      group: \"App\",\n      description: \"Check your achievement status\"\n    }, {\n      text: \"Save a file\",\n      icon: \"\",\n      group: \"OS\",\n      description: \"Write to the file system\"\n    }, {\n      text: \"Load a file\",\n      icon: \"\",\n      group: \"OS\",\n      description: \"Read from the file system\"\n    }, {\n      text: \"Execute code\",\n      icon: \"\",\n      group: \"OS\",\n      description: \"Some people like to live dangerously\"\n    }, {\n      text: \"Dismiss modal\",\n      icon: \"\",\n      group: \"OS\",\n      description: \"Dismiss a modal without even reading it\"\n    }, {\n      text: \"I AM ERROR\",\n      icon: \"\",\n      group: \"OS\",\n      description: \"Encountered a JavaScript error\"\n    }, {\n      text: \"Do you 'like' like me?\",\n      icon: \"\",\n      group: \"Social\",\n      description: \"Have fine taste\"\n    }, {\n      text: \"We value your input\",\n      icon: \"\",\n      group: \"Social\",\n      description: \"View feedback form\"\n    }, {\n      text: \"Enter the Chateau\",\n      icon: \"\",\n      group: \"Chateau\",\n      description: \"Enter the Chateau\"\n    }, {\n      text: \"Puttin' on the Ritz\",\n      icon: \"\",\n      group: \"Chateau\",\n      description: \"Upload custom avatar\"\n    }, {\n      text: \"Paint the town red\",\n      icon: \"\",\n      group: \"Chateau\",\n      description: \"Upload a custom background\"\n    }, {\n      text: \"Poutine on the Ritz\",\n      icon: \"\",\n      group: \"Chateau\",\n      description: \"Put poutine on a Ritz cracker\"\n    }, {\n      text: \"It's in the cloud\",\n      icon: \"\",\n      group: \"Chateau\",\n      description: \"Upload a file\"\n    }, {\n      text: \"Rawr\",\n      icon: \"\",\n      group: \"Contrasaurus\",\n      description: \"Played Contrasaurus\"\n    }\n  ];\n\n  restore = function() {\n    var storedAchieved, storedCheevos;\n    storedCheevos = [];\n    try {\n      storedCheevos = JSON.parse(localStorage.cheevos);\n    } catch (_error) {}\n    storedAchieved = {};\n    storedCheevos.forEach(function(_arg) {\n      var achieved, text;\n      achieved = _arg.achieved, text = _arg.text;\n      return storedAchieved[text] = achieved;\n    });\n    return achievementData.forEach(function(cheevo) {\n      var text;\n      text = cheevo.text;\n      if (storedAchieved[text]) {\n        return cheevo.achieved = true;\n      }\n    });\n  };\n\n  persist = function() {\n    return localStorage.cheevos = JSON.stringify(achievementData);\n  };\n\n  AchievementProgressPresenter = require(\"../presenters/achievement-group-progress\");\n\n  groupBy = function(xs, key) {\n    return xs.reduce(function(rv, x) {\n      var _name;\n      (rv[_name = x[key]] != null ? rv[_name] : rv[_name] = []).push(x);\n      return rv;\n    }, {});\n  };\n\n  module.exports = function(I, self) {\n    var updateStatus;\n    restore();\n    Object.assign(self, {\n      Achievement: {\n        groupData: Observable({}),\n        unlock: function(name) {\n          var opts;\n          opts = achievementData.find(function(_arg) {\n            var text;\n            text = _arg.text;\n            return text === name;\n          });\n          if (opts && !opts.achieved) {\n            opts.achieved = true;\n            persist();\n            updateStatus();\n            return Achievement.display(opts);\n          }\n        },\n        progressView: function() {\n          var content;\n          content = document.createElement(\"content\");\n          Observable(function() {\n            var data, elements;\n            data = self.Achievement.groupData();\n            elements = Object.keys(data).map(function(group) {\n              return AchievementProgressPresenter({\n                name: group,\n                achievements: data[group]\n              });\n            });\n            emptyElement(content);\n            return elements.forEach(function(element) {\n              return content.appendChild(element);\n            });\n          });\n          return content;\n        }\n      }\n    });\n    updateStatus = function() {\n      return self.Achievement.groupData(groupBy(achievementData, \"group\"));\n    };\n    updateStatus();\n    return self;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "system/associations": {
      "path": "system/associations",
      "content": "(function() {\n  var AudioBro, DSad, Filter, Markdown, Notepad, PixelEditor, Spreadsheet, TextEditor, openWith;\n\n  AudioBro = require(\"../apps/audio-bro\");\n\n  Filter = require(\"../apps/filter\");\n\n  Notepad = require(\"../apps/notepad\");\n\n  TextEditor = require(\"../apps/text-editor\");\n\n  Spreadsheet = require(\"../apps/spreadsheet\");\n\n  PixelEditor = require(\"../apps/pixel\");\n\n  Markdown = require(\"../apps/markdown\");\n\n  DSad = require(\"../apps/dungeon-of-sadness\");\n\n  openWith = function(App) {\n    return function(file) {\n      var app;\n      app = App();\n      app.loadFile(file.blob, file.path);\n      return document.body.appendChild(app.element);\n    };\n  };\n\n  module.exports = function(I, self) {\n    var handle, handlers;\n    handlers = [\n      {\n        name: \"Execute\",\n        filter: function(file) {\n          return file.type === \"application/javascript\" || file.path.match(/\\.js$/);\n        },\n        fn: function(file) {\n          return file.blob.readAsText().then(function(sourceProgram) {\n            return system.loadModule(sourceProgram, file.path);\n          });\n        }\n      }, {\n        name: \"Execute\",\n        filter: function(file) {\n          return file.path.match(/\\.coffee$/);\n        },\n        fn: function(file) {\n          return file.blob.readAsText().then(function(coffeeSource) {\n            var sourceProgram;\n            sourceProgram = CoffeeScript.compile(coffeeSource, {\n              bare: true\n            });\n            return system.loadModule(sourceProgram, file.path);\n          });\n        }\n      }, {\n        name: \"Markdown\",\n        filter: function(file) {\n          return file.path.match(/\\.md$/);\n        },\n        fn: openWith(Markdown)\n      }, {\n        name: \"Text Editor\",\n        filter: function(file) {\n          return file.type.match(/^text\\//) || file.type === \"application/javascript\";\n        },\n        fn: openWith(Notepad)\n      }, {\n        name: \"Spreadsheet\",\n        filter: function(file) {\n          return file.type === \"application/json\";\n        },\n        fn: openWith(Spreadsheet)\n      }, {\n        name: \"Image Viewer\",\n        filter: function(file) {\n          return file.type.match(/^image\\//);\n        },\n        fn: openWith(Filter)\n      }, {\n        name: \"Pixel Editor\",\n        filter: function(file) {\n          return file.type.match(/^image\\//);\n        },\n        fn: openWith(PixelEditor)\n      }, {\n        name: \"Audio Bro\",\n        filter: function(file) {\n          return file.type.match(/^audio\\//);\n        },\n        fn: openWith(AudioBro)\n      }, {\n        name: \"dsad.exe\",\n        filter: function(file) {\n          return file.path.match(/dsad\\.exe$/);\n        },\n        fn: function() {\n          var app;\n          app = DSad();\n          return document.body.appendChild(app.element);\n        }\n      }, {\n        name: \"zine1.exe\",\n        filter: function(file) {\n          return file.path.match(/zine1\\.exe$/);\n        },\n        fn: function() {\n          return require(\"../issues/2016-12\")();\n        }\n      }, {\n        name: \"zine2.exe\",\n        filter: function(file) {\n          return file.path.match(/zine2\\.exe$/);\n        },\n        fn: function() {\n          return require(\"../issues/2017-02\")();\n        }\n      }, {\n        name: \"zine3.exe\",\n        filter: function(file) {\n          return file.path.match(/zine3\\.exe$/);\n        },\n        fn: function() {\n          return require(\"../issues/2017-03\")();\n        }\n      }, {\n        name: \"feedback.exe\",\n        filter: function(file) {\n          return file.path.match(/feedback\\.exe$/);\n        },\n        fn: function() {\n          return require(\"../feedback\")();\n        }\n      }\n    ];\n    handle = function(file) {\n      var handler;\n      handler = handlers.find(function(_arg) {\n        var filter;\n        filter = _arg.filter;\n        return filter(file);\n      });\n      if (handler) {\n        return handler.fn(file);\n      } else {\n        throw new Error(\"No handler for files of type \" + file.type);\n      }\n    };\n    Object.assign(self, {\n      open: function(file) {\n        return handle(file);\n      },\n      openersFor: function(file) {\n        return handlers.filter(function(handler) {\n          return handler.filter(file);\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "system/module": {
      "path": "system/module",
      "content": "(function() {\n  var annotateSourceURL, compilers,\n    __slice = [].slice;\n\n  module.exports = function(I, self) {\n\n    /*\n    Load a module from a file in the file system.\n    \n    Additional properties such as a reference to the global object and some metadata\n    are exposed.\n    \n    Returns a promise that is fulfilled when the module assigns its exports, or\n    rejected on error.\n    \n    Caches modules so mutual includes don't get re-run per include root.\n    \n    Circular includes will never reslove\n     * TODO: Fail early on circular includes, challenging because of async\n    \n     * TODO: Succeed on files that don't assign module.exports\n    \n     * TODO: Require .coffee/arbitrary files\n     * images, blobs, html, json\n     */\n    var absolutizePath, fileSeparator, loadModule, normalizePath, rewriteRequires, _ref;\n    _ref = require(\"../util\"), absolutizePath = _ref.absolutizePath, fileSeparator = _ref.fileSeparator, normalizePath = _ref.normalizePath;\n    rewriteRequires = function(program) {\n      var id, namePrefix, requirePaths, requires, rewrittenProgram, tmpVars;\n      id = 0;\n      namePrefix = \"__req\";\n      requires = {};\n      rewrittenProgram = program.replace(/require\\(['\"]([^'\"]+)['\"]\\)/g, function(match, key) {\n        var tmpVar;\n        if (requires[key]) {\n          tmpVar = requires[key];\n        } else {\n          tmpVar = \"\" + namePrefix + id;\n          id += 1;\n          requires[key] = tmpVar;\n        }\n        return tmpVar;\n      });\n      tmpVars = Object.keys(requires).map(function(name) {\n        return requires[name];\n      });\n      requirePaths = Object.keys(requires);\n      requirePaths = requirePaths;\n      return \"system.include(\" + (JSON.stringify(requirePaths)) + \")\\n.then(function(__reqResults) {\\n(function(\" + (tmpVars.join(', ')) + \"){\\n\" + rewrittenProgram + \"\\n}).apply(this, __reqResults);\\n});\";\n    };\n    loadModule = function(content, path, state) {\n      return new Promise(function(resolve, reject) {\n        var args, context, dirname, exports, hasExports, localSystem, module, program, values;\n        program = annotateSourceURL(rewriteRequires(content), path);\n        dirname = path.split(fileSeparator).slice(0, -1).join(fileSeparator) || fileSeparator;\n        module = {\n          path: dirname\n        };\n        hasExports = program.match(/module\\.exports/);\n        exports = {};\n        Object.defineProperty(module, \"exports\", {\n          get: function() {\n            return exports;\n          },\n          set: function(newValue) {\n            exports = newValue;\n            return resolve(module);\n          }\n        });\n        localSystem = Object.assign({}, self, {\n          include: function(moduleIdentifiers) {\n            var relativeIdentifiers;\n            relativeIdentifiers = moduleIdentifiers.map(function(identifier) {\n              if (identifier.match(/^\\//)) {\n                return absolutizePath(\"/\", identifier);\n              } else {\n                return absolutizePath(dirname, identifier);\n              }\n            });\n            return self.include(relativeIdentifiers, state);\n          }\n        });\n        context = {\n          system: localSystem,\n          global: global,\n          module: module,\n          exports: module.exports,\n          __filename: path,\n          __dirname: dirname\n        };\n        args = Object.keys(context);\n        values = args.map(function(name) {\n          return context[name];\n        });\n        Promise.resolve().then(function() {\n          return Function.apply(null, __slice.call(args).concat([program])).apply(module, values);\n        })[\"catch\"](reject);\n        if (!hasExports) {\n          return setTimeout(function() {\n            return resolve(module);\n          }, 0);\n        }\n      });\n    };\n    return Object.assign(self, {\n      include: function(moduleIdentifiers, state) {\n        if (state == null) {\n          state = {};\n        }\n        if (state.cache == null) {\n          state.cache = {};\n        }\n        return Promise.all(moduleIdentifiers.map(function(absolutePath) {\n          var _base;\n          return (_base = state.cache)[absolutePath] != null ? _base[absolutePath] : _base[absolutePath] = self.loadProgram(absolutePath).then(function(sourceProgram) {\n            return loadModule(sourceProgram, absolutePath, state);\n          }).then(function(module) {\n            return module.exports;\n          });\n        }));\n      },\n      loadProgram: function(path, basePath) {\n        if (basePath == null) {\n          basePath = \"/\";\n        }\n        return self.fs.read(absolutizePath(basePath, path)).then(function(file) {\n          var compiler;\n          compiler = compilers.filter(function(_arg) {\n            var filter;\n            filter = _arg.filter;\n            return filter(file);\n          })[0];\n          if (compiler) {\n            return compiler.fn(file);\n          } else {\n            throw new Error(\"Could not find a compiler for file: \" + path);\n          }\n        });\n      },\n      loadModule: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        self.Achievement.unlock(\"Execute code\");\n        return loadModule.apply(null, args);\n      }\n    });\n  };\n\n  compilers = [\n    {\n      filter: function(_arg) {\n        var path;\n        path = _arg.path;\n        return path.match(/\\.js/);\n      },\n      fn: function(_arg) {\n        var blob;\n        blob = _arg.blob;\n        return blob.readAsText();\n      }\n    }, {\n      filter: function(_arg) {\n        var path;\n        path = _arg.path;\n        return path.match(/\\.coffee/);\n      },\n      fn: function(_arg) {\n        var blob;\n        blob = _arg.blob;\n        return blob.readAsText().then(function(coffeeSource) {\n          return CoffeeScript.compile(coffeeSource, {\n            bare: true\n          });\n        });\n      }\n    }, {\n      filter: function(_arg) {\n        var path;\n        path = _arg.path;\n        return path.match(/\\.jadelet/);\n      },\n      fn: function(_arg) {\n        var blob;\n        blob = _arg.blob;\n        return blob.readAsText().then(function(jadeletSource) {\n          return Hamlet.compile(jadeletSource, {\n            compiler: CoffeeScript,\n            mode: \"jade\",\n            runtime: \"Hamlet\"\n          });\n        });\n      }\n    }\n  ];\n\n  annotateSourceURL = function(program, path) {\n    return \"\" + program + \"\\n//# sourceURL=\" + path;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "system/template": {
      "path": "system/template",
      "content": "(function() {\n  module.exports = function(I, self) {\n    return self.extend({\n      compileTemplate: function(source, mode) {\n        var templateSource;\n        if (mode == null) {\n          mode = \"jade\";\n        }\n        templateSource = Hamlet.compile(source, {\n          compiler: CoffeeScript,\n          mode: mode,\n          runtime: \"Hamlet\",\n          exports: false\n        });\n        return Function(\"return \" + templateSource)();\n      }\n    });\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "templates/achievement-badge": {
      "path": "templates/achievement-badge",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"achievement-badge\", this, {\n      \"class\": [this[\"class\"]],\n      \"title\": this.description\n    }, function(__root) {\n      __root.buffer(this.icon);\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/achievement-progress": {
      "path": "templates/achievement-progress",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"achievement-progress\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"h2\", this, {}, function(__root) {\n        __root.buffer(this.name);\n      }));\n      __root.buffer(__root.element(\"progress\", this, {\n        \"value\": this.value\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"span\", this, {}, function(__root) {\n        __root.buffer(this.fraction);\n      }));\n      __root.buffer(__root.element(\"achievement-badges\", this, {}, function(__root) {\n        __root.buffer(this.badges);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/achievement": {
      "path": "templates/achievement",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"achievement\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"icon\", this, {}, function(__root) {\n        __root.buffer(this.icon);\n      }));\n      __root.buffer(__root.element(\"h2\", this, {}, function(__root) {\n        __root.buffer(this.title);\n      }));\n      __root.buffer(__root.element(\"p\", this, {}, function(__root) {\n        __root.buffer(this.text);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/chateau": {
      "path": "templates/chateau",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"chateau\", this, {}, function(__root) {\n      __root.buffer(this.canvas);\n      __root.buffer(__root.element(\"word-area\", this, {}, function(__root) {\n        __root.buffer(this.words);\n      }));\n      __root.buffer(__root.element(\"form\", this, {\n        \"submit\": this.submit\n      }, function(__root) {\n        __root.buffer(__root.element(\"input\", this, {}, function(__root) {}));\n        __root.buffer(__root.element(\"button\", this, {}, function(__root) {\n          __root.buffer(\"Speak\\n\");\n        }));\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/file": {
      "path": "templates/file",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"file\", this, {\n      \"dblclick\": this.dblclick,\n      \"contextmenu\": this.contextmenu,\n      \"type\": this.type\n    }, function(__root) {\n      __root.buffer(__root.element(\"icon\", this, {}, function(__root) {}));\n      __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n        __root.buffer(this.relativePath);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/folder": {
      "path": "templates/folder",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"folder\", this, {\n      \"dblclick\": this.dblclick,\n      \"contextmenu\": this.contextmenu\n    }, function(__root) {\n      __root.buffer(__root.element(\"icon\", this, {}, function(__root) {}));\n      __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n        __root.buffer(this.relativePath);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/input": {
      "path": "templates/input",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"input\", this, {\n      \"value\": this.value,\n      \"type\": this.type,\n      \"min\": this.min,\n      \"max\": this.max,\n      \"checked\": this.checked\n    }, function(__root) {}));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "test/system/module": {
      "path": "test/system/module",
      "content": "(function() {\n  var Associations, Model, SystemModule, makeSystemFS;\n\n  require(\"../../extensions\");\n\n  Model = require(\"model\");\n\n  Associations = require(\"../../system/associations\");\n\n  SystemModule = require(\"../../system/module\");\n\n  global.Hamlet = require(\"../../lib/hamlet\");\n\n  makeSystemFS = function(files) {\n    var model;\n    model = Model();\n    model.include(SystemModule, Associations);\n    model.fs = {\n      read: function(path) {\n        return Promise.resolve().then(function() {\n          var content;\n          content = files[path];\n          if (content == null) {\n            throw new Error(\"File not found: \" + path);\n          }\n          return {\n            path: path,\n            blob: new Blob([content])\n          };\n        });\n      }\n    };\n    return model;\n  };\n\n  describe(\"System Module\", function() {\n    it(\"should include modules in files async\", function() {\n      var model;\n      model = makeSystemFS({\n        \"/test.js\": \"module.exports = 'yo';\",\n        \"/root.js\": \"var test = require('./test.js');\\nvar test2 = require(\\\"./folder/nested.js\\\");\\nmodule.exports = test + \\\" 2 rad \\\" + test2;\",\n        \"/folder/nested.js\": \"module.exports = \\\"hella\\\";\",\n        \"/wat.js\": \"module.exports = \\\"wat\\\";\",\n        \"/rand.js\": \"module.exports = Math.random();\"\n      });\n      return model.include([\"/root.js\", \"/wat.js\", \"/rand.js\", \"/rand.js\"]).then(function(_arg) {\n        var r1, r2, root, wat;\n        root = _arg[0], wat = _arg[1], r1 = _arg[2], r2 = _arg[3];\n        console.log(root, wat, r1, r2);\n        assert.equal(r1, r2);\n        return assert.equal(root, 'yo 2 rad hella');\n      });\n    });\n    it(\"should throw an error when requiring a file that doesn't exist\", function(done) {\n      var model;\n      this.timeout(250);\n      model = makeSystemFS({\n        \"/a.js\": \"module.exports = require(\\\"./b.js\\\")\"\n      });\n      return model.include([\"/a.js\"])[\"catch\"](function(e) {\n        return done();\n      });\n    });\n    it(\"should wait forever when resolving circular requires\", function(done) {\n      var model;\n      model = makeSystemFS({\n        \"/a.js\": \"module.exports = require(\\\"./b.js\\\")\",\n        \"/b.js\": \"module.exports = require(\\\"./a.js\\\")\"\n      });\n      model.include([\"/a.js\"]).then(function(_arg) {\n        var a;\n        a = _arg[0];\n        return assert(false);\n      });\n      return setTimeout(function() {\n        return done();\n      }, 100);\n    });\n    it(\"should work even if the file doesn't assign to module.exports\", function() {\n      var model;\n      model = makeSystemFS({\n        \"/wat.js\": \"exports.yolo = \\\"wat\\\";\"\n      });\n      return model.include([\"/wat.js\"]).then(function(_arg) {\n        var wat;\n        wat = _arg[0];\n        return assert.equal(wat.yolo, \"wat\");\n      });\n    });\n    it(\"should work with relative paths in subfolders\", function() {\n      var model;\n      model = makeSystemFS({\n        \"/main.js\": \"module.exports = require(\\\"./folder/a.js\\\");\",\n        \"/folder/a.js\": \"module.exports = require(\\\"./b.js\\\");\",\n        \"/folder/b.js\": \"module.exports = \\\"b\\\";\"\n      });\n      return model.include([\"/main.js\"]).then(function(_arg) {\n        var main;\n        main = _arg[0];\n        return assert.equal(main, \"b\");\n      });\n    });\n    it(\"should work with absolute paths in subfolders\", function() {\n      var model;\n      model = makeSystemFS({\n        \"/main.js\": \"module.exports = require(\\\"./folder/a.js\\\");\",\n        \"/folder/a.js\": \"module.exports = require(\\\"/b.js\\\");\",\n        \"/b.js\": \"module.exports = \\\"b\\\";\"\n      });\n      return model.include([\"/main.js\"]).then(function(_arg) {\n        var main;\n        main = _arg[0];\n        return assert.equal(main, \"b\");\n      });\n    });\n    return it(\"should require .jadelet sources\", function() {\n      var model;\n      model = makeSystemFS({\n        \"/main.coffee\": \"template = require \\\"./button.jadelet\\\"\\n\\nmodule.exports =\\n  buttonTemplate: template\",\n        \"/button.jadelet\": \"button(@click)= @text\"\n      });\n      return model.include([\"/main.coffee\"]).then(function(_arg) {\n        var main;\n        main = _arg[0];\n        return assert(typeof main.buttonTemplate === \"function\");\n      });\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "util": {
      "path": "util",
      "content": "(function() {\n  var absolutizePath, fileSeparator, normalizePath;\n\n  fileSeparator = \"/\";\n\n  normalizePath = function(path) {\n    return path.replace(/\\/\\/+/, fileSeparator).replace(/\\/[^/]*\\/\\.\\./g, \"\").replace(/\\/\\.\\//g, fileSeparator);\n  };\n\n  absolutizePath = function(base, relativePath) {\n    return normalizePath(\"/\" + base + \"/\" + relativePath);\n  };\n\n  module.exports = {\n    emptyElement: function(element) {\n      var _results;\n      _results = [];\n      while (element.lastChild) {\n        _results.push(element.removeChild(element.lastChild));\n      }\n      return _results;\n    },\n    fileSeparator: fileSeparator,\n    normalizePath: normalizePath,\n    absolutizePath: absolutizePath,\n    parentElementOfType: function(tagname, element) {\n      tagname = tagname.toLowerCase();\n      if (element.nodeName.toLowerCase() === tagname) {\n        return element;\n      }\n      while (element = element.parentNode) {\n        if (element.nodeName.toLowerCase() === tagname) {\n          return element;\n        }\n      }\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/hamlet-runtime": {
      "path": "lib/hamlet-runtime",
      "content": "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.HamletRuntime = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  \"use strict\";\n  var Observable, Runtime, bindEvent, bindObservable, bufferTo, classes, createElement, empty, eventNames, get, id, isEvent, isFragment, makeElement, observeAttribute, observeAttributes, observeContent, specialBindings, valueBind, valueIndexOf;\n\n  Observable = require(\"o_0\");\n\n  eventNames = \"abort\\nblur\\nchange\\nclick\\ncontextmenu\\ndblclick\\ndrag\\ndragend\\ndragenter\\ndragexit\\ndragleave\\ndragover\\ndragstart\\ndrop\\nerror\\nfocus\\ninput\\nkeydown\\nkeypress\\nkeyup\\nload\\nmousedown\\nmousemove\\nmouseout\\nmouseover\\nmouseup\\nreset\\nresize\\nscroll\\nselect\\nsubmit\\ntouchcancel\\ntouchend\\ntouchenter\\ntouchleave\\ntouchmove\\ntouchstart\\nunload\".split(\"\\n\");\n\n  isEvent = function(name) {\n    return eventNames.indexOf(name) !== -1;\n  };\n\n  isFragment = function(node) {\n    return (node != null ? node.nodeType : void 0) === 11;\n  };\n\n  valueBind = function(element, value, context) {\n    Observable(function() {\n      var update;\n      value = Observable(value, context);\n      switch (element.nodeName) {\n        case \"SELECT\":\n          element.oninput = element.onchange = function() {\n            var optionValue, _ref, _value;\n            _ref = this.children[this.selectedIndex], optionValue = _ref.value, _value = _ref._value;\n            return value(_value || optionValue);\n          };\n          update = function(newValue) {\n            var options;\n            element._value = newValue;\n            if ((options = element._options)) {\n              if (newValue.value != null) {\n                return element.value = (typeof newValue.value === \"function\" ? newValue.value() : void 0) || newValue.value;\n              } else {\n                return element.selectedIndex = valueIndexOf(options, newValue);\n              }\n            } else {\n              return element.value = newValue;\n            }\n          };\n          return bindObservable(element, value, context, update);\n        default:\n          element.oninput = element.onchange = function() {\n            return value(element.value);\n          };\n          if (typeof element.attachEvent === \"function\") {\n            element.attachEvent(\"onkeydown\", function() {\n              return setTimeout(function() {\n                return value(element.value);\n              }, 0);\n            });\n          }\n          return bindObservable(element, value, context, function(newValue) {\n            if (element.value !== newValue) {\n              return element.value = newValue;\n            }\n          });\n      }\n    });\n  };\n\n  specialBindings = {\n    INPUT: {\n      checked: function(element, value, context) {\n        element.onchange = function() {\n          return typeof value === \"function\" ? value(element.checked) : void 0;\n        };\n        return bindObservable(element, value, context, function(newValue) {\n          return element.checked = newValue;\n        });\n      }\n    },\n    SELECT: {\n      options: function(element, values, context) {\n        var updateValues;\n        values = Observable(values, context);\n        updateValues = function(values) {\n          empty(element);\n          element._options = values;\n          return values.map(function(value, index) {\n            var option, optionName, optionValue;\n            option = createElement(\"option\");\n            option._value = value;\n            if (typeof value === \"object\") {\n              optionValue = (value != null ? value.value : void 0) || index;\n            } else {\n              optionValue = value.toString();\n            }\n            bindObservable(option, optionValue, value, function(newValue) {\n              return option.value = newValue;\n            });\n            optionName = (value != null ? value.name : void 0) || value;\n            bindObservable(option, optionName, value, function(newValue) {\n              return option.textContent = option.innerText = newValue;\n            });\n            element.appendChild(option);\n            if (value === element._value) {\n              element.selectedIndex = index;\n            }\n            return option;\n          });\n        };\n        return bindObservable(element, values, context, updateValues);\n      }\n    }\n  };\n\n  observeAttribute = function(element, context, name, value) {\n    var binding, nodeName, _ref;\n    nodeName = element.nodeName;\n    if (name === \"value\") {\n      valueBind(element, value);\n    } else if (binding = (_ref = specialBindings[nodeName]) != null ? _ref[name] : void 0) {\n      binding(element, value, context);\n    } else if (name.match(/^on/) && isEvent(name.substr(2))) {\n      bindEvent(element, name, value, context);\n    } else if (isEvent(name)) {\n      bindEvent(element, \"on\" + name, value, context);\n    } else {\n      bindObservable(element, value, context, function(newValue) {\n        if ((newValue != null) && newValue !== false) {\n          return element.setAttribute(name, newValue);\n        } else {\n          return element.removeAttribute(name);\n        }\n      });\n    }\n    return element;\n  };\n\n  observeAttributes = function(element, context, attributes) {\n    return Object.keys(attributes).forEach(function(name) {\n      var value;\n      value = attributes[name];\n      return observeAttribute(element, context, name, value);\n    });\n  };\n\n  bindObservable = function(element, value, context, update) {\n    var observable, observe, unobserve;\n    observable = Observable(value, context);\n    observe = function() {\n      observable.observe(update);\n      return update(observable());\n    };\n    unobserve = function() {\n      return observable.stopObserving(update);\n    };\n    observe();\n    return element;\n  };\n\n  bindEvent = function(element, name, fn, context) {\n    return element[name] = function() {\n      return fn.apply(context, arguments);\n    };\n  };\n\n  id = function(element, context, sources) {\n    var lastId, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(newId) {\n      return element.id = newId;\n    };\n    lastId = function() {\n      return value.last();\n    };\n    return bindObservable(element, lastId, context, update);\n  };\n\n  classes = function(element, context, sources) {\n    var classNames, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(classNames) {\n      return element.className = classNames;\n    };\n    classNames = function() {\n      return value.join(\" \");\n    };\n    return bindObservable(element, classNames, context, update);\n  };\n\n  createElement = function(name) {\n    return document.createElement(name);\n  };\n\n  observeContent = function(element, context, contentFn) {\n    var append, contents, update;\n    contents = [];\n    contentFn.call(context, {\n      buffer: bufferTo(context, contents),\n      element: makeElement\n    });\n    append = function(item) {\n      if (item == null) {\n\n      } else if (typeof item === \"string\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"number\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"boolean\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item.each === \"function\") {\n        return item.each(append);\n      } else if (typeof item.forEach === \"function\") {\n        return item.forEach(append);\n      } else {\n        return element.appendChild(item);\n      }\n    };\n    update = function(contents) {\n      empty(element);\n      return contents.forEach(append);\n    };\n    return update(contents);\n  };\n\n  bufferTo = function(context, collection) {\n    return function(content) {\n      if (typeof content === 'function') {\n        content = Observable(content, context);\n      }\n      collection.push(content);\n      return content;\n    };\n  };\n\n  makeElement = function(name, context, attributes, fn) {\n    var element;\n    if (attributes == null) {\n      attributes = {};\n    }\n    element = createElement(name);\n    Observable(function() {\n      if (attributes.id != null) {\n        id(element, context, attributes.id);\n        return delete attributes.id;\n      }\n    });\n    Observable(function() {\n      if (attributes[\"class\"] != null) {\n        classes(element, context, attributes[\"class\"]);\n        return delete attributes[\"class\"];\n      }\n    });\n    Observable(function() {\n      return observeAttributes(element, context, attributes);\n    }, context);\n    if (element.nodeName !== \"SELECT\") {\n      Observable(function() {\n        return observeContent(element, context, fn);\n      }, context);\n    }\n    return element;\n  };\n\n  Runtime = function(context) {\n    var self;\n    self = {\n      buffer: function(content) {\n        if (self.root) {\n          throw \"Cannot have multiple root elements\";\n        }\n        return self.root = content;\n      },\n      element: makeElement,\n      filter: function(name, content) {}\n    };\n    return self;\n  };\n\n  Runtime.VERSION = require(\"../package.json\").version;\n\n  Runtime.Observable = Observable;\n\n  module.exports = Runtime;\n\n  empty = function(node) {\n    var child, _results;\n    _results = [];\n    while (child = node.firstChild) {\n      _results.push(node.removeChild(child));\n    }\n    return _results;\n  };\n\n  valueIndexOf = function(options, value) {\n    if (typeof value === \"object\") {\n      return options.indexOf(value);\n    } else {\n      return options.map(function(option) {\n        return option.toString();\n      }).indexOf(value.toString());\n    }\n  };\n\n  get = function(x) {\n    if (typeof x === 'function') {\n      return x();\n    } else {\n      return x;\n    }\n  };\n\n}).call(this);\n\n},{\"../package.json\":3,\"o_0\":2}],2:[function(require,module,exports){\n(function (global){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],3:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"hamlet.coffee\",\n  \"version\": \"0.7.6\",\n  \"description\": \"Truly amazing templating!\",\n  \"devDependencies\": {\n    \"browserify\": \"^12.0.1\",\n    \"coffee-script\": \"~1.7.1\",\n    \"jsdom\": \"^7.2.0\",\n    \"mocha\": \"^2.3.3\"\n  },\n  \"dependencies\": {\n    \"hamlet-compiler\": \"0.7.0\",\n    \"o_0\": \"0.3.8\"\n  },\n  \"homepage\": \"hamlet.coffee\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/dr-coffee-labs/hamlet.git\"\n  },\n  \"scripts\": {\n    \"prepublish\": \"script/prepublish\",\n    \"test\": \"script/test\"\n  },\n  \"files\": [\n    \"dist/\"\n  ],\n  \"main\": \"dist/runtime.js\"\n}\n\n},{}]},{},[1])(1)\n});",
      "type": "blob"
    }
  },
  "progenitor": {
    "url": "https://danielx.net/editor/"
  },
  "config": {
    "dependencies": {
      "ajax": "distri/ajax:master",
      "analytics": "distri/google-analytics:master",
      "bindable": "distri/bindable:master",
      "model": "distri/model:master",
      "postmaster": "distri/postmaster:v0.5.0",
      "ui": "STRd6/ui:master"
    },
    "remoteDependencies": [
      "https://cdnjs.cloudflare.com/ajax/libs/dexie/2.0.0-beta.7/dexie.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ace.js",
      "https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ext-language_tools.js",
      "https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.7.1/coffee-script.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.6/marked.min.js"
    ]
  },
  "entryPoint": "main",
  "remoteDependencies": [
    "https://cdnjs.cloudflare.com/ajax/libs/dexie/2.0.0-beta.7/dexie.min.js",
    "https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ace.js",
    "https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ext-language_tools.js",
    "https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.7.1/coffee-script.min.js",
    "https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.6/marked.min.js"
  ],
  "repository": {
    "branch": "master",
    "default_branch": "master",
    "full_name": "STRd6/zine",
    "homepage": null,
    "description": "DIY E-Zine and Operating System",
    "html_url": "https://github.com/STRd6/zine",
    "url": "https://api.github.com/repos/STRd6/zine",
    "publishBranch": "gh-pages"
  },
  "dependencies": {
    "ajax": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
          "mode": "100644",
          "type": "blob"
        },
        "README.md": {
          "path": "README.md",
          "content": "# ajax\n\nA Promise returning wrapper for XMLHttpRequest\n\nThis aims to be a very small and very direct wrapper for XMLHttpRequest. We\nreturn a native promise and configure the requets via an options object.\n\n\n",
          "mode": "100644",
          "type": "blob"
        },
        "main.coffee": {
          "path": "main.coffee",
          "content": "require \"./shims\"\n\nmodule.exports = ->\n  ajax = (options={}) ->\n    {data, headers, method, overrideMimeType, password, url, responseType, timeout, user, withCredentials} = options\n    data ?= \"\"\n    method ?= \"GET\"\n    password ?= \"\"\n    responseType ?= \"\"\n    timeout ?= 0\n    user ?= \"\"\n    withCredentials ?= false\n\n    new ProgressPromise (resolve, reject, progress) ->\n      xhr = new XMLHttpRequest()\n      xhr.open(method, url, true, user, password)\n      xhr.responseType = responseType\n      xhr.timeout = timeout\n      xhr.withCredentialls = withCredentials\n\n      if headers\n        Object.keys(headers).forEach (header) ->\n          value = headers[header]\n          xhr.setRequestHeader header, value\n\n      if overrideMimeType\n        xhr.overrideMimeType overrideMimeType\n\n      xhr.onload = (e) ->\n        if (200 <= this.status < 300) or this.status is 304\n          resolve this.response\n          complete e, xhr, options\n        else\n          reject xhr\n          complete e, xhr, options\n\n      xhr.onerror = (e) ->\n        reject xhr\n        complete e, xhr, options\n\n      xhr.onprogress = progress\n\n      xhr.send(data)\n\n  complete = (args...) ->\n    completeHandlers.forEach (handler) ->\n      handler args...\n\n  configure = (optionDefaults) ->\n    (url, options={}) ->\n      if typeof url is \"object\"\n        options = url\n      else\n        options.url = url\n\n      defaults options, optionDefaults\n\n      ajax(options)\n\n  completeHandlers = []\n\n  Object.assign ajax,\n    ajax: configure {}\n    complete: (handler) ->\n      completeHandlers.push handler\n\n    getJSON: configure\n      responseType: \"json\"\n\n    getBlob: configure\n      responseType: \"blob\"\n\ndefaults = (target, objects...) ->\n  for object in objects\n    for name of object\n      unless target.hasOwnProperty(name)\n        target[name] = object[name]\n\n  return target\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "version: \"0.1.5-pre.0\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "shims.coffee": {
          "path": "shims.coffee",
          "content": "# Extend promises with `finally`\n# From: https://github.com/domenic/promises-unwrapping/issues/18\nPromise.prototype.finally ?= (callback) ->\n  # We dont invoke the callback in here,\n  # because we want then() to handle its exceptions\n  this.then(\n    # Callback fulfills: pass on predecessor settlement\n    # Callback rejects: pass on rejection (=omit 2nd arg.)\n    (value) ->\n      Promise.resolve(callback())\n      .then -> return value\n    (reason) ->\n      Promise.resolve(callback())\n      .then -> throw reason\n  )\n\n# HACK: I really would prefer not to modify the native Promise prototype, but I\n# know no other way...\n\nPromise.prototype._notify ?= (event) ->\n  @_progressHandlers.forEach (handler) ->\n    try\n      handler(event)\n\nPromise.prototype.progress ?= (handler) ->\n  @_progressHandlers ?= []\n  @_progressHandlers.push handler\n\n  return this\n\nglobal.ProgressPromise = (fn) ->\n  p = new Promise (resolve, reject) ->\n    notify = ->\n      p._progressHandlers?.forEach (handler) ->\n        try\n          handler(event)\n\n    fn(resolve, reject, notify)\n\n  p.then = (onFulfilled, onRejected) ->\n    result = Promise.prototype.then.call(p, onFulfilled, onRejected)\n    # Pass progress through\n    p.progress result._notify.bind(result)\n\n    return result\n\n  return p\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/test.coffee": {
          "path": "test/test.coffee",
          "content": "Ajax = require \"../main\"\n\ndescribe \"Ajax\", ->\n  it \"should provide progress\", (done) ->\n    ajax = Ajax()\n\n    ajax\n      url: \"https://api.github.com/users\"\n      responseType: \"json\"\n    .progress (e) ->\n      console.log e\n    .then (data) ->\n      assert data[0].id is 1\n      done()\n\n  it \"should getJSON\", (done) ->\n    ajax = Ajax()\n\n    ajax\n      url: \"https://api.github.com/users\"\n      responseType: \"json\"\n    .then (data) ->\n      assert data[0].id is 1\n      assert data[0].login is \"mojombo\"\n\n      done()\n\n  it \"should have complete handlers\", (done) ->\n    ajax = Ajax()\n\n    ajax.complete (e, xhr, options) ->\n      done()\n\n    ajax.getJSON(\"https://api.github.com/users\")\n\n\n  it \"should work with options only\", (done) ->\n    ajax = Ajax()\n\n    ajax.getJSON(url: \"https://api.github.com/users\")\n    .then (data) ->\n      assert data[0].id is 1\n      assert data[0].login is \"mojombo\"\n\n      done()\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "main": {
          "path": "main",
          "content": "(function() {\n  var defaults,\n    __slice = [].slice;\n\n  require(\"./shims\");\n\n  module.exports = function() {\n    var ajax, complete, completeHandlers, configure;\n    ajax = function(options) {\n      var data, headers, method, overrideMimeType, password, responseType, timeout, url, user, withCredentials;\n      if (options == null) {\n        options = {};\n      }\n      data = options.data, headers = options.headers, method = options.method, overrideMimeType = options.overrideMimeType, password = options.password, url = options.url, responseType = options.responseType, timeout = options.timeout, user = options.user, withCredentials = options.withCredentials;\n      if (data == null) {\n        data = \"\";\n      }\n      if (method == null) {\n        method = \"GET\";\n      }\n      if (password == null) {\n        password = \"\";\n      }\n      if (responseType == null) {\n        responseType = \"\";\n      }\n      if (timeout == null) {\n        timeout = 0;\n      }\n      if (user == null) {\n        user = \"\";\n      }\n      if (withCredentials == null) {\n        withCredentials = false;\n      }\n      return new ProgressPromise(function(resolve, reject, progress) {\n        var xhr;\n        xhr = new XMLHttpRequest();\n        xhr.open(method, url, true, user, password);\n        xhr.responseType = responseType;\n        xhr.timeout = timeout;\n        xhr.withCredentialls = withCredentials;\n        if (headers) {\n          Object.keys(headers).forEach(function(header) {\n            var value;\n            value = headers[header];\n            return xhr.setRequestHeader(header, value);\n          });\n        }\n        if (overrideMimeType) {\n          xhr.overrideMimeType(overrideMimeType);\n        }\n        xhr.onload = function(e) {\n          var _ref;\n          if (((200 <= (_ref = this.status) && _ref < 300)) || this.status === 304) {\n            resolve(this.response);\n            return complete(e, xhr, options);\n          } else {\n            reject(xhr);\n            return complete(e, xhr, options);\n          }\n        };\n        xhr.onerror = function(e) {\n          reject(xhr);\n          return complete(e, xhr, options);\n        };\n        xhr.onprogress = progress;\n        return xhr.send(data);\n      });\n    };\n    complete = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return completeHandlers.forEach(function(handler) {\n        return handler.apply(null, args);\n      });\n    };\n    configure = function(optionDefaults) {\n      return function(url, options) {\n        if (options == null) {\n          options = {};\n        }\n        if (typeof url === \"object\") {\n          options = url;\n        } else {\n          options.url = url;\n        }\n        defaults(options, optionDefaults);\n        return ajax(options);\n      };\n    };\n    completeHandlers = [];\n    return Object.assign(ajax, {\n      ajax: configure({}),\n      complete: function(handler) {\n        return completeHandlers.push(handler);\n      },\n      getJSON: configure({\n        responseType: \"json\"\n      }),\n      getBlob: configure({\n        responseType: \"blob\"\n      })\n    });\n  };\n\n  defaults = function() {\n    var name, object, objects, target, _i, _len;\n    target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    for (_i = 0, _len = objects.length; _i < _len; _i++) {\n      object = objects[_i];\n      for (name in object) {\n        if (!target.hasOwnProperty(name)) {\n          target[name] = object[name];\n        }\n      }\n    }\n    return target;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"version\":\"0.1.5-pre.0\"};",
          "type": "blob"
        },
        "shims": {
          "path": "shims",
          "content": "(function() {\n  var _base, _base1, _base2;\n\n  if ((_base = Promise.prototype)[\"finally\"] == null) {\n    _base[\"finally\"] = function(callback) {\n      return this.then(function(value) {\n        return Promise.resolve(callback()).then(function() {\n          return value;\n        });\n      }, function(reason) {\n        return Promise.resolve(callback()).then(function() {\n          throw reason;\n        });\n      });\n    };\n  }\n\n  if ((_base1 = Promise.prototype)._notify == null) {\n    _base1._notify = function(event) {\n      return this._progressHandlers.forEach(function(handler) {\n        try {\n          return handler(event);\n        } catch (_error) {}\n      });\n    };\n  }\n\n  if ((_base2 = Promise.prototype).progress == null) {\n    _base2.progress = function(handler) {\n      if (this._progressHandlers == null) {\n        this._progressHandlers = [];\n      }\n      this._progressHandlers.push(handler);\n      return this;\n    };\n  }\n\n  global.ProgressPromise = function(fn) {\n    var p;\n    p = new Promise(function(resolve, reject) {\n      var notify;\n      notify = function() {\n        var _ref;\n        return (_ref = p._progressHandlers) != null ? _ref.forEach(function(handler) {\n          try {\n            return handler(event);\n          } catch (_error) {}\n        }) : void 0;\n      };\n      return fn(resolve, reject, notify);\n    });\n    p.then = function(onFulfilled, onRejected) {\n      var result;\n      result = Promise.prototype.then.call(p, onFulfilled, onRejected);\n      p.progress(result._notify.bind(result));\n      return result;\n    };\n    return p;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "test/test": {
          "path": "test/test",
          "content": "(function() {\n  var Ajax;\n\n  Ajax = require(\"../main\");\n\n  describe(\"Ajax\", function() {\n    it(\"should provide progress\", function(done) {\n      var ajax;\n      ajax = Ajax();\n      return ajax({\n        url: \"https://api.github.com/users\",\n        responseType: \"json\"\n      }).progress(function(e) {\n        return console.log(e);\n      }).then(function(data) {\n        assert(data[0].id === 1);\n        return done();\n      });\n    });\n    it(\"should getJSON\", function(done) {\n      var ajax;\n      ajax = Ajax();\n      return ajax({\n        url: \"https://api.github.com/users\",\n        responseType: \"json\"\n      }).then(function(data) {\n        assert(data[0].id === 1);\n        assert(data[0].login === \"mojombo\");\n        return done();\n      });\n    });\n    it(\"should have complete handlers\", function(done) {\n      var ajax;\n      ajax = Ajax();\n      ajax.complete(function(e, xhr, options) {\n        return done();\n      });\n      return ajax.getJSON(\"https://api.github.com/users\");\n    });\n    return it(\"should work with options only\", function(done) {\n      var ajax;\n      ajax = Ajax();\n      return ajax.getJSON({\n        url: \"https://api.github.com/users\"\n      }).then(function(data) {\n        assert(data[0].id === 1);\n        assert(data[0].login === \"mojombo\");\n        return done();\n      });\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "https://danielx.net/editor/"
      },
      "config": {
        "version": "0.1.5-pre.0"
      },
      "version": "0.1.5-pre.0",
      "entryPoint": "main",
      "repository": {
        "branch": "master",
        "default_branch": "master",
        "full_name": "distri/ajax",
        "homepage": null,
        "description": "Promise returning Ajax lib",
        "html_url": "https://github.com/distri/ajax",
        "url": "https://api.github.com/repos/distri/ajax",
        "publishBranch": "gh-pages"
      },
      "dependencies": {}
    },
    "analytics": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
          "mode": "100644",
          "type": "blob"
        },
        "README.md": {
          "path": "README.md",
          "content": "google-analytics\n================\n\nGoogle analytics for distri apps\n",
          "mode": "100644",
          "type": "blob"
        },
        "lib/analytics.js": {
          "path": "lib/analytics.js",
          "content": "(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n",
          "mode": "100644",
          "type": "blob"
        },
        "main.coffee": {
          "path": "main.coffee",
          "content": "module.exports =\n  init: (id) ->\n    require \"./lib/analytics\"\n\n    global.ga('create', id, 'auto')\n    global.ga('send', 'pageview')\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "version: \"0.1.2\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/main.coffee": {
          "path": "test/main.coffee",
          "content": "mocha.globals(\"ga\")\n\ndescribe \"analytics\", ->\n  it \"should put analytics on the page\", ->\n    GA = require \"../main\"\n\n    GA.init(\"UA-XXXX-Y\")\n\n  it \"should be a chill bro\", ->\n    ga(\"send\", \"duder\")\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "lib/analytics": {
          "path": "lib/analytics",
          "content": "(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n",
          "type": "blob"
        },
        "main": {
          "path": "main",
          "content": "(function() {\n  module.exports = {\n    init: function(id) {\n      require(\"./lib/analytics\");\n      global.ga('create', id, 'auto');\n      return global.ga('send', 'pageview');\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"version\":\"0.1.2\"};",
          "type": "blob"
        },
        "test/main": {
          "path": "test/main",
          "content": "(function() {\n  mocha.globals(\"ga\");\n\n  describe(\"analytics\", function() {\n    it(\"should put analytics on the page\", function() {\n      var GA;\n      GA = require(\"../main\");\n      return GA.init(\"UA-XXXX-Y\");\n    });\n    return it(\"should be a chill bro\", function() {\n      return ga(\"send\", \"duder\");\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "https://danielx.net/editor/"
      },
      "version": "0.1.2",
      "entryPoint": "main",
      "repository": {
        "branch": "master",
        "default_branch": "master",
        "full_name": "distri/google-analytics",
        "homepage": null,
        "description": "Google analytics for distri apps",
        "html_url": "https://github.com/distri/google-analytics",
        "url": "https://api.github.com/repos/distri/google-analytics",
        "publishBranch": "gh-pages"
      },
      "dependencies": {}
    },
    "bindable": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
          "mode": "100644",
          "type": "blob"
        },
        "README.coffee.md": {
          "path": "README.coffee.md",
          "content": "Bindable\n========\n\nAdd event binding to objects.\n\n>     bindable = Bindable()\n>     bindable.on \"greet\", ->\n>       console.log \"yo!\"\n>     bindable.trigger \"greet\"\n>     #=> \"yo!\" is printed to log\n\nUse as a mixin.\n\n>    self.include Bindable\n\n    module.exports = (I={}, self={}) ->\n      eventCallbacks = {}\n\nAdds a function as an event listener.\n\nThis will call `coolEventHandler` after `yourObject.trigger \"someCustomEvent\"`\nis called.\n\n>     yourObject.on \"someCustomEvent\", coolEventHandler\n\nHandlers can be attached to namespaces as well. The namespaces are only used\nfor finer control of targeting event removal. For example if you are making a\ncustom drawing system you could unbind `\".Drawable\"` events and add your own.\n\n>     yourObject.on \"\"\n\n      self.on = (namespacedEvent, callback) ->\n        [event, namespace] = namespacedEvent.split(\".\")\n\n        # HACK: Here we annotate the callback function with namespace metadata\n        # This will probably lead to some strange edge cases, but should work fine\n        # for simple cases.\n        if namespace\n          callback.__PIXIE ||= {}\n          callback.__PIXIE[namespace] = true\n\n        eventCallbacks[event] ||= []\n        eventCallbacks[event].push(callback)\n\n        return self\n\nRemoves a specific event listener, or all event listeners if\nno specific listener is given.\n\nRemoves the handler coolEventHandler from the event `\"someCustomEvent\"` while\nleaving the other events intact.\n\n>     yourObject.off \"someCustomEvent\", coolEventHandler\n\nRemoves all handlers attached to `\"anotherCustomEvent\"`\n\n>     yourObject.off \"anotherCustomEvent\"\n\nRemove all handlers from the `\".Drawable\" namespace`\n\n>     yourObject.off \".Drawable\"\n\n      self.off = (namespacedEvent, callback) ->\n        [event, namespace] = namespacedEvent.split(\".\")\n\n        if event\n          eventCallbacks[event] ||= []\n\n          if namespace\n            # Select only the callbacks that do not have this namespace metadata\n            eventCallbacks[event] = eventCallbacks.filter (callback) ->\n              !callback.__PIXIE?[namespace]?\n\n          else\n            if callback\n              remove eventCallbacks[event], callback\n            else\n              eventCallbacks[event] = []\n        else if namespace\n          # No event given\n          # Select only the callbacks that do not have this namespace metadata\n          # for any events bound\n          for key, callbacks of eventCallbacks\n            eventCallbacks[key] = callbacks.filter (callback) ->\n              !callback.__PIXIE?[namespace]?\n\n        return self\n\nCalls all listeners attached to the specified event.\n\n>     # calls each event handler bound to \"someCustomEvent\"\n>     yourObject.trigger \"someCustomEvent\"\n\nAdditional parameters can be passed to the handlers.\n\n>     yourObject.trigger \"someEvent\", \"hello\", \"anotherParameter\"\n\n      self.trigger = (event, parameters...) ->\n        callbacks = eventCallbacks[event]\n\n        if callbacks\n          callbacks.forEach (callback) ->\n            callback.apply(self, parameters)\n\n        return self\n\n      return self\n\nHelpers\n-------\n\nRemove a value from an array.\n\n    remove = (array, value) ->\n      index = array.indexOf(value)\n\n      if index >= 0\n        array.splice(index, 1)[0]\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "entryPoint: \"README\"\nversion: \"0.2.0\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/bindable.coffee": {
          "path": "test/bindable.coffee",
          "content": "test = it\nok = assert\nequal = assert.equal\n\nBindable = require \"../README\"\n\ndescribe \"Bindable\", ->\n\n  test \"#bind and #trigger\", ->\n    o = Bindable()\n\n    o.on(\"test\", -> ok true)\n\n    o.trigger(\"test\")\n\n  test \"Multiple bindings\", ->\n    o = Bindable()\n\n    o.on(\"test\", -> ok true)\n    o.on(\"test\", -> ok true)\n\n    o.trigger(\"test\")\n\n  test \"#trigger arguments\", ->\n    o = Bindable()\n\n    param1 = \"the message\"\n    param2 = 3\n\n    o.on \"test\", (p1, p2) ->\n      equal(p1, param1)\n      equal(p2, param2)\n\n    o.trigger \"test\", param1, param2\n\n  test \"#unbind\", ->\n    o = Bindable()\n\n    callback = ->\n      ok false\n\n    o.on \"test\", callback\n    # Unbind specific event\n    o.off \"test\", callback\n    o.trigger \"test\"\n\n    o.on \"test\", callback\n    # Unbind all events\n    o.off \"test\"\n    o.trigger \"test\"\n\n  test \"#trigger namespace\", ->\n    o = Bindable()\n    o.on \"test.TestNamespace\", ->\n      ok true\n\n    o.trigger \"test\"\n\n    o.off \".TestNamespace\"\n    o.trigger \"test\"\n\n  test \"#unbind namespaced\", ->\n    o = Bindable()\n\n    o.on \"test.TestNamespace\", ->\n      ok true\n\n    o.trigger \"test\"\n\n    o.off \".TestNamespace\", ->\n    o.trigger \"test\"\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "README": {
          "path": "README",
          "content": "(function() {\n  var remove,\n    __slice = [].slice;\n\n  module.exports = function(I, self) {\n    var eventCallbacks;\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = {};\n    }\n    eventCallbacks = {};\n    self.on = function(namespacedEvent, callback) {\n      var event, namespace, _ref;\n      _ref = namespacedEvent.split(\".\"), event = _ref[0], namespace = _ref[1];\n      if (namespace) {\n        callback.__PIXIE || (callback.__PIXIE = {});\n        callback.__PIXIE[namespace] = true;\n      }\n      eventCallbacks[event] || (eventCallbacks[event] = []);\n      eventCallbacks[event].push(callback);\n      return self;\n    };\n    self.off = function(namespacedEvent, callback) {\n      var callbacks, event, key, namespace, _ref;\n      _ref = namespacedEvent.split(\".\"), event = _ref[0], namespace = _ref[1];\n      if (event) {\n        eventCallbacks[event] || (eventCallbacks[event] = []);\n        if (namespace) {\n          eventCallbacks[event] = eventCallbacks.filter(function(callback) {\n            var _ref1;\n            return ((_ref1 = callback.__PIXIE) != null ? _ref1[namespace] : void 0) == null;\n          });\n        } else {\n          if (callback) {\n            remove(eventCallbacks[event], callback);\n          } else {\n            eventCallbacks[event] = [];\n          }\n        }\n      } else if (namespace) {\n        for (key in eventCallbacks) {\n          callbacks = eventCallbacks[key];\n          eventCallbacks[key] = callbacks.filter(function(callback) {\n            var _ref1;\n            return ((_ref1 = callback.__PIXIE) != null ? _ref1[namespace] : void 0) == null;\n          });\n        }\n      }\n      return self;\n    };\n    self.trigger = function() {\n      var callbacks, event, parameters;\n      event = arguments[0], parameters = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      callbacks = eventCallbacks[event];\n      if (callbacks) {\n        callbacks.forEach(function(callback) {\n          return callback.apply(self, parameters);\n        });\n      }\n      return self;\n    };\n    return self;\n  };\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"entryPoint\":\"README\",\"version\":\"0.2.0\"};",
          "type": "blob"
        },
        "test/bindable": {
          "path": "test/bindable",
          "content": "(function() {\n  var Bindable, equal, ok, test;\n\n  test = it;\n\n  ok = assert;\n\n  equal = assert.equal;\n\n  Bindable = require(\"../README\");\n\n  describe(\"Bindable\", function() {\n    test(\"#bind and #trigger\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test\", function() {\n        return ok(true);\n      });\n      return o.trigger(\"test\");\n    });\n    test(\"Multiple bindings\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test\", function() {\n        return ok(true);\n      });\n      o.on(\"test\", function() {\n        return ok(true);\n      });\n      return o.trigger(\"test\");\n    });\n    test(\"#trigger arguments\", function() {\n      var o, param1, param2;\n      o = Bindable();\n      param1 = \"the message\";\n      param2 = 3;\n      o.on(\"test\", function(p1, p2) {\n        equal(p1, param1);\n        return equal(p2, param2);\n      });\n      return o.trigger(\"test\", param1, param2);\n    });\n    test(\"#unbind\", function() {\n      var callback, o;\n      o = Bindable();\n      callback = function() {\n        return ok(false);\n      };\n      o.on(\"test\", callback);\n      o.off(\"test\", callback);\n      o.trigger(\"test\");\n      o.on(\"test\", callback);\n      o.off(\"test\");\n      return o.trigger(\"test\");\n    });\n    test(\"#trigger namespace\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test.TestNamespace\", function() {\n        return ok(true);\n      });\n      o.trigger(\"test\");\n      o.off(\".TestNamespace\");\n      return o.trigger(\"test\");\n    });\n    return test(\"#unbind namespaced\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test.TestNamespace\", function() {\n        return ok(true);\n      });\n      o.trigger(\"test\");\n      o.off(\".TestNamespace\", function() {});\n      return o.trigger(\"test\");\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "https://danielx.net/editor/"
      },
      "version": "0.2.0",
      "entryPoint": "README",
      "repository": {
        "branch": "master",
        "default_branch": "master",
        "full_name": "distri/bindable",
        "homepage": null,
        "description": "Event binding",
        "html_url": "https://github.com/distri/bindable",
        "url": "https://api.github.com/repos/distri/bindable",
        "publishBranch": "gh-pages"
      },
      "dependencies": {}
    },
    "model": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
          "mode": "100644",
          "type": "blob"
        },
        "README.md": {
          "path": "README.md",
          "content": "Model\n=====\n\nThe `Model` module provides helper methods to compose nested data models.\n\nModels uses [Observable](/observable/docs) to keep the internal data in sync.\n",
          "mode": "100644",
          "type": "blob"
        },
        "core.coffee.md": {
          "path": "core.coffee.md",
          "content": "Core\n====\n\nThe Core module is used to add extended functionality to objects without\nextending `Object.prototype` directly.\n\n    Core = (I={}, self={}) ->\n      Object.assign self,\n\nExternal access to instance variables. Use of this property should be avoided\nin general, but can come in handy from time to time.\n\n>     #! example\n>     I =\n>       r: 255\n>       g: 0\n>       b: 100\n>\n>     myObject = Core(I)\n>\n>     [myObject.I.r, myObject.I.g, myObject.I.b]\n\n        I: I\n\nGenerates a public jQuery style getter / setter method for each `String` argument.\n\n>     #! example\n>     myObject = Core\n>       r: 255\n>       g: 0\n>       b: 100\n>\n>     myObject.attrAccessor \"r\", \"g\", \"b\"\n>\n>     myObject.r(254)\n\n        attrAccessor: (attrNames...) ->\n          attrNames.forEach (attrName) ->\n            self[attrName] = (newValue) ->\n              if arguments.length > 0\n                I[attrName] = newValue\n\n                return self\n              else\n                I[attrName]\n\n          return self\n\nGenerates a public jQuery style getter method for each String argument.\n\n>     #! example\n>     myObject = Core\n>       r: 255\n>       g: 0\n>       b: 100\n>\n>     myObject.attrReader \"r\", \"g\", \"b\"\n>\n>     [myObject.r(), myObject.g(), myObject.b()]\n\n        attrReader: (attrNames...) ->\n          attrNames.forEach (attrName) ->\n            self[attrName] = ->\n              I[attrName]\n\n          return self\n\nExtends this object with methods from the passed in object. A shortcut for Object.extend(self, methods)\n\n>     I =\n>       x: 30\n>       y: 40\n>       maxSpeed: 5\n>\n>     # we are using extend to give player\n>     # additional methods that Core doesn't have\n>     player = Core(I).extend\n>       increaseSpeed: ->\n>         I.maxSpeed += 1\n>\n>     player.increaseSpeed()\n\n        extend: (objects...) ->\n          Object.assign self, objects...\n\nIncludes a module in this object. A module is a constructor that takes two parameters, `I` and `self`\n\n>     myObject = Core()\n>     myObject.include(Bindable)\n\n>     # now you can bind handlers to functions\n>     myObject.bind \"someEvent\", ->\n>       alert(\"wow. that was easy.\")\n\n        include: (modules...) ->\n          for Module in modules\n            Module(I, self)\n\n          return self\n\n      return self\n\nExport\n\n    module.exports = Core\n",
          "mode": "100644",
          "type": "blob"
        },
        "main.coffee.md": {
          "path": "main.coffee.md",
          "content": "Model\n=====\n\nThe `Model` module provides helper methods to compose nested data models.\n\nModels uses [Observable](/observable/docs) to keep the internal data in sync.\n\n    Core = require \"./core\"\n    Observable = global.Observable ? require \"observable\"\n\n    module.exports = Model = (I={}, self=Core(I)) ->\n\n      self.extend\n\nBind a data model getter/setter to an attribute. The data model is bound directly to\nthe attribute and must be directly convertible to and from JSON.\n\n        attrData: (name, DataModel) ->\n          I[name] = DataModel(I[name])\n\n          Object.defineProperty self, name,\n            get: ->\n              I[name]\n            set: (value) ->\n              I[name] = DataModel(value)\n\nObserve any number of attributes as observables. For each attribute name passed in we expose a public getter/setter method and listen to changes when the value is set.\n\n        attrObservable: (names...) ->\n          names.forEach (name) ->\n            self[name] = Observable(I[name])\n\n            self[name].observe (newValue) ->\n              I[name] = newValue\n\n          return self\n\nObserve an attribute as a model. Treats the attribute given as an Observable\nmodel instance exposing a getter/setter method of the same name. The Model\nconstructor must be passed explicitly.\n\n        attrModel: (name, Model) ->\n          model = Model(I[name])\n\n          self[name] = Observable(model)\n\n          self[name].observe (newValue) ->\n            I[name] = newValue.I\n\n          return self\n\nObserve an attribute as an array of sub-models. This is the same as `attrModel`\nexcept the attribute is expected to be an array of models rather than a single one.\n\n        attrModels: (name, Model) ->\n          models = (I[name] or []).map (x) ->\n            Model(x)\n\n          self[name] = Observable(models)\n\n          self[name].observe (newValue) ->\n            I[name] = newValue.map (instance) ->\n              instance.I\n\n          return self\n\n        delegate: (names..., {to}) ->\n          names.forEach (name) ->\n            console.log \"delegating #{name} to #{to}\"\n            Object.defineProperty self, name,\n              get: ->\n                receiver = getValue self, to\n                receiver[name]\n              set: (value) ->\n                receiver = getValue self, to\n                setValue receiver, name, value\n\nThe JSON representation is kept up to date via the observable properites and resides in `I`.\n\n        toJSON: ->\n          I\n\nReturn our public object.\n\n      return self\n\n    isFn = (x) ->\n      typeof x is 'function'\n\n    getValue = (receiver, property) ->\n      if isFn receiver[property]\n        receiver[property]()\n      else\n        receiver[property]\n\n    setValue = (receiver, property, value) ->\n      target = receiver[property]\n\n      if isFn target\n        target.call(receiver, value)\n      else\n        receiver[property] = value\n\n    {defaults, extend} = require \"./util\"\n    Object.assign Model, {Core, Observable, defaults, extend}\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "version: \"0.2.0-pre.4\"\ndependencies:\n  observable: \"distri/observable:v0.3.8\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/core.coffee": {
          "path": "test/core.coffee",
          "content": "Core = require \"../core\"\n\nok = assert\nequals = assert.equal\ntest = it\n\ndescribe \"Core\", ->\n\n  test \"#extend\", ->\n    o = Core()\n\n    o.extend\n      test: \"jawsome\"\n\n    equals o.test, \"jawsome\"\n\n  test \"#attrAccessor\", ->\n    o = Core\n      test: \"my_val\"\n\n    o.attrAccessor(\"test\")\n\n    equals o.test(), \"my_val\"\n    equals o.test(\"new_val\"), o\n    equals o.test(), \"new_val\"\n\n  test \"#attrReader\", ->\n    o = Core\n      test: \"my_val\"\n\n    o.attrReader(\"test\")\n\n    equals o.test(), \"my_val\"\n    equals o.test(\"new_val\"), \"my_val\"\n    equals o.test(), \"my_val\"\n\n  test \"#include\", ->\n    o = Core\n      test: \"my_val\"\n\n    M = (I, self) ->\n      self.attrReader \"test\"\n\n      self.extend\n        test2: \"cool\"\n\n    ret = o.include M\n\n    equals ret, o, \"Should return self\"\n\n    equals o.test(), \"my_val\"\n    equals o.test2, \"cool\"\n\n  test \"#include multiple\", ->\n    o = Core\n      test: \"my_val\"\n\n    M = (I, self) ->\n      self.attrReader \"test\"\n\n      self.extend\n        test2: \"cool\"\n\n    M2 = (I, self) ->\n      self.extend\n        test2: \"coolio\"\n\n    o.include M, M2\n\n    equals o.test2, \"coolio\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/model.coffee": {
          "path": "test/model.coffee",
          "content": "Model = require \"../main\"\n\ndescribe 'Model', ->\n  # Association Testing model\n  Person = (I) ->\n    person = Model(I)\n\n    person.attrAccessor(\n      'firstName'\n      'lastName'\n      'suffix'\n    )\n\n    person.fullName = ->\n      \"#{@firstName()} #{@lastName()} #{@suffix()}\"\n\n    return person\n\n  describe \"#attrData\", ->\n    pointProto =\n      add: ({x, y}) ->\n        @x += x\n        @y += y\n\n    Point = ({x, y}) ->\n      Object.create pointProto,\n        x:\n          value: x\n        y:\n          value: y\n\n    it \"should expose a property mapping to the instance data\", ->\n      model = Model\n        position:\n          x: 5\n          y: 5\n\n      model.attrData \"position\", Point\n\n      assert model.position.add\n\n      model.position.x = 12\n      assert.equal model.position.x, model.I.position.x\n\n      model.position =\n        x: 9\n        y: 6\n\n      assert.equal model.position.y, 6\n      assert.equal model.I.position.x, 9\n\n  describe \"#attrObservable\", ->\n    it 'should allow for observing of attributes', ->\n      model = Model\n        name: \"Duder\"\n\n      model.attrObservable \"name\"\n\n      model.name(\"Dudeman\")\n\n      assert.equal model.name(), \"Dudeman\"\n\n    it 'should bind properties to observable attributes', ->\n      model = Model\n        name: \"Duder\"\n\n      model.attrObservable \"name\"\n\n      model.name(\"Dudeman\")\n\n      assert.equal model.name(), \"Dudeman\"\n      assert.equal model.name(), model.I.name\n\n  describe \"#attrModel\", ->\n    it \"should be a model instance\", ->\n      model = Model\n        person:\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      assert.equal model.person().fullName(), \"Duder Mannington Jr.\"\n\n    it \"should allow setting the associated model\", ->\n      model = Model\n        person:\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      otherPerson = Person\n        firstName: \"Mr.\"\n        lastName: \"Man\"\n\n      model.person(otherPerson)\n\n      assert.equal model.person().firstName(), \"Mr.\"\n\n    it \"shouldn't update the instance properties after it's been replaced\", ->\n      model = Model\n        person:\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      duder = model.person()\n\n      otherPerson = Person\n        firstName: \"Mr.\"\n        lastName: \"Man\"\n\n      model.person(otherPerson)\n\n      duder.firstName(\"Joe\")\n\n      assert.equal duder.I.firstName, \"Joe\"\n      assert.equal model.I.person.firstName, \"Mr.\"\n\n  describe \"#attrModels\", ->\n    it \"should have an array of model instances\", ->\n      model = Model\n        people: [{\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n        }, {\n          firstName: \"Mr.\"\n          lastName: \"Mannington\"\n          suffix: \"Sr.\"\n        }]\n\n      model.attrModels(\"people\", Person)\n\n      assert.equal model.people()[0].fullName(), \"Duder Mannington Jr.\"\n\n    it \"should track pushes\", ->\n      model = Model\n        people: [{\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n        }, {\n          firstName: \"Mr.\"\n          lastName: \"Mannington\"\n          suffix: \"Sr.\"\n        }]\n\n      model.attrModels(\"people\", Person)\n\n      model.people.push Person\n        firstName: \"JoJo\"\n        lastName: \"Loco\"\n\n      assert.equal model.people().length, 3\n      assert.equal model.I.people.length, 3\n\n    it \"should track pops\", ->\n      model = Model\n        people: [{\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n        }, {\n          firstName: \"Mr.\"\n          lastName: \"Mannington\"\n          suffix: \"Sr.\"\n        }]\n\n      model.attrModels(\"people\", Person)\n\n      model.people.pop()\n\n      assert.equal model.people().length, 1\n      assert.equal model.I.people.length, 1\n\n  describe \"#delegate\", ->\n    it \"should delegate to another method\", ->\n      model = Model\n        position:\n          x: 1\n          y: 2\n          z: 3\n\n      model.attrReader \"position\"\n\n      model.delegate \"x\", \"y\", \"z\", to: \"position\"\n\n      assert.equal model.x, 1\n      assert.equal model.y, 2\n      assert.equal model.z, 3\n\n      model.x = 5\n\n      assert.equal model.position().x, 5\n      assert.equal model.I.position.x, 5\n\n    it \"should delegate to another property\", ->\n      model = Model\n        position:\n          x: 1\n          y: 2\n          z: 3\n\n      model.position = model.I.position\n\n      model.delegate \"x\", \"y\", \"z\", to: \"position\"\n\n      assert.equal model.x, 1\n      assert.equal model.y, 2\n      assert.equal model.z, 3\n\n      model.x = 5\n\n      assert.equal model.position.x, 5\n      assert.equal model.I.position.x, 5\n\n    it \"should delegate to methods just fine\", ->\n      model = Model\n        size:\n          width: 10\n          height: 20\n\n      model.attrData \"size\", ({width, height}) ->\n        width: -> width\n        height: -> height\n\n      model.delegate \"width\", \"height\", to: \"size\"\n\n      assert.equal model.width(), 10\n      assert.equal model.height(), 20\n\n  describe \"#toJSON\", ->\n    it \"should return an object appropriate for JSON serialization\", ->\n      model = Model\n        test: true\n\n      assert model.toJSON().test\n\n  describe \"#observeAll\", ->\n    it \"should observe all attributes of a simple model\"\n    ->  # TODO\n      model = Model\n        test: true\n        yolo: \"4life\"\n\n      model.observeAll()\n\n      assert model.test()\n      assert.equal model.yolo(), \"4life\"\n\n    it \"should camel case underscored names\"\n\n  describe \".defaults\", ->\n    it \"should expose defaults method\", ->\n      assert Model.defaults\n\n  describe \".extend\", ->\n    it \"should expose extend method\", ->\n      assert Model.extend\n",
          "mode": "100644",
          "type": "blob"
        },
        "util.coffee": {
          "path": "util.coffee",
          "content": "module.exports =\n  defaults: (target, objects...) ->\n    for object in objects\n      for name of object\n        unless target.hasOwnProperty(name)\n          target[name] = object[name]\n\n    return target\n\n  extend: Object.assign\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "core": {
          "path": "core",
          "content": "(function() {\n  var Core,\n    __slice = [].slice;\n\n  Core = function(I, self) {\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = {};\n    }\n    Object.assign(self, {\n      I: I,\n      attrAccessor: function() {\n        var attrNames;\n        attrNames = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        attrNames.forEach(function(attrName) {\n          return self[attrName] = function(newValue) {\n            if (arguments.length > 0) {\n              I[attrName] = newValue;\n              return self;\n            } else {\n              return I[attrName];\n            }\n          };\n        });\n        return self;\n      },\n      attrReader: function() {\n        var attrNames;\n        attrNames = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        attrNames.forEach(function(attrName) {\n          return self[attrName] = function() {\n            return I[attrName];\n          };\n        });\n        return self;\n      },\n      extend: function() {\n        var objects;\n        objects = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return Object.assign.apply(Object, [self].concat(__slice.call(objects)));\n      },\n      include: function() {\n        var Module, modules, _i, _len;\n        modules = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        for (_i = 0, _len = modules.length; _i < _len; _i++) {\n          Module = modules[_i];\n          Module(I, self);\n        }\n        return self;\n      }\n    });\n    return self;\n  };\n\n  module.exports = Core;\n\n}).call(this);\n",
          "type": "blob"
        },
        "main": {
          "path": "main",
          "content": "(function() {\n  var Core, Model, Observable, defaults, extend, getValue, isFn, setValue, _ref, _ref1,\n    __slice = [].slice;\n\n  Core = require(\"./core\");\n\n  Observable = (_ref = global.Observable) != null ? _ref : require(\"observable\");\n\n  module.exports = Model = function(I, self) {\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = Core(I);\n    }\n    self.extend({\n      attrData: function(name, DataModel) {\n        I[name] = DataModel(I[name]);\n        return Object.defineProperty(self, name, {\n          get: function() {\n            return I[name];\n          },\n          set: function(value) {\n            return I[name] = DataModel(value);\n          }\n        });\n      },\n      attrObservable: function() {\n        var names;\n        names = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        names.forEach(function(name) {\n          self[name] = Observable(I[name]);\n          return self[name].observe(function(newValue) {\n            return I[name] = newValue;\n          });\n        });\n        return self;\n      },\n      attrModel: function(name, Model) {\n        var model;\n        model = Model(I[name]);\n        self[name] = Observable(model);\n        self[name].observe(function(newValue) {\n          return I[name] = newValue.I;\n        });\n        return self;\n      },\n      attrModels: function(name, Model) {\n        var models;\n        models = (I[name] || []).map(function(x) {\n          return Model(x);\n        });\n        self[name] = Observable(models);\n        self[name].observe(function(newValue) {\n          return I[name] = newValue.map(function(instance) {\n            return instance.I;\n          });\n        });\n        return self;\n      },\n      delegate: function() {\n        var names, to, _arg, _i;\n        names = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), _arg = arguments[_i++];\n        to = _arg.to;\n        return names.forEach(function(name) {\n          console.log(\"delegating \" + name + \" to \" + to);\n          return Object.defineProperty(self, name, {\n            get: function() {\n              var receiver;\n              receiver = getValue(self, to);\n              return receiver[name];\n            },\n            set: function(value) {\n              var receiver;\n              receiver = getValue(self, to);\n              return setValue(receiver, name, value);\n            }\n          });\n        });\n      },\n      toJSON: function() {\n        return I;\n      }\n    });\n    return self;\n  };\n\n  isFn = function(x) {\n    return typeof x === 'function';\n  };\n\n  getValue = function(receiver, property) {\n    if (isFn(receiver[property])) {\n      return receiver[property]();\n    } else {\n      return receiver[property];\n    }\n  };\n\n  setValue = function(receiver, property, value) {\n    var target;\n    target = receiver[property];\n    if (isFn(target)) {\n      return target.call(receiver, value);\n    } else {\n      return receiver[property] = value;\n    }\n  };\n\n  _ref1 = require(\"./util\"), defaults = _ref1.defaults, extend = _ref1.extend;\n\n  Object.assign(Model, {\n    Core: Core,\n    Observable: Observable,\n    defaults: defaults,\n    extend: extend\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"version\":\"0.2.0-pre.4\",\"dependencies\":{\"observable\":\"distri/observable:v0.3.8\"}};",
          "type": "blob"
        },
        "test/core": {
          "path": "test/core",
          "content": "(function() {\n  var Core, equals, ok, test;\n\n  Core = require(\"../core\");\n\n  ok = assert;\n\n  equals = assert.equal;\n\n  test = it;\n\n  describe(\"Core\", function() {\n    test(\"#extend\", function() {\n      var o;\n      o = Core();\n      o.extend({\n        test: \"jawsome\"\n      });\n      return equals(o.test, \"jawsome\");\n    });\n    test(\"#attrAccessor\", function() {\n      var o;\n      o = Core({\n        test: \"my_val\"\n      });\n      o.attrAccessor(\"test\");\n      equals(o.test(), \"my_val\");\n      equals(o.test(\"new_val\"), o);\n      return equals(o.test(), \"new_val\");\n    });\n    test(\"#attrReader\", function() {\n      var o;\n      o = Core({\n        test: \"my_val\"\n      });\n      o.attrReader(\"test\");\n      equals(o.test(), \"my_val\");\n      equals(o.test(\"new_val\"), \"my_val\");\n      return equals(o.test(), \"my_val\");\n    });\n    test(\"#include\", function() {\n      var M, o, ret;\n      o = Core({\n        test: \"my_val\"\n      });\n      M = function(I, self) {\n        self.attrReader(\"test\");\n        return self.extend({\n          test2: \"cool\"\n        });\n      };\n      ret = o.include(M);\n      equals(ret, o, \"Should return self\");\n      equals(o.test(), \"my_val\");\n      return equals(o.test2, \"cool\");\n    });\n    return test(\"#include multiple\", function() {\n      var M, M2, o;\n      o = Core({\n        test: \"my_val\"\n      });\n      M = function(I, self) {\n        self.attrReader(\"test\");\n        return self.extend({\n          test2: \"cool\"\n        });\n      };\n      M2 = function(I, self) {\n        return self.extend({\n          test2: \"coolio\"\n        });\n      };\n      o.include(M, M2);\n      return equals(o.test2, \"coolio\");\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "test/model": {
          "path": "test/model",
          "content": "(function() {\n  var Model;\n\n  Model = require(\"../main\");\n\n  describe('Model', function() {\n    var Person;\n    Person = function(I) {\n      var person;\n      person = Model(I);\n      person.attrAccessor('firstName', 'lastName', 'suffix');\n      person.fullName = function() {\n        return \"\" + (this.firstName()) + \" \" + (this.lastName()) + \" \" + (this.suffix());\n      };\n      return person;\n    };\n    describe(\"#attrData\", function() {\n      var Point, pointProto;\n      pointProto = {\n        add: function(_arg) {\n          var x, y;\n          x = _arg.x, y = _arg.y;\n          this.x += x;\n          return this.y += y;\n        }\n      };\n      Point = function(_arg) {\n        var x, y;\n        x = _arg.x, y = _arg.y;\n        return Object.create(pointProto, {\n          x: {\n            value: x\n          },\n          y: {\n            value: y\n          }\n        });\n      };\n      return it(\"should expose a property mapping to the instance data\", function() {\n        var model;\n        model = Model({\n          position: {\n            x: 5,\n            y: 5\n          }\n        });\n        model.attrData(\"position\", Point);\n        assert(model.position.add);\n        model.position.x = 12;\n        assert.equal(model.position.x, model.I.position.x);\n        model.position = {\n          x: 9,\n          y: 6\n        };\n        assert.equal(model.position.y, 6);\n        return assert.equal(model.I.position.x, 9);\n      });\n    });\n    describe(\"#attrObservable\", function() {\n      it('should allow for observing of attributes', function() {\n        var model;\n        model = Model({\n          name: \"Duder\"\n        });\n        model.attrObservable(\"name\");\n        model.name(\"Dudeman\");\n        return assert.equal(model.name(), \"Dudeman\");\n      });\n      return it('should bind properties to observable attributes', function() {\n        var model;\n        model = Model({\n          name: \"Duder\"\n        });\n        model.attrObservable(\"name\");\n        model.name(\"Dudeman\");\n        assert.equal(model.name(), \"Dudeman\");\n        return assert.equal(model.name(), model.I.name);\n      });\n    });\n    describe(\"#attrModel\", function() {\n      it(\"should be a model instance\", function() {\n        var model;\n        model = Model({\n          person: {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }\n        });\n        model.attrModel(\"person\", Person);\n        return assert.equal(model.person().fullName(), \"Duder Mannington Jr.\");\n      });\n      it(\"should allow setting the associated model\", function() {\n        var model, otherPerson;\n        model = Model({\n          person: {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }\n        });\n        model.attrModel(\"person\", Person);\n        otherPerson = Person({\n          firstName: \"Mr.\",\n          lastName: \"Man\"\n        });\n        model.person(otherPerson);\n        return assert.equal(model.person().firstName(), \"Mr.\");\n      });\n      return it(\"shouldn't update the instance properties after it's been replaced\", function() {\n        var duder, model, otherPerson;\n        model = Model({\n          person: {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }\n        });\n        model.attrModel(\"person\", Person);\n        duder = model.person();\n        otherPerson = Person({\n          firstName: \"Mr.\",\n          lastName: \"Man\"\n        });\n        model.person(otherPerson);\n        duder.firstName(\"Joe\");\n        assert.equal(duder.I.firstName, \"Joe\");\n        return assert.equal(model.I.person.firstName, \"Mr.\");\n      });\n    });\n    describe(\"#attrModels\", function() {\n      it(\"should have an array of model instances\", function() {\n        var model;\n        model = Model({\n          people: [\n            {\n              firstName: \"Duder\",\n              lastName: \"Mannington\",\n              suffix: \"Jr.\"\n            }, {\n              firstName: \"Mr.\",\n              lastName: \"Mannington\",\n              suffix: \"Sr.\"\n            }\n          ]\n        });\n        model.attrModels(\"people\", Person);\n        return assert.equal(model.people()[0].fullName(), \"Duder Mannington Jr.\");\n      });\n      it(\"should track pushes\", function() {\n        var model;\n        model = Model({\n          people: [\n            {\n              firstName: \"Duder\",\n              lastName: \"Mannington\",\n              suffix: \"Jr.\"\n            }, {\n              firstName: \"Mr.\",\n              lastName: \"Mannington\",\n              suffix: \"Sr.\"\n            }\n          ]\n        });\n        model.attrModels(\"people\", Person);\n        model.people.push(Person({\n          firstName: \"JoJo\",\n          lastName: \"Loco\"\n        }));\n        assert.equal(model.people().length, 3);\n        return assert.equal(model.I.people.length, 3);\n      });\n      return it(\"should track pops\", function() {\n        var model;\n        model = Model({\n          people: [\n            {\n              firstName: \"Duder\",\n              lastName: \"Mannington\",\n              suffix: \"Jr.\"\n            }, {\n              firstName: \"Mr.\",\n              lastName: \"Mannington\",\n              suffix: \"Sr.\"\n            }\n          ]\n        });\n        model.attrModels(\"people\", Person);\n        model.people.pop();\n        assert.equal(model.people().length, 1);\n        return assert.equal(model.I.people.length, 1);\n      });\n    });\n    describe(\"#delegate\", function() {\n      it(\"should delegate to another method\", function() {\n        var model;\n        model = Model({\n          position: {\n            x: 1,\n            y: 2,\n            z: 3\n          }\n        });\n        model.attrReader(\"position\");\n        model.delegate(\"x\", \"y\", \"z\", {\n          to: \"position\"\n        });\n        assert.equal(model.x, 1);\n        assert.equal(model.y, 2);\n        assert.equal(model.z, 3);\n        model.x = 5;\n        assert.equal(model.position().x, 5);\n        return assert.equal(model.I.position.x, 5);\n      });\n      it(\"should delegate to another property\", function() {\n        var model;\n        model = Model({\n          position: {\n            x: 1,\n            y: 2,\n            z: 3\n          }\n        });\n        model.position = model.I.position;\n        model.delegate(\"x\", \"y\", \"z\", {\n          to: \"position\"\n        });\n        assert.equal(model.x, 1);\n        assert.equal(model.y, 2);\n        assert.equal(model.z, 3);\n        model.x = 5;\n        assert.equal(model.position.x, 5);\n        return assert.equal(model.I.position.x, 5);\n      });\n      return it(\"should delegate to methods just fine\", function() {\n        var model;\n        model = Model({\n          size: {\n            width: 10,\n            height: 20\n          }\n        });\n        model.attrData(\"size\", function(_arg) {\n          var height, width;\n          width = _arg.width, height = _arg.height;\n          return {\n            width: function() {\n              return width;\n            },\n            height: function() {\n              return height;\n            }\n          };\n        });\n        model.delegate(\"width\", \"height\", {\n          to: \"size\"\n        });\n        assert.equal(model.width(), 10);\n        return assert.equal(model.height(), 20);\n      });\n    });\n    describe(\"#toJSON\", function() {\n      return it(\"should return an object appropriate for JSON serialization\", function() {\n        var model;\n        model = Model({\n          test: true\n        });\n        return assert(model.toJSON().test);\n      });\n    });\n    describe(\"#observeAll\", function() {\n      it(\"should observe all attributes of a simple model\");\n      (function() {\n        var model;\n        model = Model({\n          test: true,\n          yolo: \"4life\"\n        });\n        model.observeAll();\n        assert(model.test());\n        return assert.equal(model.yolo(), \"4life\");\n      });\n      return it(\"should camel case underscored names\");\n    });\n    describe(\".defaults\", function() {\n      return it(\"should expose defaults method\", function() {\n        return assert(Model.defaults);\n      });\n    });\n    return describe(\".extend\", function() {\n      return it(\"should expose extend method\", function() {\n        return assert(Model.extend);\n      });\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "util": {
          "path": "util",
          "content": "(function() {\n  var __slice = [].slice;\n\n  module.exports = {\n    defaults: function() {\n      var name, object, objects, target, _i, _len;\n      target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      for (_i = 0, _len = objects.length; _i < _len; _i++) {\n        object = objects[_i];\n        for (name in object) {\n          if (!target.hasOwnProperty(name)) {\n            target[name] = object[name];\n          }\n        }\n      }\n      return target;\n    },\n    extend: Object.assign\n  };\n\n}).call(this);\n",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "https://danielx.net/editor/"
      },
      "config": {
        "version": "0.2.0-pre.4",
        "dependencies": {
          "observable": "distri/observable:v0.3.8"
        }
      },
      "version": "0.2.0-pre.4",
      "entryPoint": "main",
      "repository": {
        "branch": "master",
        "default_branch": "master",
        "full_name": "distri/model",
        "homepage": null,
        "description": null,
        "html_url": "https://github.com/distri/model",
        "url": "https://api.github.com/repos/distri/model",
        "publishBranch": "gh-pages"
      },
      "dependencies": {
        "observable": {
          "source": {
            "LICENSE": {
              "path": "LICENSE",
              "content": "The MIT License (MIT)\n\nCopyright (c) 2014 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
              "mode": "100644",
              "type": "blob"
            },
            "README.md": {
              "path": "README.md",
              "content": "[![Build Status](https://travis-ci.org/distri/observable.svg?branch=npm)](https://travis-ci.org/distri/observable)\n\nObservable\n==========\n\nInstallation\n------------\n\nNode\n\n    npm install o_0\n\nUsage\n-----\n\n    Observable = require \"o_0\"\n\nGet notified when the value changes.\n\n    observable = Observable 5\n\n    observable() # 5\n\n    observable.observe (newValue) ->\n      console.log newValue\n\n    observable 10 # logs 10 to console\n\nArrays\n------\n\nProxy array methods.\n\n    observable = Observable [1, 2, 3]\n\n    observable.forEach (value) ->\n      # 1, 2, 3\n\nFunctions\n---------\n\nAutomagically compute dependencies for observable functions.\n\n    firstName = Observable \"Duder\"\n    lastName = Observable \"Man\"\n\n    o = Observable ->\n      \"#{firstName()} #{lastName()}\"\n\n    o.observe (newValue) ->\n      assert.equal newValue, \"Duder Bro\"\n\n    lastName \"Bro\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "main.coffee.md": {
              "path": "main.coffee.md",
              "content": "Observable\n==========\n\n`Observable` allows for observing arrays, functions, and objects.\n\nFunction dependencies are automagically observed.\n\nStandard array methods are proxied through to the underlying array.\n\n    module.exports = Observable = (value, context) ->\n\nReturn the object if it is already an observable object.\n\n      return value if typeof value?.observe is \"function\"\n\nMaintain a set of listeners to observe changes and provide a helper to notify each observer.\n\n      listeners = []\n\n      notify = (newValue) ->\n        copy(listeners).forEach (listener) ->\n          listener(newValue)\n\nOur observable function is stored as a reference to `self`.\n\nIf `value` is a function compute dependencies and listen to observables that it depends on.\n\n      if typeof value is 'function'\n        fn = value\n\nOur return function is a function that holds only a cached value which is updated\nwhen it's dependencies change.\n\nThe `magicDependency` call is so other functions can depend on this computed function the\nsame way we depend on other types of observables.\n\n        self = ->\n          # Automagic dependency observation\n          magicDependency(self)\n\n          return value\n\n        changed = ->\n          value = computeDependencies(self, fn, changed, context)\n          notify(value)\n\n        changed()\n\n      else\n\nWhen called with zero arguments it is treated as a getter. When called with one argument it is treated as a setter.\n\nChanges to the value will trigger notifications.\n\nThe value is always returned.\n\n        self = (newValue) ->\n          if arguments.length > 0\n            if value != newValue\n              value = newValue\n\n              notify(newValue)\n          else\n            # Automagic dependency observation\n            magicDependency(self)\n\n          return value\n\nThis `each` iterator is similar to [the Maybe monad](http://en.wikipedia.org/wiki/Monad_&#40;functional_programming&#41;#The_Maybe_monad) in that our observable may contain a single value or nothing at all.\n\n      self.each = (callback) ->\n        magicDependency(self)\n\n        if value?\n          [value].forEach (item) ->\n            callback.call(item, item)\n\n        return self\n\nIf the value is an array then proxy array methods and add notifications to mutation events.\n\n      if Array.isArray(value)\n        [\n          \"concat\"\n          \"every\"\n          \"filter\"\n          \"forEach\"\n          \"indexOf\"\n          \"join\"\n          \"lastIndexOf\"\n          \"map\"\n          \"reduce\"\n          \"reduceRight\"\n          \"slice\"\n          \"some\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            magicDependency(self)\n            value[method](args...)\n\n        [\n          \"pop\"\n          \"push\"\n          \"reverse\"\n          \"shift\"\n          \"splice\"\n          \"sort\"\n          \"unshift\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            notifyReturning value[method](args...)\n\n        # Provide length on a best effort basis because older browsers choke\n        if PROXY_LENGTH\n          Object.defineProperty self, 'length',\n            get: ->\n              magicDependency(self)\n              value.length\n            set: (length) ->\n              value.length = length\n              notifyReturning(value.length)\n\n        notifyReturning = (returnValue) ->\n          notify(value)\n\n          return returnValue\n\nAdd some extra helpful methods to array observables.\n\n        extend self,\n          each: (callback) ->\n            self.forEach (item, index) ->\n              callback.call(item, item, index, self)\n\n            return self\n\nRemove an element from the array and notify observers of changes.\n\n          remove: (object) ->\n            index = value.indexOf(object)\n\n            if index >= 0\n              notifyReturning value.splice(index, 1)[0]\n\n          get: (index) ->\n            magicDependency(self)\n            value[index]\n\n          first: ->\n            magicDependency(self)\n            value[0]\n\n          last: ->\n            magicDependency(self)\n            value[value.length-1]\n\n          size: ->\n            magicDependency(self)\n            value.length\n\n      extend self,\n        listeners: listeners\n\n        observe: (listener) ->\n          listeners.push listener\n\n        stopObserving: (fn) ->\n          remove listeners, fn\n\n        toggle: ->\n          self !value\n\n        increment: (n) ->\n          self value + n\n\n        decrement: (n) ->\n          self value - n\n\n        toString: ->\n          \"Observable(#{value})\"\n\n      return self\n\n    Observable.concat = ->\n      # Optimization: Manually copy arguments to an array\n      args = new Array(arguments.length)\n      for arg, i in arguments\n        args[i] = arguments[i]\n\n      collection = Observable(args)\n\n      o = Observable ->\n        flatten collection.map(splat)\n\n      o.push = collection.push\n\n      return o\n\nAppendix\n--------\n\nThe extend method adds one object's properties to another.\n\n    extend = (target) ->\n      # Optimization: iterate through arguments manually rather than pass to slice to create an array\n      for source, i in arguments\n        # The first argument is target, so skip it\n        if i > 0\n          for name of source\n            target[name] = source[name]\n\n      return target\n\nSuper hax for computing dependencies. This needs to be a shared global so that\ndifferent bundled versions of observable libraries can interoperate.\n\n    global.OBSERVABLE_ROOT_HACK = []\n\n    magicDependency = (self) ->\n      observerSet = last(global.OBSERVABLE_ROOT_HACK)\n      if observerSet\n        observerSet.add self\n\nOptimization: Keep the function containing the try-catch as small as possible.\n\n    tryCallWithFinallyPop = (fn, context) ->\n      try\n        fn.call(context)\n      finally\n        global.OBSERVABLE_ROOT_HACK.pop()\n\nAutomagically compute dependencies.\n\n    computeDependencies = (self, fn, update, context) ->\n      deps = new Set\n\n      global.OBSERVABLE_ROOT_HACK.push(deps)\n\n      value = tryCallWithFinallyPop fn, context\n\n      self._deps?.forEach (observable) ->\n        observable.stopObserving update\n\n      self._deps = deps\n\n      deps.forEach (observable) ->\n        observable.observe update\n\n      return value\n\nCheck if we can proxy function length property.\n\n    try\n      Object.defineProperty (->), 'length',\n        get: ->\n        set: ->\n\n      PROXY_LENGTH = true\n    catch\n      PROXY_LENGTH = false\n\nRemove a value from an array.\n\n    remove = (array, value) ->\n      index = array.indexOf(value)\n\n      if index >= 0\n        array.splice(index, 1)[0]\n\n    copy = (array) ->\n      array.concat([])\n\n    get = (arg) ->\n      if typeof arg is \"function\"\n        arg()\n      else\n        arg\n\n    splat = (item) ->\n      results = []\n\n      return results unless item?\n\n      if typeof item.forEach is \"function\"\n        item.forEach (i) ->\n          results.push i\n      else\n        result = get item\n\n        results.push result if result?\n\n      results\n\n    last = (array) ->\n      array[array.length - 1]\n\n    flatten = (array) ->\n      array.reduce (a, b) ->\n        a.concat(b)\n      , []\n",
              "mode": "100644",
              "type": "blob"
            },
            "pixie.cson": {
              "path": "pixie.cson",
              "content": "version: \"0.3.8\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "test/observable.coffee": {
              "path": "test/observable.coffee",
              "content": "global.Observable = require \"../main\"\n\ndescribe 'Observable', ->\n  it 'should create an observable for an object', ->\n    n = 5\n\n    observable = Observable(n)\n\n    assert.equal(observable(), n)\n\n  it 'should fire events when setting', ->\n    string = \"yolo\"\n\n    observable = Observable(string)\n    observable.observe (newValue) ->\n      assert.equal newValue, \"4life\"\n\n    observable(\"4life\")\n\n  it \"should not fire when setting to the same value\", ->\n    o = Observable 5\n\n    o.observe ->\n      assert false\n\n    o(5)\n\n  it 'should be idempotent', ->\n    o = Observable(5)\n\n    assert.equal o, Observable(o)\n\n  describe \"#each\", ->\n    it \"should be invoked once if there is an observable\", ->\n      o = Observable(5)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n        assert.equal value, 5\n\n      assert.equal called, 1\n\n    it \"should not be invoked if observable is null\", ->\n      o = Observable(null)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n\n      assert.equal called, 0\n\n    it \"should have the correct `this` scope for items\", (done) ->\n      o = Observable 5\n\n      o.each ->\n        assert.equal this, 5\n        done()\n\n    it \"should have the correct `this` scope for items in observable arrays\", ->\n      scopes = []\n\n      o = Observable [\"I'm\", \"an\", \"array\"]\n\n      o.each ->\n        scopes.push this\n\n      assert.equal scopes[0], \"I'm\"\n      assert.equal scopes[1], \"an\"\n      assert.equal scopes[2], \"array\"\n\n  it \"should allow for stopping observation\", ->\n    observable = Observable(\"string\")\n\n    called = 0\n    fn = (newValue) ->\n      called += 1\n      assert.equal newValue, \"4life\"\n\n    observable.observe fn\n\n    observable(\"4life\")\n\n    observable.stopObserving fn\n\n    observable(\"wat\")\n\n    assert.equal called, 1\n\n  it \"should increment\", ->\n    observable = Observable 1\n\n    observable.increment(5)\n\n    assert.equal observable(), 6\n\n  it \"should decremnet\", ->\n    observable = Observable 1\n\n    observable.decrement 5\n\n    assert.equal observable(), -4\n\n  it \"should toggle\", ->\n    observable = Observable false\n\n    observable.toggle()\n    assert.equal observable(), true\n\n    observable.toggle()\n    assert.equal observable(), false\n\n  it \"should trigger when toggling\", (done) ->\n    observable = Observable true\n    observable.observe (v) ->\n      assert.equal v, false\n      done()\n\n    observable.toggle()\n\n  it \"should have a nice toString\", ->\n    observable = Observable 5\n\n    assert.equal observable.toString(), \"Observable(5)\"\n\ndescribe \"Observable Array\", ->\n  it \"should proxy array methods\", ->\n    o = Observable [5]\n\n    o.map (n) ->\n      assert.equal n, 5\n\n  it \"should notify on mutation methods\", (done) ->\n    o = Observable []\n\n    o.observe (newValue) ->\n      assert.equal newValue[0], 1\n\n    o.push 1\n\n    done()\n\n  it \"should have an each method\", ->\n    o = Observable []\n\n    assert o.each\n\n  it \"#get\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.get(2), 2\n\n  it \"#first\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.first(), 0\n\n  it \"#last\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.last(), 3\n\n  it \"#remove\", (done) ->\n    o = Observable [0, 1, 2, 3]\n\n    o.observe (newValue) ->\n      assert.equal newValue.length, 3\n      setTimeout ->\n        done()\n      , 0\n\n    assert.equal o.remove(2), 2\n\n  it \"#remove non-existent element\", ->\n    o = Observable [1, 2, 3]\n\n    assert.equal o.remove(0), undefined\n\n  it \"should proxy the length property\", ->\n    o = Observable [1, 2, 3]\n\n    assert.equal o.length, 3\n\n    called = false\n    o.observe (value) ->\n      assert.equal value[0], 1\n      assert.equal value[1], undefined\n      called = true\n\n    o.length = 1\n    assert.equal o.length, 1\n    assert.equal called, true\n\n  it \"should auto detect conditionals of length as a dependency\", ->\n    observableArray = Observable [1, 2, 3]\n\n    o = Observable ->\n      if observableArray.length > 5\n        true\n      else\n        false\n\n    assert.equal o(), false\n\n    called = 0\n    o.observe ->\n      called += 1\n\n    observableArray.push 4, 5, 6\n\n    assert.equal called, 1\n\ndescribe \"Observable functions\", ->\n  it \"should compute dependencies\", (done) ->\n    firstName = Observable \"Duder\"\n    lastName = Observable \"Man\"\n\n    o = Observable ->\n      \"#{firstName()} #{lastName()}\"\n\n    o.observe (newValue) ->\n      assert.equal newValue, \"Duder Bro\"\n\n      done()\n\n    lastName \"Bro\"\n\n  it \"should compute array#get as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.get(0)\n\n    assert.equal observableFn(), 0\n\n    observableArray([5])\n\n    assert.equal observableFn(), 5\n\n  it \"should compute array#first as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.first() + 1\n\n    assert.equal observableFn(), 1\n\n    observableArray([5])\n\n    assert.equal observableFn(), 6\n\n  it \"should compute array#last as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.last()\n\n    assert.equal observableFn(), 2\n\n    observableArray.pop()\n\n    assert.equal observableFn(), 1\n\n    observableArray([5])\n\n    assert.equal observableFn(), 5\n\n  it \"should compute array#size as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.size() * 2\n\n    assert.equal observableFn(), 6\n\n    observableArray.pop()\n    assert.equal observableFn(), 4\n    observableArray.shift()\n    assert.equal observableFn(), 2\n\n  it \"should allow double nesting\", (done) ->\n    bottom = Observable \"rad\"\n    middle = Observable ->\n      bottom()\n    top = Observable ->\n      middle()\n\n    top.observe (newValue) ->\n      assert.equal newValue, \"wat\"\n      assert.equal top(), newValue\n      assert.equal middle(), newValue\n\n      done()\n\n    bottom(\"wat\")\n\n  it \"should work with dynamic dependencies\", ->\n    observableArray = Observable []\n\n    dynamicObservable = Observable ->\n      observableArray.filter (item) ->\n        item.age() > 3\n\n    assert.equal dynamicObservable().length, 0\n\n    observableArray.push\n      age: Observable 1\n\n    observableArray()[0].age 5\n    assert.equal dynamicObservable().length, 1\n\n  it \"should work with context\", ->\n    model =\n      a: Observable \"Hello\"\n      b: Observable \"there\"\n\n    model.c = Observable ->\n      \"#{@a()} #{@b()}\"\n    , model\n\n    assert.equal model.c(), \"Hello there\"\n\n    model.b \"world\"\n\n    assert.equal model.c(), \"Hello world\"\n\n  it \"should be ok even if the function throws an exception\", ->\n    assert.throws ->\n      t = Observable ->\n        throw \"wat\"\n\n    # TODO: Should be able to find a test case that is affected by this rather that\n    # checking it directly\n    assert.equal global.OBSERVABLE_ROOT_HACK.length, 0\n\n  it \"should have an each method\", ->\n    o = Observable ->\n\n    assert o.each()\n\n  it \"should not invoke when returning undefined\", ->\n    o = Observable ->\n\n    o.each ->\n      assert false\n\n  it \"should invoke when returning any defined value\", (done) ->\n    o = Observable -> 5\n\n    o.each (n) ->\n      assert.equal n, 5\n      done()\n\n  it \"should work on an array dependency\", ->\n    oA = Observable [1, 2, 3]\n\n    o = Observable ->\n      oA()[0]\n\n    last = Observable ->\n      oA()[oA().length-1]\n\n    assert.equal o(), 1\n\n    oA.unshift 0\n\n    assert.equal o(), 0\n\n    oA.push 4\n\n    assert.equal last(), 4, \"Last should be 4\"\n\n  it \"should work with multiple dependencies\", ->\n    letter = Observable \"A\"\n    checked = ->\n      l = letter()\n      @name().indexOf(l) is 0\n\n    first = {name: Observable(\"Andrew\")}\n    first.checked = Observable checked, first\n\n    second = {name: Observable(\"Benjamin\")}\n    second.checked = Observable checked, second\n\n    assert.equal first.checked(), true\n    assert.equal second.checked(), false\n\n    assert.equal letter.listeners.length, 2\n\n    letter \"B\"\n\n    assert.equal first.checked(), false\n    assert.equal second.checked(), true\n\n  it \"shouldn't double count dependencies\", ->\n    dep = Observable \"yo\"\n\n    o = Observable ->\n      dep()\n      dep()\n      dep()\n\n    count = 0\n    o.observe ->\n      count += 1\n\n    dep('heyy')\n\n    assert.equal count, 1\n\n  it \"should work with nested observable construction\", ->\n    gen = Observable ->\n      Observable \"Duder\"\n\n    o = gen()\n\n    assert.equal o(), \"Duder\"\n\n    o(\"wat\")\n\n    assert.equal o(), \"wat\"\n\n  describe \"Scoping\", ->\n    it \"should be scoped to optional context\", (done) ->\n      model =\n        firstName: Observable \"Duder\"\n        lastName: Observable \"Man\"\n\n      model.name = Observable ->\n        \"#{@firstName()} #{@lastName()}\"\n      , model\n\n      model.name.observe (newValue) ->\n        assert.equal newValue, \"Duder Bro\"\n\n        done()\n\n      model.lastName \"Bro\"\n\n  describe \"concat\", ->\n    it \"should work with a single observable\", ->\n      observable = Observable \"something\"\n      observableArray = Observable.concat observable\n      assert.equal observableArray.last(), \"something\"\n\n      observable \"something else\"\n      assert.equal observableArray.last(), \"something else\"\n\n    it \"should work with an undefined observable\", ->\n      observable = Observable undefined\n      observableArray = Observable.concat observable\n      assert.equal observableArray.size(), 0\n\n      observable \"defined\"\n      assert.equal observableArray.size(), 1\n\n    it \"should work with undefined\", ->\n      observableArray = Observable.concat undefined\n      assert.equal observableArray.size(), 0\n\n    it \"should work with []\", ->\n      observableArray = Observable.concat []\n      assert.equal observableArray.size(), 0\n\n    it \"should return an observable array that changes based on changes in inputs\", ->\n      numbers = Observable [1, 2, 3]\n      letters = Observable [\"a\", \"b\", \"c\"]\n      item = Observable({})\n      nullable = Observable null\n\n      observableArray = Observable.concat numbers, \"literal\", letters, item, nullable\n\n      assert.equal observableArray().length, 3 + 1 + 3 + 1\n\n      assert.equal observableArray()[0], 1\n      assert.equal observableArray()[3], \"literal\"\n      assert.equal observableArray()[4], \"a\"\n      assert.equal observableArray()[7], item()\n\n      numbers.push 4\n\n      assert.equal observableArray().length, 9\n\n      nullable \"cool\"\n\n      assert.equal observableArray().length, 10\n\n    it \"should work with observable functions that return arrays\", ->\n      item = Observable(\"wat\")\n\n      computedArray = Observable ->\n        [item()]\n\n      observableArray = Observable.concat computedArray, computedArray\n\n      assert.equal observableArray().length, 2\n\n      assert.equal observableArray()[1], \"wat\"\n\n      item \"yolo\"\n\n      assert.equal observableArray()[1], \"yolo\"\n\n    it \"should have a push method\", ->\n      observableArray = Observable.concat()\n\n      observable = Observable \"hey\"\n\n      observableArray.push observable\n\n      assert.equal observableArray()[0], \"hey\"\n\n      observable \"wat\"\n\n      assert.equal observableArray()[0], \"wat\"\n\n      observableArray.push \"cool\"\n      observableArray.push \"radical\"\n\n      assert.equal observableArray().length, 3\n\n    it \"should be observable\", (done) ->\n      observableArray = Observable.concat()\n\n      observableArray.observe (items) ->\n        assert.equal items.length, 3\n        done()\n\n      observableArray.push [\"A\", \"B\", \"C\"]\n\n    it \"should have an each method\", ->\n      observableArray = Observable.concat([\"A\", \"B\", \"C\"])\n\n      n = 0\n      observableArray.each () ->\n        n += 1\n\n      assert.equal n, 3\n\n  describe \"nesting dependencies\", ->\n    it \"should update the correct observable\", ->\n      a = Observable \"a\"\n      b = Observable \"b\"\n\n      results = Observable ->\n        r = Observable.concat()\n\n        r.push a\n        r.push b\n\n        r\n\n      # TODO: Should this just be\n      #     results.first()\n      assert.equal results().first(), \"a\"\n\n      a(\"newA\")\n\n      assert.equal results().first(), \"newA\"\n",
              "mode": "100644",
              "type": "blob"
            }
          },
          "distribution": {
            "main": {
              "path": "main",
              "content": "(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n",
              "type": "blob"
            },
            "pixie": {
              "path": "pixie",
              "content": "module.exports = {\"version\":\"0.3.8\"};",
              "type": "blob"
            },
            "test/observable": {
              "path": "test/observable",
              "content": "(function() {\n  global.Observable = require(\"../main\");\n\n  describe('Observable', function() {\n    it('should create an observable for an object', function() {\n      var n, observable;\n      n = 5;\n      observable = Observable(n);\n      return assert.equal(observable(), n);\n    });\n    it('should fire events when setting', function() {\n      var observable, string;\n      string = \"yolo\";\n      observable = Observable(string);\n      observable.observe(function(newValue) {\n        return assert.equal(newValue, \"4life\");\n      });\n      return observable(\"4life\");\n    });\n    it(\"should not fire when setting to the same value\", function() {\n      var o;\n      o = Observable(5);\n      o.observe(function() {\n        return assert(false);\n      });\n      return o(5);\n    });\n    it('should be idempotent', function() {\n      var o;\n      o = Observable(5);\n      return assert.equal(o, Observable(o));\n    });\n    describe(\"#each\", function() {\n      it(\"should be invoked once if there is an observable\", function() {\n        var called, o;\n        o = Observable(5);\n        called = 0;\n        o.each(function(value) {\n          called += 1;\n          return assert.equal(value, 5);\n        });\n        return assert.equal(called, 1);\n      });\n      it(\"should not be invoked if observable is null\", function() {\n        var called, o;\n        o = Observable(null);\n        called = 0;\n        o.each(function(value) {\n          return called += 1;\n        });\n        return assert.equal(called, 0);\n      });\n      it(\"should have the correct `this` scope for items\", function(done) {\n        var o;\n        o = Observable(5);\n        return o.each(function() {\n          assert.equal(this, 5);\n          return done();\n        });\n      });\n      return it(\"should have the correct `this` scope for items in observable arrays\", function() {\n        var o, scopes;\n        scopes = [];\n        o = Observable([\"I'm\", \"an\", \"array\"]);\n        o.each(function() {\n          return scopes.push(this);\n        });\n        assert.equal(scopes[0], \"I'm\");\n        assert.equal(scopes[1], \"an\");\n        return assert.equal(scopes[2], \"array\");\n      });\n    });\n    it(\"should allow for stopping observation\", function() {\n      var called, fn, observable;\n      observable = Observable(\"string\");\n      called = 0;\n      fn = function(newValue) {\n        called += 1;\n        return assert.equal(newValue, \"4life\");\n      };\n      observable.observe(fn);\n      observable(\"4life\");\n      observable.stopObserving(fn);\n      observable(\"wat\");\n      return assert.equal(called, 1);\n    });\n    it(\"should increment\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.increment(5);\n      return assert.equal(observable(), 6);\n    });\n    it(\"should decremnet\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.decrement(5);\n      return assert.equal(observable(), -4);\n    });\n    it(\"should toggle\", function() {\n      var observable;\n      observable = Observable(false);\n      observable.toggle();\n      assert.equal(observable(), true);\n      observable.toggle();\n      return assert.equal(observable(), false);\n    });\n    it(\"should trigger when toggling\", function(done) {\n      var observable;\n      observable = Observable(true);\n      observable.observe(function(v) {\n        assert.equal(v, false);\n        return done();\n      });\n      return observable.toggle();\n    });\n    return it(\"should have a nice toString\", function() {\n      var observable;\n      observable = Observable(5);\n      return assert.equal(observable.toString(), \"Observable(5)\");\n    });\n  });\n\n  describe(\"Observable Array\", function() {\n    it(\"should proxy array methods\", function() {\n      var o;\n      o = Observable([5]);\n      return o.map(function(n) {\n        return assert.equal(n, 5);\n      });\n    });\n    it(\"should notify on mutation methods\", function(done) {\n      var o;\n      o = Observable([]);\n      o.observe(function(newValue) {\n        return assert.equal(newValue[0], 1);\n      });\n      o.push(1);\n      return done();\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable([]);\n      return assert(o.each);\n    });\n    it(\"#get\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.get(2), 2);\n    });\n    it(\"#first\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.first(), 0);\n    });\n    it(\"#last\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.last(), 3);\n    });\n    it(\"#remove\", function(done) {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      o.observe(function(newValue) {\n        assert.equal(newValue.length, 3);\n        return setTimeout(function() {\n          return done();\n        }, 0);\n      });\n      return assert.equal(o.remove(2), 2);\n    });\n    it(\"#remove non-existent element\", function() {\n      var o;\n      o = Observable([1, 2, 3]);\n      return assert.equal(o.remove(0), void 0);\n    });\n    it(\"should proxy the length property\", function() {\n      var called, o;\n      o = Observable([1, 2, 3]);\n      assert.equal(o.length, 3);\n      called = false;\n      o.observe(function(value) {\n        assert.equal(value[0], 1);\n        assert.equal(value[1], void 0);\n        return called = true;\n      });\n      o.length = 1;\n      assert.equal(o.length, 1);\n      return assert.equal(called, true);\n    });\n    return it(\"should auto detect conditionals of length as a dependency\", function() {\n      var called, o, observableArray;\n      observableArray = Observable([1, 2, 3]);\n      o = Observable(function() {\n        if (observableArray.length > 5) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n      assert.equal(o(), false);\n      called = 0;\n      o.observe(function() {\n        return called += 1;\n      });\n      observableArray.push(4, 5, 6);\n      return assert.equal(called, 1);\n    });\n  });\n\n  describe(\"Observable functions\", function() {\n    it(\"should compute dependencies\", function(done) {\n      var firstName, lastName, o;\n      firstName = Observable(\"Duder\");\n      lastName = Observable(\"Man\");\n      o = Observable(function() {\n        return \"\" + (firstName()) + \" \" + (lastName());\n      });\n      o.observe(function(newValue) {\n        assert.equal(newValue, \"Duder Bro\");\n        return done();\n      });\n      return lastName(\"Bro\");\n    });\n    it(\"should compute array#get as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.get(0);\n      });\n      assert.equal(observableFn(), 0);\n      observableArray([5]);\n      return assert.equal(observableFn(), 5);\n    });\n    it(\"should compute array#first as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.first() + 1;\n      });\n      assert.equal(observableFn(), 1);\n      observableArray([5]);\n      return assert.equal(observableFn(), 6);\n    });\n    it(\"should compute array#last as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.last();\n      });\n      assert.equal(observableFn(), 2);\n      observableArray.pop();\n      assert.equal(observableFn(), 1);\n      observableArray([5]);\n      return assert.equal(observableFn(), 5);\n    });\n    it(\"should compute array#size as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.size() * 2;\n      });\n      assert.equal(observableFn(), 6);\n      observableArray.pop();\n      assert.equal(observableFn(), 4);\n      observableArray.shift();\n      return assert.equal(observableFn(), 2);\n    });\n    it(\"should allow double nesting\", function(done) {\n      var bottom, middle, top;\n      bottom = Observable(\"rad\");\n      middle = Observable(function() {\n        return bottom();\n      });\n      top = Observable(function() {\n        return middle();\n      });\n      top.observe(function(newValue) {\n        assert.equal(newValue, \"wat\");\n        assert.equal(top(), newValue);\n        assert.equal(middle(), newValue);\n        return done();\n      });\n      return bottom(\"wat\");\n    });\n    it(\"should work with dynamic dependencies\", function() {\n      var dynamicObservable, observableArray;\n      observableArray = Observable([]);\n      dynamicObservable = Observable(function() {\n        return observableArray.filter(function(item) {\n          return item.age() > 3;\n        });\n      });\n      assert.equal(dynamicObservable().length, 0);\n      observableArray.push({\n        age: Observable(1)\n      });\n      observableArray()[0].age(5);\n      return assert.equal(dynamicObservable().length, 1);\n    });\n    it(\"should work with context\", function() {\n      var model;\n      model = {\n        a: Observable(\"Hello\"),\n        b: Observable(\"there\")\n      };\n      model.c = Observable(function() {\n        return \"\" + (this.a()) + \" \" + (this.b());\n      }, model);\n      assert.equal(model.c(), \"Hello there\");\n      model.b(\"world\");\n      return assert.equal(model.c(), \"Hello world\");\n    });\n    it(\"should be ok even if the function throws an exception\", function() {\n      assert.throws(function() {\n        var t;\n        return t = Observable(function() {\n          throw \"wat\";\n        });\n      });\n      return assert.equal(global.OBSERVABLE_ROOT_HACK.length, 0);\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable(function() {});\n      return assert(o.each());\n    });\n    it(\"should not invoke when returning undefined\", function() {\n      var o;\n      o = Observable(function() {});\n      return o.each(function() {\n        return assert(false);\n      });\n    });\n    it(\"should invoke when returning any defined value\", function(done) {\n      var o;\n      o = Observable(function() {\n        return 5;\n      });\n      return o.each(function(n) {\n        assert.equal(n, 5);\n        return done();\n      });\n    });\n    it(\"should work on an array dependency\", function() {\n      var last, o, oA;\n      oA = Observable([1, 2, 3]);\n      o = Observable(function() {\n        return oA()[0];\n      });\n      last = Observable(function() {\n        return oA()[oA().length - 1];\n      });\n      assert.equal(o(), 1);\n      oA.unshift(0);\n      assert.equal(o(), 0);\n      oA.push(4);\n      return assert.equal(last(), 4, \"Last should be 4\");\n    });\n    it(\"should work with multiple dependencies\", function() {\n      var checked, first, letter, second;\n      letter = Observable(\"A\");\n      checked = function() {\n        var l;\n        l = letter();\n        return this.name().indexOf(l) === 0;\n      };\n      first = {\n        name: Observable(\"Andrew\")\n      };\n      first.checked = Observable(checked, first);\n      second = {\n        name: Observable(\"Benjamin\")\n      };\n      second.checked = Observable(checked, second);\n      assert.equal(first.checked(), true);\n      assert.equal(second.checked(), false);\n      assert.equal(letter.listeners.length, 2);\n      letter(\"B\");\n      assert.equal(first.checked(), false);\n      return assert.equal(second.checked(), true);\n    });\n    it(\"shouldn't double count dependencies\", function() {\n      var count, dep, o;\n      dep = Observable(\"yo\");\n      o = Observable(function() {\n        dep();\n        dep();\n        return dep();\n      });\n      count = 0;\n      o.observe(function() {\n        return count += 1;\n      });\n      dep('heyy');\n      return assert.equal(count, 1);\n    });\n    it(\"should work with nested observable construction\", function() {\n      var gen, o;\n      gen = Observable(function() {\n        return Observable(\"Duder\");\n      });\n      o = gen();\n      assert.equal(o(), \"Duder\");\n      o(\"wat\");\n      return assert.equal(o(), \"wat\");\n    });\n    describe(\"Scoping\", function() {\n      return it(\"should be scoped to optional context\", function(done) {\n        var model;\n        model = {\n          firstName: Observable(\"Duder\"),\n          lastName: Observable(\"Man\")\n        };\n        model.name = Observable(function() {\n          return \"\" + (this.firstName()) + \" \" + (this.lastName());\n        }, model);\n        model.name.observe(function(newValue) {\n          assert.equal(newValue, \"Duder Bro\");\n          return done();\n        });\n        return model.lastName(\"Bro\");\n      });\n    });\n    describe(\"concat\", function() {\n      it(\"should work with a single observable\", function() {\n        var observable, observableArray;\n        observable = Observable(\"something\");\n        observableArray = Observable.concat(observable);\n        assert.equal(observableArray.last(), \"something\");\n        observable(\"something else\");\n        return assert.equal(observableArray.last(), \"something else\");\n      });\n      it(\"should work with an undefined observable\", function() {\n        var observable, observableArray;\n        observable = Observable(void 0);\n        observableArray = Observable.concat(observable);\n        assert.equal(observableArray.size(), 0);\n        observable(\"defined\");\n        return assert.equal(observableArray.size(), 1);\n      });\n      it(\"should work with undefined\", function() {\n        var observableArray;\n        observableArray = Observable.concat(void 0);\n        return assert.equal(observableArray.size(), 0);\n      });\n      it(\"should work with []\", function() {\n        var observableArray;\n        observableArray = Observable.concat([]);\n        return assert.equal(observableArray.size(), 0);\n      });\n      it(\"should return an observable array that changes based on changes in inputs\", function() {\n        var item, letters, nullable, numbers, observableArray;\n        numbers = Observable([1, 2, 3]);\n        letters = Observable([\"a\", \"b\", \"c\"]);\n        item = Observable({});\n        nullable = Observable(null);\n        observableArray = Observable.concat(numbers, \"literal\", letters, item, nullable);\n        assert.equal(observableArray().length, 3 + 1 + 3 + 1);\n        assert.equal(observableArray()[0], 1);\n        assert.equal(observableArray()[3], \"literal\");\n        assert.equal(observableArray()[4], \"a\");\n        assert.equal(observableArray()[7], item());\n        numbers.push(4);\n        assert.equal(observableArray().length, 9);\n        nullable(\"cool\");\n        return assert.equal(observableArray().length, 10);\n      });\n      it(\"should work with observable functions that return arrays\", function() {\n        var computedArray, item, observableArray;\n        item = Observable(\"wat\");\n        computedArray = Observable(function() {\n          return [item()];\n        });\n        observableArray = Observable.concat(computedArray, computedArray);\n        assert.equal(observableArray().length, 2);\n        assert.equal(observableArray()[1], \"wat\");\n        item(\"yolo\");\n        return assert.equal(observableArray()[1], \"yolo\");\n      });\n      it(\"should have a push method\", function() {\n        var observable, observableArray;\n        observableArray = Observable.concat();\n        observable = Observable(\"hey\");\n        observableArray.push(observable);\n        assert.equal(observableArray()[0], \"hey\");\n        observable(\"wat\");\n        assert.equal(observableArray()[0], \"wat\");\n        observableArray.push(\"cool\");\n        observableArray.push(\"radical\");\n        return assert.equal(observableArray().length, 3);\n      });\n      it(\"should be observable\", function(done) {\n        var observableArray;\n        observableArray = Observable.concat();\n        observableArray.observe(function(items) {\n          assert.equal(items.length, 3);\n          return done();\n        });\n        return observableArray.push([\"A\", \"B\", \"C\"]);\n      });\n      return it(\"should have an each method\", function() {\n        var n, observableArray;\n        observableArray = Observable.concat([\"A\", \"B\", \"C\"]);\n        n = 0;\n        observableArray.each(function() {\n          return n += 1;\n        });\n        return assert.equal(n, 3);\n      });\n    });\n    return describe(\"nesting dependencies\", function() {\n      return it(\"should update the correct observable\", function() {\n        var a, b, results;\n        a = Observable(\"a\");\n        b = Observable(\"b\");\n        results = Observable(function() {\n          var r;\n          r = Observable.concat();\n          r.push(a);\n          r.push(b);\n          return r;\n        });\n        assert.equal(results().first(), \"a\");\n        a(\"newA\");\n        return assert.equal(results().first(), \"newA\");\n      });\n    });\n  });\n\n}).call(this);\n",
              "type": "blob"
            }
          },
          "progenitor": {
            "url": "https://danielx.net/editor/"
          },
          "config": {
            "version": "0.3.8"
          },
          "version": "0.3.8",
          "entryPoint": "main",
          "repository": {
            "branch": "v0.3.8",
            "default_branch": "master",
            "full_name": "distri/observable",
            "homepage": "http://observable.us",
            "description": null,
            "html_url": "https://github.com/distri/observable",
            "url": "https://api.github.com/repos/distri/observable",
            "publishBranch": "gh-pages"
          },
          "dependencies": {}
        }
      }
    },
    "postmaster": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
          "mode": "100644",
          "type": "blob"
        },
        "README.md": {
          "path": "README.md",
          "content": "postmaster\n==========\n\nSend and receive `postMessage` commands using promises to handle the results.\n",
          "mode": "100644",
          "type": "blob"
        },
        "main.coffee": {
          "path": "main.coffee",
          "content": "###\n\nPostmaster wraps the `postMessage` API with promises.\n\n###\n\ndefaultReceiver = self\nackTimeout = 1000\n\nmodule.exports = Postmaster = (self={}) ->\n  send = (data) ->\n    target = self.remoteTarget()\n    if !Worker? or target instanceof Worker\n      target.postMessage data\n    else\n      target.postMessage data, \"*\"\n\n  dominant = Postmaster.dominant()\n  self.remoteTarget ?= -> dominant\n  self.receiver ?= -> defaultReceiver\n  self.ackTimeout ?= -> ackTimeout\n\n  self.receiver().addEventListener \"message\", (event) ->\n    # Only listening to messages from `opener`\n    if event.source is self.remoteTarget() or !event.source\n      data = event.data\n      {type, method, params, id} = data\n\n      switch type\n        when \"ack\"\n          pendingResponses[id]?.ack = true\n        when \"response\"\n          pendingResponses[id].resolve data.result\n        when \"error\"\n          pendingResponses[id].reject data.error\n        when \"message\"\n          send\n            type: \"ack\"\n            id: id\n\n          Promise.resolve()\n          .then ->\n            if typeof self[method] is \"function\"\n              self[method](params...)\n            else\n              throw new Error \"`#{method}` is not a function\"\n          .then (result) ->\n            send\n              type: \"response\"\n              id: id\n              result: result\n          .catch (error) ->\n            if typeof error is \"string\"\n              message = error\n            else\n              message = error.message\n\n            send\n              type: \"error\"\n              id: id\n              error:\n                message: message\n                stack: error.stack\n\n  pendingResponses = {}\n  remoteId = 0\n\n  self.invokeRemote = (method, params...) ->\n    id = remoteId++\n\n    send\n      type: \"message\"\n      method: method\n      params: params\n      id: id\n\n    new Promise (resolve, reject) ->\n      clear = ->\n        clearTimeout pendingResponses[id].timeout\n        delete pendingResponses[id]\n\n      ackWait = self.ackTimeout()\n      timeout = setTimeout ->\n        pendingResponse = pendingResponses[id]\n        if pendingResponse and !pendingResponse.ack\n          clear()\n          reject new Error \"No ack received within #{ackWait}\"\n      , ackWait\n\n      pendingResponses[id] =\n        timeout: timeout\n        resolve: (result) ->\n          clear()\n          resolve(result)\n        reject: (error) ->\n          clear()\n          reject(error)\n\n  return self\n\nPostmaster.dominant = ->\n  if window? # iframe or child window context\n    opener or ((parent != window) and parent) or undefined\n  else # Web Worker Context\n    self\n\nreturn Postmaster\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "version: \"0.5.0\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/postmaster.coffee": {
          "path": "test/postmaster.coffee",
          "content": "Postmaster = require \"../main\"\n\nscriptContent = ->\n  fn = ->\n    pm = Postmaster()\n    pm.echo = (value) ->\n      return value\n    pm.throws = ->\n      throw new Error(\"This always throws\")\n    pm.promiseFail = ->\n      Promise.reject new Error \"This is a failed promise\"\n\n  \"\"\"\n    var module = {};\n    Postmaster = #{PACKAGE.distribution.main.content};\n    (#{fn.toString()})();\n  \"\"\"\n\ninitWindow = (targetWindow) ->\n  targetWindow.document.write \"<script>#{scriptContent()}<\\/script>\"\n\ndescribe \"Postmaster\", ->\n  it \"should work with openened windows\", (done) ->\n    childWindow = open(\"\", null, \"width=200,height=200\")\n\n    initWindow(childWindow)\n\n    postmaster = Postmaster()\n    postmaster.remoteTarget = -> childWindow\n    postmaster.invokeRemote \"echo\", 5\n    .then (result) ->\n      assert.equal result, 5\n    .then ->\n      done()\n    , (error) ->\n      done(error)\n    .then ->\n      childWindow.close()\n\n  it \"should work with iframes\", (done) ->\n    iframe = document.createElement('iframe')\n    document.body.appendChild(iframe)\n\n    childWindow = iframe.contentWindow\n    initWindow(childWindow)\n\n    postmaster = Postmaster()\n    postmaster.remoteTarget = -> childWindow\n    postmaster.invokeRemote \"echo\", 17\n    .then (result) ->\n      assert.equal result, 17\n    .then ->\n      done()\n    , (error) ->\n      done(error)\n    .then ->\n      iframe.remove()\n\n  it \"should handle the remote call throwing errors\", (done) ->\n    iframe = document.createElement('iframe')\n    document.body.appendChild(iframe)\n\n    childWindow = iframe.contentWindow\n    initWindow(childWindow)\n\n    postmaster = Postmaster()\n    postmaster.remoteTarget = -> childWindow\n    postmaster.invokeRemote \"throws\"\n    .catch (error) ->\n      done()\n    .then ->\n      iframe.remove()\n\n  it \"should throwing a useful error when the remote doesn't define the function\", (done) ->\n    iframe = document.createElement('iframe')\n    document.body.appendChild(iframe)\n\n    childWindow = iframe.contentWindow\n    initWindow(childWindow)\n\n    postmaster = Postmaster()\n    postmaster.remoteTarget = -> childWindow\n    postmaster.invokeRemote \"someUndefinedFunction\"\n    .catch (error) ->\n      done()\n    .then ->\n      iframe.remove()\n\n  it \"should handle the remote call returning failed promises\", (done) ->\n    iframe = document.createElement('iframe')\n    document.body.appendChild(iframe)\n\n    childWindow = iframe.contentWindow\n    initWindow(childWindow)\n\n    postmaster = Postmaster()\n    postmaster.remoteTarget = -> childWindow\n    postmaster.invokeRemote \"promiseFail\"\n    .catch (error) ->\n      done()\n    .then ->\n      iframe.remove()\n\n  it \"should be able to go around the world\", (done) ->\n    iframe = document.createElement('iframe')\n    document.body.appendChild(iframe)\n\n    childWindow = iframe.contentWindow\n    initWindow(childWindow)\n\n    postmaster = Postmaster()\n    postmaster.remoteTarget = -> childWindow\n    postmaster.yolo = (txt) ->\n      \"heyy #{txt}\"\n    postmaster.invokeRemote \"invokeRemote\", \"yolo\", \"cool\"\n    .then (result) ->\n      assert.equal result, \"heyy cool\"\n    .then ->\n      done()\n    , (error) ->\n      done(error)\n    .then ->\n      iframe.remove()\n\n  it \"should work with web workers\", (done) ->\n    blob = new Blob [scriptContent()]\n    jsUrl = URL.createObjectURL(blob)\n\n    worker = new Worker(jsUrl)\n\n    base =\n      remoteTarget: -> worker\n      receiver: -> worker\n\n    postmaster = Postmaster(base)\n    postmaster.invokeRemote \"echo\", 17\n    .then (result) ->\n      assert.equal result, 17\n    .then ->\n      done()\n    , (error) ->\n      done(error)\n    .then ->\n      worker.terminate()\n\n  it \"should fail quickly when contacting a window that doesn't support Postmaster\", (done) ->\n    iframe = document.createElement('iframe')\n    document.body.appendChild(iframe)\n\n    childWindow = iframe.contentWindow\n    postmaster = Postmaster()\n    postmaster.remoteTarget = -> childWindow\n    postmaster.invokeRemote \"echo\", 5\n    .catch (e) ->\n      if e.message.match /no ack/i\n        done()\n      else\n        done(1)\n    .then ->\n      iframe.remove()\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "main": {
          "path": "main",
          "content": "\n/*\n\nPostmaster wraps the `postMessage` API with promises.\n */\n\n(function() {\n  var Postmaster, ackTimeout, defaultReceiver,\n    __slice = [].slice;\n\n  defaultReceiver = self;\n\n  ackTimeout = 1000;\n\n  module.exports = Postmaster = function(self) {\n    var dominant, pendingResponses, remoteId, send;\n    if (self == null) {\n      self = {};\n    }\n    send = function(data) {\n      var target;\n      target = self.remoteTarget();\n      if ((typeof Worker === \"undefined\" || Worker === null) || target instanceof Worker) {\n        return target.postMessage(data);\n      } else {\n        return target.postMessage(data, \"*\");\n      }\n    };\n    dominant = Postmaster.dominant();\n    if (self.remoteTarget == null) {\n      self.remoteTarget = function() {\n        return dominant;\n      };\n    }\n    if (self.receiver == null) {\n      self.receiver = function() {\n        return defaultReceiver;\n      };\n    }\n    if (self.ackTimeout == null) {\n      self.ackTimeout = function() {\n        return ackTimeout;\n      };\n    }\n    self.receiver().addEventListener(\"message\", function(event) {\n      var data, id, method, params, type, _ref;\n      if (event.source === self.remoteTarget() || !event.source) {\n        data = event.data;\n        type = data.type, method = data.method, params = data.params, id = data.id;\n        switch (type) {\n          case \"ack\":\n            return (_ref = pendingResponses[id]) != null ? _ref.ack = true : void 0;\n          case \"response\":\n            return pendingResponses[id].resolve(data.result);\n          case \"error\":\n            return pendingResponses[id].reject(data.error);\n          case \"message\":\n            send({\n              type: \"ack\",\n              id: id\n            });\n            return Promise.resolve().then(function() {\n              if (typeof self[method] === \"function\") {\n                return self[method].apply(self, params);\n              } else {\n                throw new Error(\"`\" + method + \"` is not a function\");\n              }\n            }).then(function(result) {\n              return send({\n                type: \"response\",\n                id: id,\n                result: result\n              });\n            })[\"catch\"](function(error) {\n              var message;\n              if (typeof error === \"string\") {\n                message = error;\n              } else {\n                message = error.message;\n              }\n              return send({\n                type: \"error\",\n                id: id,\n                error: {\n                  message: message,\n                  stack: error.stack\n                }\n              });\n            });\n        }\n      }\n    });\n    pendingResponses = {};\n    remoteId = 0;\n    self.invokeRemote = function() {\n      var id, method, params;\n      method = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      id = remoteId++;\n      send({\n        type: \"message\",\n        method: method,\n        params: params,\n        id: id\n      });\n      return new Promise(function(resolve, reject) {\n        var ackWait, clear, timeout;\n        clear = function() {\n          clearTimeout(pendingResponses[id].timeout);\n          return delete pendingResponses[id];\n        };\n        ackWait = self.ackTimeout();\n        timeout = setTimeout(function() {\n          var pendingResponse;\n          pendingResponse = pendingResponses[id];\n          if (pendingResponse && !pendingResponse.ack) {\n            clear();\n            return reject(new Error(\"No ack received within \" + ackWait));\n          }\n        }, ackWait);\n        return pendingResponses[id] = {\n          timeout: timeout,\n          resolve: function(result) {\n            clear();\n            return resolve(result);\n          },\n          reject: function(error) {\n            clear();\n            return reject(error);\n          }\n        };\n      });\n    };\n    return self;\n  };\n\n  Postmaster.dominant = function() {\n    if (typeof window !== \"undefined\" && window !== null) {\n      return opener || ((parent !== window) && parent) || void 0;\n    } else {\n      return self;\n    }\n  };\n\n  return Postmaster;\n\n}).call(this);\n",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"version\":\"0.5.0\"};",
          "type": "blob"
        },
        "test/postmaster": {
          "path": "test/postmaster",
          "content": "(function() {\n  var Postmaster, initWindow, scriptContent;\n\n  Postmaster = require(\"../main\");\n\n  scriptContent = function() {\n    var fn;\n    fn = function() {\n      var pm;\n      pm = Postmaster();\n      pm.echo = function(value) {\n        return value;\n      };\n      pm.throws = function() {\n        throw new Error(\"This always throws\");\n      };\n      return pm.promiseFail = function() {\n        return Promise.reject(new Error(\"This is a failed promise\"));\n      };\n    };\n    return \"var module = {};\\nPostmaster = \" + PACKAGE.distribution.main.content + \";\\n(\" + (fn.toString()) + \")();\";\n  };\n\n  initWindow = function(targetWindow) {\n    return targetWindow.document.write(\"<script>\" + (scriptContent()) + \"<\\/script>\");\n  };\n\n  describe(\"Postmaster\", function() {\n    it(\"should work with openened windows\", function(done) {\n      var childWindow, postmaster;\n      childWindow = open(\"\", null, \"width=200,height=200\");\n      initWindow(childWindow);\n      postmaster = Postmaster();\n      postmaster.remoteTarget = function() {\n        return childWindow;\n      };\n      return postmaster.invokeRemote(\"echo\", 5).then(function(result) {\n        return assert.equal(result, 5);\n      }).then(function() {\n        return done();\n      }, function(error) {\n        return done(error);\n      }).then(function() {\n        return childWindow.close();\n      });\n    });\n    it(\"should work with iframes\", function(done) {\n      var childWindow, iframe, postmaster;\n      iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      childWindow = iframe.contentWindow;\n      initWindow(childWindow);\n      postmaster = Postmaster();\n      postmaster.remoteTarget = function() {\n        return childWindow;\n      };\n      return postmaster.invokeRemote(\"echo\", 17).then(function(result) {\n        return assert.equal(result, 17);\n      }).then(function() {\n        return done();\n      }, function(error) {\n        return done(error);\n      }).then(function() {\n        return iframe.remove();\n      });\n    });\n    it(\"should handle the remote call throwing errors\", function(done) {\n      var childWindow, iframe, postmaster;\n      iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      childWindow = iframe.contentWindow;\n      initWindow(childWindow);\n      postmaster = Postmaster();\n      postmaster.remoteTarget = function() {\n        return childWindow;\n      };\n      return postmaster.invokeRemote(\"throws\")[\"catch\"](function(error) {\n        return done();\n      }).then(function() {\n        return iframe.remove();\n      });\n    });\n    it(\"should throwing a useful error when the remote doesn't define the function\", function(done) {\n      var childWindow, iframe, postmaster;\n      iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      childWindow = iframe.contentWindow;\n      initWindow(childWindow);\n      postmaster = Postmaster();\n      postmaster.remoteTarget = function() {\n        return childWindow;\n      };\n      return postmaster.invokeRemote(\"someUndefinedFunction\")[\"catch\"](function(error) {\n        return done();\n      }).then(function() {\n        return iframe.remove();\n      });\n    });\n    it(\"should handle the remote call returning failed promises\", function(done) {\n      var childWindow, iframe, postmaster;\n      iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      childWindow = iframe.contentWindow;\n      initWindow(childWindow);\n      postmaster = Postmaster();\n      postmaster.remoteTarget = function() {\n        return childWindow;\n      };\n      return postmaster.invokeRemote(\"promiseFail\")[\"catch\"](function(error) {\n        return done();\n      }).then(function() {\n        return iframe.remove();\n      });\n    });\n    it(\"should be able to go around the world\", function(done) {\n      var childWindow, iframe, postmaster;\n      iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      childWindow = iframe.contentWindow;\n      initWindow(childWindow);\n      postmaster = Postmaster();\n      postmaster.remoteTarget = function() {\n        return childWindow;\n      };\n      postmaster.yolo = function(txt) {\n        return \"heyy \" + txt;\n      };\n      return postmaster.invokeRemote(\"invokeRemote\", \"yolo\", \"cool\").then(function(result) {\n        return assert.equal(result, \"heyy cool\");\n      }).then(function() {\n        return done();\n      }, function(error) {\n        return done(error);\n      }).then(function() {\n        return iframe.remove();\n      });\n    });\n    it(\"should work with web workers\", function(done) {\n      var base, blob, jsUrl, postmaster, worker;\n      blob = new Blob([scriptContent()]);\n      jsUrl = URL.createObjectURL(blob);\n      worker = new Worker(jsUrl);\n      base = {\n        remoteTarget: function() {\n          return worker;\n        },\n        receiver: function() {\n          return worker;\n        }\n      };\n      postmaster = Postmaster(base);\n      return postmaster.invokeRemote(\"echo\", 17).then(function(result) {\n        return assert.equal(result, 17);\n      }).then(function() {\n        return done();\n      }, function(error) {\n        return done(error);\n      }).then(function() {\n        return worker.terminate();\n      });\n    });\n    return it(\"should fail quickly when contacting a window that doesn't support Postmaster\", function(done) {\n      var childWindow, iframe, postmaster;\n      iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      childWindow = iframe.contentWindow;\n      postmaster = Postmaster();\n      postmaster.remoteTarget = function() {\n        return childWindow;\n      };\n      return postmaster.invokeRemote(\"echo\", 5)[\"catch\"](function(e) {\n        if (e.message.match(/no ack/i)) {\n          return done();\n        } else {\n          return done(1);\n        }\n      }).then(function() {\n        return iframe.remove();\n      });\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "https://danielx.net/editor/"
      },
      "version": "0.5.0",
      "entryPoint": "main",
      "repository": {
        "branch": "v0.5.0",
        "default_branch": "master",
        "full_name": "distri/postmaster",
        "homepage": null,
        "description": "Send and receive postMessage commands.",
        "html_url": "https://github.com/distri/postmaster",
        "url": "https://api.github.com/repos/distri/postmaster",
        "publishBranch": "gh-pages"
      },
      "dependencies": {}
    },
    "ui": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "content": "MIT License\n\nCopyright (c) 2016 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
          "mode": "100644",
          "type": "blob"
        },
        "NOTES.md": {
          "path": "NOTES.md",
          "content": "Notes\n=====\n\nWrapping simple promise returning handlers around the modal should make it easy\nto prompt.\n",
          "mode": "100644",
          "type": "blob"
        },
        "README.md": {
          "path": "README.md",
          "content": "UI\n===\n\nArtisanal User Interface\n\nMenus\n-----\n\n- Context Menu\n- Menu Bar\n- Nested submenus\n\nSimple DSL for creating menus and binding to handlers.\n\n```\n{ContextMenu} = require \"ui\"\n\ncontextMenu = ContextMenu()\ndocument.body.appendChild contextMenu.element\n```\n\nModals\n------\n\n- Alert\n- Confirm\n- Prompt\n\nPromise returning prompts, confirms, etc.\n\nActions\n-------\n\nHotkeys, help text, icons, enabled/disabled states.\n\nZ-Indexes\n---------\n\nIs there a sane way to do z-indexes? Right now I'm just listing them.\n\nModal: 1000\nContext Menu: 2000\n",
          "mode": "100644",
          "type": "blob"
        },
        "TODO.md": {
          "path": "TODO.md",
          "content": "TODO\n====\n\nModals\n  Alert\n  Prompt\n  Confirm\n  General\n\nMenus\n  Menu Bar\n  Context Menu\n  Keyboard Navigation (Up, Down, Left, Right)\n  Accelerator Keys\n  Display Hotkeys\n  Indicate Enabled/Disabled\n  Nested Submenus\n\nToaster/Popup Notifications\n  Animations\n  Native notifications?\n\nGlobal Hotkeys\n\nLoader / Progress\n\nDocumentation\n  Modals\n  Menus\n  Context Menus\n  Hotkeys\n  Windows\n\nExamples\n  Modal Progress Bar\n\nWindows\n  Draggable\n  Resizable (Need to add invisible overlay when moving the mouse so iframes don't jank up the resize)\n  Close\n  Maximize\n  Z-Index\n  Option Menu\n\nTOMAYBE\n=======\n\nTile Windows\n\nForms\n\nTables/Grids\n\nLists\n\nFile Trees\n",
          "mode": "100644",
          "type": "blob"
        },
        "action.coffee": {
          "path": "action.coffee",
          "content": "###\nAction\n======\n\nActions have a function to call, a hotkey, and a function that determines\nwhether or not they are disabled. This is so we can present them in the UI for\nmenus.\n\nThe hotkey is for display purposes only and needs to be listened to by a\nseparate mechanism to perform. [TODO] The action can be executed like a regular\nfunction (instead of needing to use call).\n\nActions may have icons and help text as well.\n\n###\n\nObservable = require \"observable\"\n\n# TODO: This is just a test for toggling disabled state\nmodule.exports = (fn, hotkey) ->\n  disabled = Observable false\n  setInterval ->\n    disabled.toggle()\n  , 1000\n\n  disabled: disabled\n  hotkey: ->\n    hotkey\n  call: (args...) ->\n    fn.call(args...)\n",
          "mode": "100644",
          "type": "blob"
        },
        "demo.coffee": {
          "path": "demo.coffee",
          "content": "{ContextMenu, MenuBar, Modal, Observable, Util:{parseMenu}, Progress, Style, Table, Window} = require \"./export\"\n\n{o} = require \"./util\"\n\nnotepadMenuText = require \"./samples/notepad-menu\"\nnotepadMenuParsed = parseMenu notepadMenuText\n\nFormSampleTemplate = require \"./samples/test-form\"\n\nstyle = document.createElement \"style\"\nstyle.innerHTML = Style.all\ndocument.head.appendChild style\n\nsampleMenuParsed = parseMenu \"\"\"\n  [M]odal\n    [A]lert\n    [C]onfirm\n    [P]rompt\n    [F]orm\n    P[r]ogress\n  [T]est Nesting\n    Test[1]\n      Hello\n      Wat\n    Test[2]\n      [N]ested\n      [R]ad\n        So Rad\n        Hella\n          Hecka\n            Super Hecka\n              Wicked\n  [W]indow\n    New [I]mage -> newImage\n    New [P]ixel -> newPixel\n    New [T]ext -> newText\n    New [S]preadsheet -> newSheet\n\"\"\"\n{element} = MenuBar\n  items: sampleMenuParsed,\n  handlers:\n    alert: ->\n      Modal.alert \"yolo\"\n    prompt: ->\n      Modal.prompt \"Pretty cool, eh?\", \"Yeah!\"\n      .then console.log\n    confirm: ->\n      Modal.confirm \"Jawsome!\"\n      .then console.log\n    form: ->\n      Modal.form FormSampleTemplate()\n      .then console.log\n    progress: ->\n      initialMessage = \"Reticulating splines\"\n      progressView = Progress\n        value: 0\n        max: 2\n        message: initialMessage\n\n      Modal.show progressView.element,\n        cancellable: false\n\n      intervalId = setInterval ->\n        newValue = progressView.value() + 1/60\n        ellipsesCount = Math.floor(newValue * 4) % 4\n        ellipses = [0...ellipsesCount].map ->\n          \".\"\n        .join(\"\")\n        progressView.value(newValue)\n        progressView.message(initialMessage + ellipses)\n        if newValue > 2\n          clearInterval intervalId\n          Modal.hide()\n      , 15\n    newImage: ->\n      img = document.createElement \"img\"\n      img.src = \"https://s3.amazonaws.com/whimsyspace-databucket-1g3p6d9lcl6x1/danielx/data/pI1mvEvxcXJk4mNHNUW-kZsNJsrPDXcAtgguyYETRXQ\"\n\n      addWindow\n        title: \"Yoo\"\n        content: img\n\n    newPixel: ->\n      frame = document.createElement \"iframe\"\n      frame.src = \"https://danielx.net/pixel-editor/embedded/\"\n\n      addWindow\n        title: \"Pixel\"\n        content: frame\n\n    newText: ->\n      textarea = document.createElement \"textarea\"\n\n      addWindow\n        title: \"Notepad.exe\"\n        content: textarea\n\n    newSheet: ->\n      data = [0...5].map (i) ->\n        id: i\n        name: \"yolo\"\n        color: \"#FF0000\"\n\n      InputTemplate = require \"./templates/input\"\n      RowElement = (datum) ->\n        tr = document.createElement \"tr\"\n        types = [\n          \"number\"\n          \"text\"\n          \"color\"\n        ]\n\n        Object.keys(datum).forEach (key, i) ->\n          td = document.createElement \"td\"\n          td.appendChild InputTemplate\n            value: o datum, key\n            type: types[i]\n\n          tr.appendChild td\n\n        return tr\n\n      {element} = tableView = Table {\n        data\n        RowElement\n      }\n\n      menuBar = MenuBar\n        items: parseMenu \"\"\"\n          Insert\n            Row -> insertRow\n          Help\n            About\n        \"\"\"\n        handlers:\n          about: ->\n            Modal.alert \"Spreadsheet v0.0.1 by Daniel X Moore\"\n          insertRow: ->\n            data.push\n              id: 50\n              name: \"new\"\n              color: \"#FF00FF\"\n\n            tableView.render()\n\n      addWindow\n        title: \"Spreadsheet [DEMO VERSION]\"\n        content: element\n        menuBar: menuBar.element\n\ndocument.body.appendChild element\n\ndesktop = document.createElement \"desktop\"\ndocument.body.appendChild desktop\n\ncontextMenu = ContextMenu\n  items: sampleMenuParsed[1][1]\n  handlers: {}\n\ndesktop.addEventListener \"contextmenu\", (e) ->\n  if e.target is desktop\n    e.preventDefault()\n\n    contextMenu.display\n      inElement: document.body\n      x: e.pageX\n      y: e.pageY\n\naddWindow = ({title, menuBar, content}) ->\n  menuBar ?= MenuBar(items: notepadMenuParsed, handlers: {}).element\n  title ?= \"Hello\"\n\n  windowView = Window\n    title: title\n    menuBar: menuBar\n    content: content\n\n  desktop.appendChild windowView.element\n\n  return windowView\n",
          "mode": "100644",
          "type": "blob"
        },
        "export.coffee": {
          "path": "export.coffee",
          "content": "Action = require \"./action\"\nContextMenuView = require \"./views/context-menu\"\nModal = require \"./modal\"\nMenuView = require \"./views/menu\"\nMenuBarView = require \"./views/menu-bar\"\nMenuItemView = require \"./views/menu-item\"\nObservable = require \"observable\"\nProgressView = require \"./views/progress\"\nStyle = require \"./style\"\nTableView = require \"./views/table\"\nWindowView = require \"./views/window\"\n\nmodule.exports = {\n  Action: Action\n  Bindable: require \"bindable\"\n  ContextMenu: ContextMenuView\n  Modal\n  Menu: MenuView\n  MenuBar: MenuBarView\n  MenuItem: MenuItemView\n  Observable: Observable\n  Progress: ProgressView\n  Style\n  Table: TableView\n  Util:\n    parseMenu: require \"./lib/indent-parse\"\n  Window: WindowView\n}\n",
          "mode": "100644",
          "type": "blob"
        },
        "hotkeys.coffee": {
          "path": "hotkeys.coffee",
          "content": "###\nHotkeys\n=======\n\nBind hotkeys\n\n    Hotkey = require \"hotkey\"\n\n    Hotkey \"ctrl+r\", ->\n      alert \"radical!\"\n\nWe'd like to be able to generate a list of hotkeys with descriptions.\n\nQuestions\n---------\n\nShould we just use Mousetrap?\n\nMaybe, but it may have different semantics with preventDefault/defaultPrevented.\n\nShould we allow binding to specific elements?\n\nImagine a windowing OS where non-iframe apps are inside draggable windows. We'd\nlike to have each 'app' able to have its own hotkeys and at the same time have\nglobal OS level hotkeys.\n\nShould `defaultPrevented` prevent executing the hotkey action? Yes\n\nShould executing a hotkey preventDefault? Yes\n\n###\n\n# TODO: This is just a rough outline\nmodule.exports = (element) ->\n  handlers = {}\n\n  handle = (event) ->\n    {key} = event\n\n    modifiersActive = [\"alt\", \"ctrl\", \"meta\", \"shift\"].filter (modifier) ->\n      event[\"#{modifier}Key\"]\n\n    combo = modifiersActive.concat(key).join(\"+\")\n\n    # TODO: Don't trigger \"plain\" events in input/text fields\n\n    handlers[combo]?(e)\n",
          "mode": "100644",
          "type": "blob"
        },
        "lib/assert.coffee": {
          "path": "lib/assert.coffee",
          "content": "module.exports = (condition, message) ->\n  throw new Error message unless condition\n",
          "mode": "100644",
          "type": "blob"
        },
        "lib/indent-parse.coffee": {
          "path": "lib/indent-parse.coffee",
          "content": "top = (stack) ->\n  stack[stack.length - 1]\n\nparse = (source) ->\n  stack = [[]]\n  indentation = /^(  )*/\n  depth = 0\n\n  source.split(\"\\n\").forEach (line, lineNumber) ->\n    match = line.match(indentation)[0]\n    text = line.replace(match, \"\")\n    newDepth = match.length / 2\n\n    return unless text.trim().length\n    current = text\n\n    if newDepth > depth\n      unless newDepth is depth + 1\n        throw new Error \"Unexpected indentation on line #{lineNumber}\"\n      # We're one level further in\n      # Convert the simple string to a [label, items] pair\n      items = []\n      prev = top(stack)\n      prev.push [prev.pop(), items]\n      stack.push items\n    else if newDepth < depth\n      # Pop stack to correct depth\n      stack = stack.slice(0, newDepth + 1)\n\n    depth = newDepth\n\n    top(stack).push current\n\n  return stack[0]\n\nmodule.exports = parse\n",
          "mode": "100644",
          "type": "blob"
        },
        "main.coffee": {
          "path": "main.coffee",
          "content": "if PACKAGE.name is \"ROOT\"\n  require \"./demo\"\nelse\n  module.exports = require \"./export\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "modal.coffee": {
          "path": "modal.coffee",
          "content": "###\nModal\n\nDisplay modal alerts or dialogs.\n\nModal has promise returning equivalents of the native browser:\n\n- Alert\n- Confirm\n- Prompt\n\nThese accept the same arguments and return a promise fulfilled with\nthe same return value as the native methods.\n\nYou can display any element in the modal:\n\n    modal.show myElement\n\n###\n\n{formDataToObject, handle, empty} = require \"./util\"\n\nPromptTemplate = require \"./templates/modal/prompt\"\nModalTemplate = require \"./templates/modal\"\n\nmodal = ModalTemplate()\n\ncancellable = true\nmodal.onclick = (e) ->\n  if e.target is modal and cancellable\n    Modal.hide()\n\ndocument.addEventListener \"keydown\", (e) ->\n  unless e.defaultPrevented\n    if e.key is \"Escape\" and cancellable\n      e.preventDefault()\n      Modal.hide()\n\ndocument.body.appendChild modal\n\ncloseHandler = null\n\nprompt = (params) ->\n  new Promise (resolve) ->\n    element = PromptTemplate params\n\n    Modal.show element,\n      cancellable: false\n      closeHandler: resolve\n    element.querySelector(params.focus)?.focus()\n\nmodule.exports = Modal =\n  show: (element, options) ->\n    if typeof options is \"function\"\n      closeHandler = options\n    else\n      closeHandler = options?.closeHandler\n      if options?.cancellable?\n        cancellable = options.cancellable\n\n    empty(modal).appendChild(element)\n    modal.classList.add \"active\"\n\n  hide: (dataForHandler) ->\n    closeHandler?(dataForHandler)\n    modal.classList.remove \"active\"\n    cancellable = true\n    empty(modal)\n\n  alert: (message) ->\n    prompt\n      title: \"Alert\"\n      message: message\n      focus: \"button\"\n      confirm: handle ->\n        Modal.hide()\n\n  prompt: (message, defaultValue=\"\") ->\n    prompt\n      title: \"Prompt\"\n      message: message\n      focus: \"input\"\n      defaultValue: defaultValue\n      cancel: handle ->\n        Modal.hide(null)\n      confirm: handle ->\n        Modal.hide modal.querySelector(\"input\").value\n\n  confirm: (message) ->\n    prompt\n      title: \"Confirm\"\n      message: message\n      focus: \"button\"\n      cancel: handle ->\n        Modal.hide(false)\n      confirm: handle ->\n        Modal.hide(true)\n\n  form: (formElement) ->\n    new Promise (resolve) ->\n      submitHandler = handle (e) ->\n        formData = new FormData(formElement)\n        result = formDataToObject(formData)\n        Modal.hide(result)\n\n      formElement.addEventListener \"submit\", submitHandler\n\n      Modal.show formElement, (result) ->\n        formElement.removeEventListener \"submit\", submitHandler\n        resolve(result)\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "version: \"0.1.2\"\nentryPoint: \"main\"\nremoteDependencies: [\n]\ndependencies:\n  observable: \"distri/observable:master\"\n  bindable: \"distri/bindable:master\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "samples/notepad-menu.coffee": {
          "path": "samples/notepad-menu.coffee",
          "content": "module.exports = \"\"\"\n  [F]ile\n    [N]ew\n    [O]pen\n    [S]ave\n    Save [A]s\n    -\n    Page Set[u]p\n    [P]rint\n    -\n    E[x]it\n  [E]dit\n    [U]ndo\n    Redo\n    -\n    Cu[t]\n    [C]opy\n    [P]aste\n    De[l]ete\n    -\n    [F]ind\n    Find [N]ext\n    [R]eplace\n    [G]o To\n    -\n    Select [A]ll\n    Time/[D]ate\n  F[o]rmat\n    [W]ord Wrap\n    [F]ont...\n  [V]iew\n    [S]tatus Bar\n  [H]elp\n    View [H]elp\n    -\n    [A]bout Notepad\n\"\"\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "samples/test-form.jadelet": {
          "path": "samples/test-form.jadelet",
          "content": "form\n  h1 Cool Form Bro\n  p\n    a(href=\"https://yolo.biz\") Yolo\n  input(name=\"yolo\")\n  input(name=\"x\" value=\"Lorem\")\n  input(name=\"y\" value=\"florem\")\n  input(name=\"z\" type=\"number\" value=5)\n  input(name=\"file\" type=\"file\")\n  textarea(name=\"text\")\n  button Submit\n",
          "mode": "100644",
          "type": "blob"
        },
        "style.coffee": {
          "path": "style.coffee",
          "content": "styles = {}\n\nall = \"\"\"\n  main\n  loader\n  menu\n  modal\n  table\n  window\n\"\"\".split(\"\\n\").map (stylePath) ->\n  content = require \"./style/#{stylePath}\"\n  styles[stylePath] = content\n\n  return content\n.join(\"\\n\")\n\nstyles.all = all\n\nmodule.exports = styles\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/loader.styl": {
          "path": "style/loader.styl",
          "content": "// Loader\nloader\n  display: block\n  padding: 1em\n\n  > p:empty\n    margin: 0\n\n  > progress\n    display: block\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/main.styl": {
          "path": "style/main.styl",
          "content": "*\n  box-sizing: border-box\n\nbody\n  display: flex\n  flex-direction: column\n  font-family: Sans-Serif\n  font-size: 14px\n  line-height: 18px\n  margin: 0\n\nbody, html\n  height: 100%\n\ninput, textarea, keygen, select, button\n  font-size: inherit\n  font-family: inherit\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/menu.styl": {
          "path": "style/menu.styl",
          "content": "// Menus\nno-select()\n  user-select: none\n  -moz-user-select: none\n  -webkit-user-select: none\n  -ms-user-select: none\n\nmenu\n  no-select()\n\n  background-color: lightgrey\n  border-bottom: 1px solid rgba(0, 0, 0, 0.5)\n  margin: 0\n  z-index: 1\n\n  &:focus\n    outline: none\n\nmenu.context\n  z-index: 2000\n\nmenu-item\n  display: block\n  list-style-type: none\n\n  &.active\n    background-color: #000080\n    color: white\n\n  > label\n    display: flex\n    padding: 0 0.25em\n    white-space: nowrap\n\n    > *\n      flex: 1 1 auto\n\n    > span.hotkey\n      margin-left: 1em\n\n      &:empty\n        margin-left: 0\n\n    > .decoration\n      flex: 0 1 auto\n      line-height: 1em\n      text-align: right\n      margin-left: 0.5em\n\n      &:empty\n        margin-left: 0\n\n  &[disabled]\n    color: gray\n\n    &.active\n      background-color: rgba(0, 0, 0, 0.125)\n\nmenu.options\n  border-top: 1px solid rgba(255, 255, 255, 0.5)\n  border-left: 1px solid rgba(255, 255, 255, 0.5)\n  border-right: 1px solid rgba(0, 0, 0, 0.5)\n\n  box-shadow: 2px 2px 1px rgba(0, 0, 0, 0.5)\n\n  display: none\n\n  padding: 2px\n  padding-bottom: 3px\n  position: absolute\n\n  &.active\n    display: block\n\n  // Submenu\n  > menu-item.menu\n    position: relative\n\n    > menu\n      position: absolute\n      left: 100%\n      top: -3px\n      margin-left: 1px\n\nmenu-item.menu.active\n  > menu\n    background-color: lightgrey\n    color: black\n    display: block\n\nmenu.bar\n  display: block\n  flex: 0 0 auto\n  margin: 0\n  padding: 0\n  position: initial\n  white-space: nowrap\n  overflow: hidden\n\n  > menu-item\n    display: inline-block\n    > label > .decoration\n      display: none\n\n  &.accelerator-active\n    span.accelerator\n      text-decoration: underline\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/modal.styl": {
          "path": "style/modal.styl",
          "content": "#modal\n  align-items: center\n  background-color: rgba(0, 0, 0, 0.25)\n  display: none\n  justify-content: center\n  position: absolute\n  z-index: 1000\n  top: 0\n  width: 100%\n  height: 100%\n\n  &.active\n    display: flex\n\n  > *\n    background-color: white\n    border: 1px solid rgba(0, 0, 0, 0.5)\n    box-shadow: 2px 2px 6px rgb(0, 0, 0, 0.5)\n    max-width: 90%\n    max-height: 90%\n\n  > form\n    display: block\n    padding: 1em\n\n    > h1\n      font-size: 1.5em\n      margin: 0\n\n    > input, textarea\n      display: block\n      margin-bottom: 1em\n      width: 100%\n\n    > button\n      margin-right: 1em\n      &:last-child\n        margin-right: 0\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/table.styl": {
          "path": "style/table.styl",
          "content": "container\n  display: block\n  height: 100%\n  overflow: auto\n  width: 100%\n\ntable\n  border-collapse: collapse\n  width: 100%\n\nth\n  text-align: left\n\nthead\n  border-bottom: 1px solid black\n\ntd > input\n  border: none\n  background-color: transparent\n  width: 100%\n  height: 100%\n  padding: 0\n\ntr:nth-child(even)\n  background-color: #EEE\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/window.styl": {
          "path": "style/window.styl",
          "content": "no-select()\n  user-select: none\n  -moz-user-select: none\n  -webkit-user-select: none\n  -ms-user-select: none\n\ndesktop\n  no-select()\n\n  display: block\n  flex: 1 0 auto\n\nwindow\n  no-select()\n\n  background-color: lightgrey\n  border: 4px double black\n  display: flex\n  flex-direction: column\n  position: absolute\n\n  > header\n    border-bottom: 1px solid black\n    cursor: default\n    display: flex\n    flex: 0 0 auto\n\n    > close, > control\n      color: white\n      display: inline-block\n      flex: 0 0 auto\n      font-family: monospace\n      width: 18px\n      text-shadow: 1px 0px 0px #000, -1px 0px 0px #000, 0px -1px 0px #000, 0px 1px 0px #000, 1px 1px 0px #808080\n      text-align: center\n\n    > title-bar\n      background-color: #000080\n      border-color: black\n      border-style: solid\n      border-width: 0 1px\n      color: white\n      display: inline-block\n      flex: 1 1 auto\n      overflow: hidden\n      padding: 0 2px\n      text-align: center\n      text-overflow: ellipsis\n      white-space: nowrap\n\n  > viewport\n    background-color: white\n    display: flex\n    height: 100%\n    overflow: auto\n    position: relative\n    z-index: 0\n\n    > *\n      margin: auto\n\n    > textarea\n      font-family: monospace\n      height: 100%\n      resize: none\n      width: 100%\n\n    > iframe\n      border: none\n      height: 100%\n      width: 100%\n      position: absolute\n\n  > resize\n    display: block\n    position: absolute\n\n    &.e, &.w\n      cursor: ew-resize\n\n    &.n, &.s\n      cursor: ns-resize\n\n    &.h\n      height: 4px\n      width: 100%\n\n    &.v\n      height: 100%\n      width: 4px\n\n    &.w\n      left: -4px\n    &.e\n      right: -4px\n    &.n\n      top: -4px\n    &.s\n      bottom: -4px\n\n    &.n.w\n      cursor: nw-resize\n\n    &.n.e\n      cursor: ne-resize\n\n    &.s.e\n      cursor: se-resize\n\n    &.s.w\n      cursor: sw-resize\n\n    &.n.v\n      height: 23px\n      border-bottom: 1px solid black\n\n    &.s.v\n      height: 23px\n      border-top: 1px solid black\n\n    &.e.h\n      border-left: 1px solid black\n      width: 23px\n\n    &.w.h\n      border-right: 1px solid black\n      width: 23px\n\nframe-guard\n  display: block\n  height: 100%\n  pointer-events: none\n  position: absolute\n  width: 100%\n  z-index: 100000\n\n  &.active\n    pointer-events: auto\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/input.jadelet": {
          "path": "templates/input.jadelet",
          "content": "input(@value @type)\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/menu-item.jadelet": {
          "path": "templates/menu-item.jadelet",
          "content": "menu-item(@class @click @mousemove @disabled)\n  label\n    = @title\n    span.hotkey= @hotkey\n    span.decoration= @decoration\n  = @content\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/menu-separator.jadelet": {
          "path": "templates/menu-separator.jadelet",
          "content": "menu-item\n  hr\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/menu.jadelet": {
          "path": "templates/menu.jadelet",
          "content": "menu(@class @click @style)= @items\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/modal.jadelet": {
          "path": "templates/modal.jadelet",
          "content": "#modal\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/modal/prompt.jadelet": {
          "path": "templates/modal/prompt.jadelet",
          "content": "form(submit=@confirm tabindex=-1)\n  h1= @title\n  p= @message\n  - if @defaultValue?\n    input(type=\"text\" value=@defaultValue)\n  button OK\n  - if @cancel\n    button(click=@cancel) Cancel\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/progress.jadelet": {
          "path": "templates/progress.jadelet",
          "content": "loader\n  p= @message\n  progress(@class @value @max)\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/table.jadelet": {
          "path": "templates/table.jadelet",
          "content": "container\n  table(@keydown)\n    thead\n      tr\n        - @headers.forEach (header) ->\n          th= header\n    tbody\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/window.jadelet": {
          "path": "templates/window.jadelet",
          "content": "window\n  resize.n.h\n  resize.e.v\n  resize.s.h\n  resize.w.v\n  resize.n.e.h\n  resize.n.e.v\n  resize.n.w.h\n  resize.n.w.v\n  resize.s.e.h\n  resize.s.e.v\n  resize.s.w.h\n  resize.s.w.v\n  header\n    control -\n    title-bar= @title\n    close(click=@close) X\n  = @menuBar\n  viewport\n    = @content\n\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/menu.coffee": {
          "path": "test/menu.coffee",
          "content": "parse = require \"../lib/indent-parse\"\n\ndescribe \"Menu Parser\", ->\n  it \"should parse menus into lists\", ->\n    data = \"\"\"\n      File\n    \"\"\"\n\n    results = parse(data)\n    assert.deepEqual [\"File\"], results\n\n  it \"should parse empty\", ->\n    data = \"\"\"\n    \"\"\"\n\n    assert.deepEqual [], parse(data)\n\n  it \"should deal with nesting ok\", ->\n    data = \"\"\"\n      File\n        Open\n        Save\n      Edit\n        Copy\n        Paste\n      Help\n    \"\"\"\n\n    results = parse(data)\n    assert.deepEqual [\n      [\"File\", [\"Open\", \"Save\"]]\n      [\"Edit\", [\"Copy\", \"Paste\"]]\n      \"Help\"\n    ], results\n\n  it \"should parse big ol' menus\", ->\n    results = parse \"\"\"\n      File\n        New\n        Open\n        Save\n        Save As\n      Edit\n        Undo\n        Redo\n        -\n        Cut\n        Copy\n        Paste\n        Delete\n        -\n        Find\n        Find Next\n        Replace\n        Go To\n        -\n        Select All\n        Time/Date\n      Format\n        Word Wrap\n        Font...\n      View\n        Status Bar\n      Help\n        View Help\n        -\n        About Notepad\n    \"\"\"\n\n    assert.deepEqual [\n      [\"File\", [\"New\", \"Open\", \"Save\", \"Save As\"]]\n      [\"Edit\", [\"Undo\", \"Redo\", \"-\", \"Cut\", \"Copy\", \"Paste\", \"Delete\", \"-\", \"Find\", \"Find Next\", \"Replace\", \"Go To\", \"-\", \"Select All\", \"Time/Date\"]]\n      [\"Format\", [\"Word Wrap\", \"Font...\"]]\n      [\"View\", [\"Status Bar\"]]\n      [\"Help\", [\"View Help\", \"-\", \"About Notepad\"]]\n    ], results\n\n  it \"should parse hella nested menus\", ->\n    results = parse \"\"\"\n      File\n        Special\n          Nested\n            Super\n              Awesome\n    \"\"\"\n\n    assert.deepEqual [\n      [\"File\", [\n        [\"Special\", [\n          [\"Nested\", [\n            [\"Super\", [\n              \"Awesome\"\n            ]]\n          ]]\n        ]]\n      ]]\n    ], results\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/modal.coffee": {
          "path": "test/modal.coffee",
          "content": "PACKAGE.name = \"test\"\n\n{Modal} = require \"../main\"\n\ndescribe \"Modal\", ->\n  it \"shoud be totally chill\", ->\n    element = document.createElement \"p\"\n\n    called = false\n    handler = (value) ->\n      called = true\n      assert.equal value, \"yolo\"\n\n    Modal.show(element, handler)\n    Modal.hide('yolo')\n\n    assert called\n",
          "mode": "100644",
          "type": "blob"
        },
        "util.coffee": {
          "path": "util.coffee",
          "content": "Observable = require \"observable\"\n\nA = (attr) ->\n  (x) -> x[attr]\n\nF = (methodName) ->\n  (x) -> x[methodName]()\n\n# Observable attribute helper\no = (object, name) ->\n  attribute = Observable(object[name])\n\n  attribute.observe (newValue) ->\n    object[name] = newValue\n\n  return attribute\n\n# Handle events by preventing the default action\nhandle = (fn) ->\n  (e) ->\n    return if e?.defaultPrevented\n    e?.preventDefault()\n    fn.call(this, e)\n\n# I hope I don't hate myself for this later\n# S for Safe invoke, invoke the method of the object, if it exists and is a\n# function, otherwise return the provided default value\nS = (object, method, defaultValue) ->\n  ->\n    if typeof object?[method] is 'function'\n      object[method]()\n    else\n      defaultValue\n\nasElement = A('element')\n\naccelerateItem = (items, key) ->\n  [acceleratedItem] = items.filter (item) ->\n    item.accelerator is key\n\n  if acceleratedItem\n    # TODO: should there be some kind of exec rather than click action?\n    acceleratedItem.click()\n\nisDescendant = (element, ancestor) ->\n  return unless element\n\n  while (parent = element.parentElement)\n    return true if element is ancestor\n    element = parent\n\nadvance = (list, amount) ->\n  [currentItem] = list.filter (item) ->\n    item.active()\n\n  activeItemIndex = list.indexOf(currentItem) + amount\n\n  if activeItemIndex < 0\n    activeItemIndex = list.length - 1\n  else if activeItemIndex >= list.length\n    activeItemIndex = 0\n\n  list[activeItemIndex]\n\n# TODO: Nested objects?\n# TODO: Convert keys ending in [] to array entries?\n# Just keeping it simple and crushing duplicate names\nformDataToObject = (formData) ->\n  Array.from(formData.entries()).reduce (object, [key, value]) ->\n    object[key] = value\n\n    object\n  , {}\n\n# Get the view associated with a dom element\n# This will let us use the dom tree rather than manage a separate tree\n# to dispatch events at the view level\n# the assumption is that a .view property is written to the root element in the\n# view when rendering a view's template element\nelementView = (element) ->\n  return unless element\n  return element.view if element.view\n  elementView element.parentElement\n\n# Remove all children from a dom node\nempty = (node) ->\n  while node.hasChildNodes()\n    node.removeChild(node.lastChild)\n\n  return node\n\nmodule.exports =\n  htmlEscape: (string) ->\n    String(string).replace /[&<>\"'\\/]/g, (s) ->\n      entityMap[s]\n\n  A: A\n  F: F\n  S: S\n  o: o\n\n  advance: advance\n  asElement: asElement\n  accelerateItem: accelerateItem\n  elementView: elementView\n  empty: empty\n  formDataToObject: formDataToObject\n  handle: handle\n  isDescendant: isDescendant\n\nentityMap =\n  \"&\": \"&amp;\"\n  \"<\": \"&lt;\"\n  \">\": \"&gt;\"\n  '\"': '&quot;'\n  \"'\": '&#39;'\n  \"/\": '&#x2F;'\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/context-menu.coffee": {
          "path": "views/context-menu.coffee",
          "content": "###\nContextMenu\n\nDisplay a context menu!\n\nQuestions:\n\nShould we be able to update the options in the menu after creation?\n\n###\n\n\nObservable = require \"observable\"\n\nMenuView = require \"./menu\"\n\n{isDescendant} = require \"../util\"\n\nmodule.exports = ({items, handlers}) ->\n  activeItem = Observable null\n  top = Observable \"\"\n  left = Observable \"\"\n\n  contextRoot =\n    activeItem: activeItem\n    handlers: handlers\n\n  self = MenuView\n    items: items\n    contextRoot: contextRoot\n    classes: -> [\"context\", \"options\"]\n    style: ->\n      \"top: #{top()}px; left: #{left()}px\"\n\n  element = self.element\n  element.view = self\n\n  self.contextRoot = contextRoot\n  self.display = ({inElement, x, y}) ->\n    top(y)\n    left(x)\n\n    # The element must be added to the dom before it can be activated\n    # it must be visible before it can be focused\n    (inElement or document.body).appendChild element\n    activeItem self\n    element.focus()\n\n  # This must be attached to the document body so we can de-activate when\n  # a person presses the mouse outside of our menu\n  # TODO: How should we clean up this global listener?\n  document.addEventListener \"mousedown\", (e) ->\n    unless isDescendant(e.target, element)\n      activeItem null\n\n  element.setAttribute(\"tabindex\", \"-1\")\n  element.addEventListener \"keydown\", (e) ->\n    {key} = e\n\n    switch key\n      when \"ArrowLeft\", \"ArrowUp\", \"ArrowRight\", \"ArrowDown\"\n        e.preventDefault()\n        direction = key.replace(\"Arrow\", \"\")\n\n        currentItem = activeItem()\n\n        if currentItem\n          currentItem.cursor(direction)\n\n      when \"Escape\"\n        activeItem null\n\n  return self\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/menu-bar.coffee": {
          "path": "views/menu-bar.coffee",
          "content": "# The MenuBar is a list MenuItems arranged in a bar across the top of a page or\n# window.\n\nObservable = require \"observable\"\n\nMenuView = require \"./menu\"\n\n{isDescendant, advance} = require \"../util\"\n\nmodule.exports = ({items, handlers}) ->\n  acceleratorActive = Observable false\n  # Track active menus and item for navigation\n  activeItem = Observable null\n  previouslyFocusedElement = null\n\n  contextRoot =\n    activeItem: activeItem\n    handlers: handlers\n\n  self = MenuView\n    classes: ->\n      [\n        \"bar\"\n        \"accelerator-active\" if acceleratorActive()\n      ]\n    items: items\n    contextRoot: contextRoot\n\n  element = self.element\n\n  # Redefine cursor movement\n  self.cursor = (direction) ->\n    switch direction\n      when \"Right\"\n        self.advance(1)\n      when \"Left\"\n        self.advance(-1)\n\n  # Redefine expand to down and not right on menu items\n  self.items.forEach (item) ->\n    item.horizontal = true\n    item.cursor = (direction) ->\n      console.log \"Item\", direction\n      if direction is \"Down\"\n        item.submenu?.advance(1)\n      else if direction is \"Up\"\n        item.submenu?.advance(-1)\n      else\n        item.parent.cursor direction\n\n  deactivate = ->\n    activeItem null\n    acceleratorActive false\n    # De-activate menu and focus previously focused element\n    previouslyFocusedElement?.focus()\n\n  document.addEventListener \"mousedown\", (e) ->\n    unless isDescendant(e.target, element)\n      acceleratorActive false\n      activeItem null\n\n  document.addEventListener \"keydown\", (e) ->\n    {key} = e\n    switch key\n      when \"Enter\"\n        activeItem()?.click()\n      when \"Alt\"\n        menuIsActive = false\n        if acceleratorActive() or menuIsActive\n          deactivate()\n        else\n          # Store previously focused element\n          # Get menu ready for accelerating!\n          previouslyFocusedElement = document.activeElement\n          element.focus()\n          activeItem self unless activeItem()\n          acceleratorActive true\n\n  # Dispatch the key to the active menu element\n  accelerateIfActive = (key) ->\n    if acceleratorActive()\n      activeItem()?.accelerate(key)\n\n  # We need to be able to focus the menu to receive keyboard events on it\n  element.setAttribute(\"tabindex\", \"-1\")\n  element.addEventListener \"keydown\", (e) ->\n    {key} = e\n\n    switch key\n      when \"ArrowLeft\", \"ArrowUp\", \"ArrowRight\", \"ArrowDown\"\n        e.preventDefault()\n        direction = key.replace(\"Arrow\", \"\")\n\n        currentItem = activeItem()\n\n        if currentItem\n          currentItem.cursor(direction)\n\n      when \"Escape\"\n        deactivate()\n      else\n        # Only prevent default if we successfully accelerated?\n        accelerated = accelerateIfActive(key.toLowerCase())\n        if accelerated?\n          e.preventDefault()\n\n  return self\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/menu-item.coffee": {
          "path": "views/menu-item.coffee",
          "content": "{advance, htmlEscape, asElement, F, S, isDescendant, accelerateItem, handle} = require \"../util\"\n\nMenuItemTemplate = require \"../templates/menu-item\"\n\n# MenuItemView\n# An item that appears in menus\nmodule.exports = ({label, MenuView, items, contextRoot, parent}) ->\n  self = {}\n\n  {activeItem, handlers} = contextRoot\n  # TODO: This gets called per menu item when the state changes\n  # Could we shift it a little to only be called for the relevant subtree?\n  active = ->\n    isDescendant activeItem()?.element, element\n\n  self.active = active\n\n  if items\n    submenu = MenuView({\n      items\n      contextRoot\n      parent: self\n    })\n    content = submenu.element\n\n  # Hook in to Action objects so we can display hotkeys\n  # and enabled/disabled statuses.\n  [labelText, actionName] = formatAction label\n  [title, accelerator] = formatLabel labelText\n  action = handlers[actionName]\n  disabled = S(action, \"disabled\", false)\n  hotkey = S(action, \"hotkey\", \"\")\n\n  click = (e) ->\n    return if disabled()\n    return if e?.defaultPrevented\n    e?.preventDefault()\n\n    if submenu\n      activeItem submenu\n      return\n\n    console.log \"Handling\", actionName\n\n    action?.call?(handlers)\n\n    # TODO: More cleanup than just clearing the active item, like also we\n    # should clear accelerator state, and maybe return focus to previously\n    # focused element.\n    # contextRoot.finish?\n    activeItem null\n\n  element = MenuItemTemplate\n    class: ->\n      [\n        \"menu\" if items\n        \"active\" if active()\n      ]\n    click: click\n\n    mousemove: (e) ->\n      # Click to activate top level menus unless a menu is already active\n      # then hover to show.\n      return unless activeItem()\n\n      if !e.defaultPrevented and isDescendant(e.target, element)\n        # Note: We're using preventDefault to prevent handling the\n        # activation above the first element that handles it\n        e.preventDefault()\n\n        activeItem self\n\n    title: title\n    content: content\n    decoration: \"\" if items\n    hotkey: hotkey\n    disabled: disabled\n\n  Object.assign self,\n    accelerator: accelerator\n    accelerate: (key) ->\n      if submenu\n        submenu.accelerate key\n      else\n        parent.accelerate key\n    click: click\n    parent: parent\n    element: element\n    submenu: submenu\n    cursor: (direction) ->\n      console.log \"Item Cursor\", direction\n      if submenu and direction is \"Right\"\n        # Select the first navigable item of the submenu\n        activeItem submenu.navigableItems[0]\n      else if parent.parent and direction is \"Left\"\n        # parent is the menu,\n        # parent.parent is the item in the menu containing the parent\n        if parent.parent.horizontal\n          parent.parent.cursor(direction)\n        else\n          activeItem parent.parent\n      else\n        parent.cursor(direction)\n\n  return self\n\n# Parse out custom action symbol from entries like:\n#\n#     [F]ont... -> showFont\n#\n# Falling back to formatting the action title\nformatAction = (labelText) ->\n  [title, action] = labelText.split(\"->\").map F(\"trim\")\n\n  action ?= title.replace(/[^A-Za-z0-9]/g, \"\")\n  action = action.charAt(0).toLowerCase() + action.substring(1)\n\n  return [title, action]\n\nformatLabel = (labelText) ->\n  accelerator = undefined\n  # Parse out accelerator keys for underlining when alt is pressed\n  titleHTML = htmlEscape(labelText).replace /\\[([^\\]]+)\\]/, (match, $1) ->\n    accelerator = $1.toLowerCase()\n    \"<span class=\\\"accelerator\\\">#{$1}</span>\"\n\n  span = document.createElement \"span\"\n  span.innerHTML = titleHTML\n\n  return [span, accelerator]\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/menu-separator.coffee": {
          "path": "views/menu-separator.coffee",
          "content": "MenuSeparatorTemplate = require \"../templates/menu-separator\"\n\nmodule.exports = ->\n  element: MenuSeparatorTemplate()\n  separator: true\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/menu.coffee": {
          "path": "views/menu.coffee",
          "content": "Observable = require \"observable\"\n\nassert = require \"../lib/assert\"\n\n{advance, accelerateItem, asElement, F, S, htmlEscape, handle, isDescendant} = require \"../util\"\n\nMenuTemplate = require \"../templates/menu\"\nMenuItemTemplate = require \"../templates/menu-item\"\n\nSeparatorView = require \"./menu-separator\"\nMenuItemView = require \"./menu-item\"\n\n# MenuView\n#\n# items is an array of item data\n# An item datum is either a string\n# or a pair of [label:string, items...]\n#\n# ex. [\n#   \"Cool\"\n#   [\"Submenu\", [\n#     \"Yo\",\n#     \"Wat\"\n#   ]]\n# ]\n#\nmodule.exports = MenuView = ({items, classes, style, contextRoot, parent}) ->\n  self = {}\n\n  classes ?= -> [\"options\"]\n\n  {activeItem} = contextRoot\n\n  # Promote item data to MenuItemViews\n  items = items.map (item) ->\n    switch\n      when item is \"-\"\n        SeparatorView()\n      when Array.isArray(item)\n        assert item.length is 2\n        [label, submenuItems] = item\n        MenuItemView\n          label: label\n          items: submenuItems\n          MenuView: MenuView\n          contextRoot: contextRoot\n          parent: self\n      else\n        MenuItemView\n          label: item\n          contextRoot: contextRoot\n          parent: self\n\n  navigableItems = items.filter (item) ->\n    !item.separator\n\n  # TODO: This gets called per menu item when the state changes\n  # Could we shift it a little to only be called for the relevant subtree?\n  # Possible solution: find the common ancestor of the new active and the previous\n  # active and only update the necessary ones\n  active = ->\n    isDescendant activeItem()?.element, self.element\n\n  Object.assign self,\n    accelerate: (key) ->\n      accelerateItem(items, key)\n    cursor: (direction) ->\n      switch direction\n        when \"Up\"\n          self.advance(-1)\n        when \"Down\"\n          self.advance(1)\n        else\n          parent.parent?.cursor(direction)\n    parent: parent\n    items: items\n    advance: (n) ->\n      activeItem advance(navigableItems, n)\n    navigableItems: navigableItems\n    element: MenuTemplate\n      style: style\n      class: ->\n        [\n          \"active\" if active()\n        ].concat classes()\n      click: handle (e) ->\n        activeItem self\n      items: items.map asElement\n\n  return self\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/progress.coffee": {
          "path": "views/progress.coffee",
          "content": "Template = require \"../templates/progress\"\n\nObservable = require \"observable\"\n\nmodule.exports = (params={}) ->\n  {value, max, message} = params\n  value = Observable value or 0\n  max = Observable max\n  message = Observable message\n\n  element = Template\n    value: value\n    max: max\n    message: message\n\n  element: element\n  value: value\n  message: message\n  max: max\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/table.coffee": {
          "path": "views/table.coffee",
          "content": "{empty} = require \"../util\"\n\nTableTemplate = require \"../templates/table\"\n\n# Focus same cell in next row\nadvanceRow = (path, prev) ->\n  [td] = path.filter (element) ->\n    element.tagName is \"TD\"\n  return unless td\n\n  tr = td.parentElement\n  cellIndex = Array::indexOf.call(tr.children, td)\n  if prev\n    nextRowElement = tr.previousSibling\n  else\n    nextRowElement = tr.nextSibling\n\n  if nextRowElement\n    input = nextRowElement.children[cellIndex].querySelector('input')\n    input?.focus()\n\n# The table view takes source data and a constructor that returns a row element\n# for each source datum\n\n# The view will have the ability to filter/sort the data.\n\nTableView = ({data, headers, RowElement}) ->\n  headers ?= Object.keys data[0]\n\n  containerElement = TableTemplate\n    headers: headers\n    keydown: (event) ->\n      {key, path} = event\n      switch key\n        when \"Enter\", \"ArrowDown\"\n          event.preventDefault()\n          advanceRow path\n        when \"ArrowUp\"\n          event.preventDefault()\n          advanceRow path, true\n        # TODO: Left and Right\n        # Left and Right are trickier because you may want to navigate within a text input\n        # ... actually up and down get trickier too if we imagine text areas or\n        # even fancier inputs that may have their own controls...\n\n  tableBody = containerElement.querySelector('tbody')\n\n  filterFn = (datum) ->\n    true\n\n  filterAndSort = (data, filterFn, sortFn) ->\n    filterFn ?= -> true\n    filteredData = data.filter(filterFn)\n\n    if sortFn\n      filteredData.sort(sortFn)\n    else\n      filteredData\n\n  rowElements = ->\n    filterAndSort(data, filterFn, null).map RowElement\n\n  update = ->\n    empty tableBody\n    rowElements().forEach (element) ->\n      tableBody.appendChild element\n\n  update()\n\n  element: containerElement\n  render: update\n\nmodule.exports = TableView\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/window.coffee": {
          "path": "views/window.coffee",
          "content": "WindowTemplate = require \"../templates/window\"\n\n{elementView} = require \"../util\"\n\n# We need an invisible full screen overlay to keep iframes from eating our\n# mousemove events\nframeGuard = document.createElement \"frame-guard\"\ndocument.body.appendChild frameGuard\n\ntopIndex = 0\nraiseToTop = (view) ->\n  return unless typeof view.zIndex is 'function'\n  zIndex = view.zIndex()\n  return if zIndex is topIndex\n  topIndex += 1\n\n  view.zIndex(topIndex)\n\n# Drag Handling\nactiveDrag = null\ndragStart = null\ndocument.addEventListener \"mousedown\", (e) ->\n  {target} = e\n\n  view = elementView target\n  if view\n    # TODO: only raise widows?\n    raiseToTop view\n\n  if target.tagName is \"TITLE-BAR\"\n    frameGuard.classList.add(\"active\")\n    dragStart = e\n    activeDrag = view\n\ndocument.addEventListener \"mousemove\", (e) ->\n  if activeDrag\n    {clientX:prevX, clientY:prevY} = dragStart\n    {clientX:x, clientY:y} = e\n\n    dx = x - prevX\n    dy = y - prevY\n\n    activeDrag.x activeDrag.x() + dx\n    activeDrag.y activeDrag.y() + dy\n\n    dragStart = e\n\n# Resize Handling\nactiveResize = null\nresizeStart = null\nresizeInitial = null\ndocument.addEventListener \"mousedown\", (e) ->\n  {target} = e\n\n  if target.tagName is \"RESIZE\"\n    frameGuard.classList.add(\"active\")\n    resizeStart = e\n    activeResize = target\n    {width, height, x, y} = elementView activeResize\n    resizeInitial =\n      width: width()\n      height: height()\n      x: x()\n      y: y()\n\ndocument.addEventListener \"mousemove\", (e) ->\n  if activeResize\n    {clientX:startX, clientY:startY} = resizeStart\n    {clientX:x, clientY:y} = e\n\n    dx = x - startX\n    dy = y - startY\n\n    width = resizeInitial.width\n    height = resizeInitial.height\n\n    if activeResize.classList.contains(\"e\")\n      width += dx\n\n    if activeResize.classList.contains(\"w\")\n      width -= dx\n\n    if activeResize.classList.contains(\"s\")\n      height += dy\n\n    if activeResize.classList.contains(\"n\")\n      height -= dy\n\n    width = Math.max(width, 200)\n    height = Math.max(height, 50)\n\n    actualDeltaX = width - resizeInitial.width\n    actualDeltaY = height - resizeInitial.height\n\n    view = elementView activeResize\n    if activeResize.classList.contains(\"n\")\n      view.y resizeInitial.y- actualDeltaY\n\n    if activeResize.classList.contains(\"w\")\n      view.x resizeInitial.x- actualDeltaX\n\n    view.width width\n    view.height height\n\n    view.trigger \"resize\"\n\ndocument.addEventListener \"mouseup\", ->\n  activeDrag = null\n  activeResize = null\n  frameGuard.classList.remove(\"active\")\n\nBindable = require \"bindable\"\nObservable = require \"observable\"\n\nmodule.exports = (params) ->\n  self = Bindable()\n\n  x = Observable params.x ? 50\n  y = Observable params.y ? 50\n  width = Observable params.width ? 400\n  height = Observable params.height ? 300\n  title = Observable params.title ? \"Untitled\"\n\n  topIndex += 1\n  zIndex = Observable params.zIndex ? topIndex\n\n  element = WindowTemplate\n    title: title\n    menuBar: params.menuBar\n    content: params.content\n    close: ->\n      self.close()\n\n  styleBind(y, element, \"top\", \"px\")\n  styleBind(x, element, \"left\", \"px\")\n  styleBind(height, element, \"height\", \"px\")\n  styleBind(width, element, \"width\", \"px\")\n  styleBind(zIndex, element, \"zIndex\")\n\n  Object.assign self,\n    element: element\n    title: title\n    x: x\n    y: y\n    width: width\n    height: height\n    zIndex: zIndex\n    close: ->\n      # TODO: Allow prompt to cancel\n      # Maybe we count on people to override this method if they want\n      element.remove()\n\n  element.view = self\n\n  return self\n\nstyleBind = (observable, element, attr, suffix=\"\") ->\n  update = (newValue) ->\n    newValue = parseInt newValue\n\n    if newValue?\n      element.style[attr] = \"#{newValue}#{suffix}\"\n\n  observable.observe update\n\n  update(observable())\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "action": {
          "path": "action",
          "content": "\n/*\nAction\n======\n\nActions have a function to call, a hotkey, and a function that determines\nwhether or not they are disabled. This is so we can present them in the UI for\nmenus.\n\nThe hotkey is for display purposes only and needs to be listened to by a\nseparate mechanism to perform. [TODO] The action can be executed like a regular\nfunction (instead of needing to use call).\n\nActions may have icons and help text as well.\n */\n\n(function() {\n  var Observable,\n    __slice = [].slice;\n\n  Observable = require(\"observable\");\n\n  module.exports = function(fn, hotkey) {\n    var disabled;\n    disabled = Observable(false);\n    setInterval(function() {\n      return disabled.toggle();\n    }, 1000);\n    return {\n      disabled: disabled,\n      hotkey: function() {\n        return hotkey;\n      },\n      call: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return fn.call.apply(fn, args);\n      }\n    };\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "demo": {
          "path": "demo",
          "content": "(function() {\n  var ContextMenu, FormSampleTemplate, MenuBar, Modal, Observable, Progress, Style, Table, Window, addWindow, contextMenu, desktop, element, notepadMenuParsed, notepadMenuText, o, parseMenu, sampleMenuParsed, style, _ref, _ref1;\n\n  _ref = require(\"./export\"), ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Observable = _ref.Observable, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Progress = _ref.Progress, Style = _ref.Style, Table = _ref.Table, Window = _ref.Window;\n\n  o = require(\"./util\").o;\n\n  notepadMenuText = require(\"./samples/notepad-menu\");\n\n  notepadMenuParsed = parseMenu(notepadMenuText);\n\n  FormSampleTemplate = require(\"./samples/test-form\");\n\n  style = document.createElement(\"style\");\n\n  style.innerHTML = Style.all;\n\n  document.head.appendChild(style);\n\n  sampleMenuParsed = parseMenu(\"[M]odal\\n  [A]lert\\n  [C]onfirm\\n  [P]rompt\\n  [F]orm\\n  P[r]ogress\\n[T]est Nesting\\n  Test[1]\\n    Hello\\n    Wat\\n  Test[2]\\n    [N]ested\\n    [R]ad\\n      So Rad\\n      Hella\\n        Hecka\\n          Super Hecka\\n            Wicked\\n[W]indow\\n  New [I]mage -> newImage\\n  New [P]ixel -> newPixel\\n  New [T]ext -> newText\\n  New [S]preadsheet -> newSheet\");\n\n  element = MenuBar({\n    items: sampleMenuParsed,\n    handlers: {\n      alert: function() {\n        return Modal.alert(\"yolo\");\n      },\n      prompt: function() {\n        return Modal.prompt(\"Pretty cool, eh?\", \"Yeah!\").then(console.log);\n      },\n      confirm: function() {\n        return Modal.confirm(\"Jawsome!\").then(console.log);\n      },\n      form: function() {\n        return Modal.form(FormSampleTemplate()).then(console.log);\n      },\n      progress: function() {\n        var initialMessage, intervalId, progressView;\n        initialMessage = \"Reticulating splines\";\n        progressView = Progress({\n          value: 0,\n          max: 2,\n          message: initialMessage\n        });\n        Modal.show(progressView.element, {\n          cancellable: false\n        });\n        return intervalId = setInterval(function() {\n          var ellipses, ellipsesCount, newValue, _i, _results;\n          newValue = progressView.value() + 1 / 60;\n          ellipsesCount = Math.floor(newValue * 4) % 4;\n          ellipses = (function() {\n            _results = [];\n            for (var _i = 0; 0 <= ellipsesCount ? _i < ellipsesCount : _i > ellipsesCount; 0 <= ellipsesCount ? _i++ : _i--){ _results.push(_i); }\n            return _results;\n          }).apply(this).map(function() {\n            return \".\";\n          }).join(\"\");\n          progressView.value(newValue);\n          progressView.message(initialMessage + ellipses);\n          if (newValue > 2) {\n            clearInterval(intervalId);\n            return Modal.hide();\n          }\n        }, 15);\n      },\n      newImage: function() {\n        var img;\n        img = document.createElement(\"img\");\n        img.src = \"https://s3.amazonaws.com/whimsyspace-databucket-1g3p6d9lcl6x1/danielx/data/pI1mvEvxcXJk4mNHNUW-kZsNJsrPDXcAtgguyYETRXQ\";\n        return addWindow({\n          title: \"Yoo\",\n          content: img\n        });\n      },\n      newPixel: function() {\n        var frame;\n        frame = document.createElement(\"iframe\");\n        frame.src = \"https://danielx.net/pixel-editor/embedded/\";\n        return addWindow({\n          title: \"Pixel\",\n          content: frame\n        });\n      },\n      newText: function() {\n        var textarea;\n        textarea = document.createElement(\"textarea\");\n        return addWindow({\n          title: \"Notepad.exe\",\n          content: textarea\n        });\n      },\n      newSheet: function() {\n        var InputTemplate, RowElement, data, menuBar, tableView;\n        data = [0, 1, 2, 3, 4].map(function(i) {\n          return {\n            id: i,\n            name: \"yolo\",\n            color: \"#FF0000\"\n          };\n        });\n        InputTemplate = require(\"./templates/input\");\n        RowElement = function(datum) {\n          var tr, types;\n          tr = document.createElement(\"tr\");\n          types = [\"number\", \"text\", \"color\"];\n          Object.keys(datum).forEach(function(key, i) {\n            var td;\n            td = document.createElement(\"td\");\n            td.appendChild(InputTemplate({\n              value: o(datum, key),\n              type: types[i]\n            }));\n            return tr.appendChild(td);\n          });\n          return tr;\n        };\n        element = (tableView = Table({\n          data: data,\n          RowElement: RowElement\n        })).element;\n        menuBar = MenuBar({\n          items: parseMenu(\"Insert\\n  Row -> insertRow\\nHelp\\n  About\"),\n          handlers: {\n            about: function() {\n              return Modal.alert(\"Spreadsheet v0.0.1 by Daniel X Moore\");\n            },\n            insertRow: function() {\n              data.push({\n                id: 50,\n                name: \"new\",\n                color: \"#FF00FF\"\n              });\n              return tableView.render();\n            }\n          }\n        });\n        return addWindow({\n          title: \"Spreadsheet [DEMO VERSION]\",\n          content: element,\n          menuBar: menuBar.element\n        });\n      }\n    }\n  }).element;\n\n  document.body.appendChild(element);\n\n  desktop = document.createElement(\"desktop\");\n\n  document.body.appendChild(desktop);\n\n  contextMenu = ContextMenu({\n    items: sampleMenuParsed[1][1],\n    handlers: {}\n  });\n\n  desktop.addEventListener(\"contextmenu\", function(e) {\n    if (e.target === desktop) {\n      e.preventDefault();\n      return contextMenu.display({\n        inElement: document.body,\n        x: e.pageX,\n        y: e.pageY\n      });\n    }\n  });\n\n  addWindow = function(_arg) {\n    var content, menuBar, title, windowView;\n    title = _arg.title, menuBar = _arg.menuBar, content = _arg.content;\n    if (menuBar == null) {\n      menuBar = MenuBar({\n        items: notepadMenuParsed,\n        handlers: {}\n      }).element;\n    }\n    if (title == null) {\n      title = \"Hello\";\n    }\n    windowView = Window({\n      title: title,\n      menuBar: menuBar,\n      content: content\n    });\n    desktop.appendChild(windowView.element);\n    return windowView;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "export": {
          "path": "export",
          "content": "(function() {\n  var Action, ContextMenuView, MenuBarView, MenuItemView, MenuView, Modal, Observable, ProgressView, Style, TableView, WindowView;\n\n  Action = require(\"./action\");\n\n  ContextMenuView = require(\"./views/context-menu\");\n\n  Modal = require(\"./modal\");\n\n  MenuView = require(\"./views/menu\");\n\n  MenuBarView = require(\"./views/menu-bar\");\n\n  MenuItemView = require(\"./views/menu-item\");\n\n  Observable = require(\"observable\");\n\n  ProgressView = require(\"./views/progress\");\n\n  Style = require(\"./style\");\n\n  TableView = require(\"./views/table\");\n\n  WindowView = require(\"./views/window\");\n\n  module.exports = {\n    Action: Action,\n    Bindable: require(\"bindable\"),\n    ContextMenu: ContextMenuView,\n    Modal: Modal,\n    Menu: MenuView,\n    MenuBar: MenuBarView,\n    MenuItem: MenuItemView,\n    Observable: Observable,\n    Progress: ProgressView,\n    Style: Style,\n    Table: TableView,\n    Util: {\n      parseMenu: require(\"./lib/indent-parse\")\n    },\n    Window: WindowView\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "hotkeys": {
          "path": "hotkeys",
          "content": "\n/*\nHotkeys\n=======\n\nBind hotkeys\n\n    Hotkey = require \"hotkey\"\n\n    Hotkey \"ctrl+r\", ->\n      alert \"radical!\"\n\nWe'd like to be able to generate a list of hotkeys with descriptions.\n\nQuestions\n---------\n\nShould we just use Mousetrap?\n\nMaybe, but it may have different semantics with preventDefault/defaultPrevented.\n\nShould we allow binding to specific elements?\n\nImagine a windowing OS where non-iframe apps are inside draggable windows. We'd\nlike to have each 'app' able to have its own hotkeys and at the same time have\nglobal OS level hotkeys.\n\nShould `defaultPrevented` prevent executing the hotkey action? Yes\n\nShould executing a hotkey preventDefault? Yes\n */\n\n(function() {\n  module.exports = function(element) {\n    var handle, handlers;\n    handlers = {};\n    return handle = function(event) {\n      var combo, key, modifiersActive;\n      key = event.key;\n      modifiersActive = [\"alt\", \"ctrl\", \"meta\", \"shift\"].filter(function(modifier) {\n        return event[\"\" + modifier + \"Key\"];\n      });\n      combo = modifiersActive.concat(key).join(\"+\");\n      return typeof handlers[combo] === \"function\" ? handlers[combo](e) : void 0;\n    };\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "lib/assert": {
          "path": "lib/assert",
          "content": "(function() {\n  module.exports = function(condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "lib/indent-parse": {
          "path": "lib/indent-parse",
          "content": "(function() {\n  var parse, top;\n\n  top = function(stack) {\n    return stack[stack.length - 1];\n  };\n\n  parse = function(source) {\n    var depth, indentation, stack;\n    stack = [[]];\n    indentation = /^(  )*/;\n    depth = 0;\n    source.split(\"\\n\").forEach(function(line, lineNumber) {\n      var current, items, match, newDepth, prev, text;\n      match = line.match(indentation)[0];\n      text = line.replace(match, \"\");\n      newDepth = match.length / 2;\n      if (!text.trim().length) {\n        return;\n      }\n      current = text;\n      if (newDepth > depth) {\n        if (newDepth !== depth + 1) {\n          throw new Error(\"Unexpected indentation on line \" + lineNumber);\n        }\n        items = [];\n        prev = top(stack);\n        prev.push([prev.pop(), items]);\n        stack.push(items);\n      } else if (newDepth < depth) {\n        stack = stack.slice(0, newDepth + 1);\n      }\n      depth = newDepth;\n      return top(stack).push(current);\n    });\n    return stack[0];\n  };\n\n  module.exports = parse;\n\n}).call(this);\n",
          "type": "blob"
        },
        "main": {
          "path": "main",
          "content": "(function() {\n  if (PACKAGE.name === \"ROOT\") {\n    require(\"./demo\");\n  } else {\n    module.exports = require(\"./export\");\n  }\n\n}).call(this);\n",
          "type": "blob"
        },
        "modal": {
          "path": "modal",
          "content": "\n/*\nModal\n\nDisplay modal alerts or dialogs.\n\nModal has promise returning equivalents of the native browser:\n\n- Alert\n- Confirm\n- Prompt\n\nThese accept the same arguments and return a promise fulfilled with\nthe same return value as the native methods.\n\nYou can display any element in the modal:\n\n    modal.show myElement\n */\n\n(function() {\n  var Modal, ModalTemplate, PromptTemplate, cancellable, closeHandler, empty, formDataToObject, handle, modal, prompt, _ref;\n\n  _ref = require(\"./util\"), formDataToObject = _ref.formDataToObject, handle = _ref.handle, empty = _ref.empty;\n\n  PromptTemplate = require(\"./templates/modal/prompt\");\n\n  ModalTemplate = require(\"./templates/modal\");\n\n  modal = ModalTemplate();\n\n  cancellable = true;\n\n  modal.onclick = function(e) {\n    if (e.target === modal && cancellable) {\n      return Modal.hide();\n    }\n  };\n\n  document.addEventListener(\"keydown\", function(e) {\n    if (!e.defaultPrevented) {\n      if (e.key === \"Escape\" && cancellable) {\n        e.preventDefault();\n        return Modal.hide();\n      }\n    }\n  });\n\n  document.body.appendChild(modal);\n\n  closeHandler = null;\n\n  prompt = function(params) {\n    return new Promise(function(resolve) {\n      var element, _ref1;\n      element = PromptTemplate(params);\n      Modal.show(element, {\n        cancellable: false,\n        closeHandler: resolve\n      });\n      return (_ref1 = element.querySelector(params.focus)) != null ? _ref1.focus() : void 0;\n    });\n  };\n\n  module.exports = Modal = {\n    show: function(element, options) {\n      if (typeof options === \"function\") {\n        closeHandler = options;\n      } else {\n        closeHandler = options != null ? options.closeHandler : void 0;\n        if ((options != null ? options.cancellable : void 0) != null) {\n          cancellable = options.cancellable;\n        }\n      }\n      empty(modal).appendChild(element);\n      return modal.classList.add(\"active\");\n    },\n    hide: function(dataForHandler) {\n      if (typeof closeHandler === \"function\") {\n        closeHandler(dataForHandler);\n      }\n      modal.classList.remove(\"active\");\n      cancellable = true;\n      return empty(modal);\n    },\n    alert: function(message) {\n      return prompt({\n        title: \"Alert\",\n        message: message,\n        focus: \"button\",\n        confirm: handle(function() {\n          return Modal.hide();\n        })\n      });\n    },\n    prompt: function(message, defaultValue) {\n      if (defaultValue == null) {\n        defaultValue = \"\";\n      }\n      return prompt({\n        title: \"Prompt\",\n        message: message,\n        focus: \"input\",\n        defaultValue: defaultValue,\n        cancel: handle(function() {\n          return Modal.hide(null);\n        }),\n        confirm: handle(function() {\n          return Modal.hide(modal.querySelector(\"input\").value);\n        })\n      });\n    },\n    confirm: function(message) {\n      return prompt({\n        title: \"Confirm\",\n        message: message,\n        focus: \"button\",\n        cancel: handle(function() {\n          return Modal.hide(false);\n        }),\n        confirm: handle(function() {\n          return Modal.hide(true);\n        })\n      });\n    },\n    form: function(formElement) {\n      return new Promise(function(resolve) {\n        var submitHandler;\n        submitHandler = handle(function(e) {\n          var formData, result;\n          formData = new FormData(formElement);\n          result = formDataToObject(formData);\n          return Modal.hide(result);\n        });\n        formElement.addEventListener(\"submit\", submitHandler);\n        return Modal.show(formElement, function(result) {\n          formElement.removeEventListener(\"submit\", submitHandler);\n          return resolve(result);\n        });\n      });\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"version\":\"0.1.2\",\"entryPoint\":\"main\",\"remoteDependencies\":[],\"dependencies\":{\"observable\":\"distri/observable:master\",\"bindable\":\"distri/bindable:master\"}};",
          "type": "blob"
        },
        "samples/notepad-menu": {
          "path": "samples/notepad-menu",
          "content": "(function() {\n  module.exports = \"[F]ile\\n  [N]ew\\n  [O]pen\\n  [S]ave\\n  Save [A]s\\n  -\\n  Page Set[u]p\\n  [P]rint\\n  -\\n  E[x]it\\n[E]dit\\n  [U]ndo\\n  Redo\\n  -\\n  Cu[t]\\n  [C]opy\\n  [P]aste\\n  De[l]ete\\n  -\\n  [F]ind\\n  Find [N]ext\\n  [R]eplace\\n  [G]o To\\n  -\\n  Select [A]ll\\n  Time/[D]ate\\nF[o]rmat\\n  [W]ord Wrap\\n  [F]ont...\\n[V]iew\\n  [S]tatus Bar\\n[H]elp\\n  View [H]elp\\n  -\\n  [A]bout Notepad\";\n\n}).call(this);\n",
          "type": "blob"
        },
        "samples/test-form": {
          "path": "samples/test-form",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"form\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"h1\", this, {}, function(__root) {\n        __root.buffer(\"Cool Form Bro\\n\");\n      }));\n      __root.buffer(__root.element(\"p\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"a\", this, {\n          \"href\": \"https://yolo.biz\"\n        }, function(__root) {\n          __root.buffer(\"Yolo\\n\");\n        }));\n      }));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"yolo\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"x\",\n        \"value\": \"Lorem\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"y\",\n        \"value\": \"florem\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"z\",\n        \"type\": \"number\",\n        \"value\": 5\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"file\",\n        \"type\": \"file\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"textarea\", this, {\n        \"name\": \"text\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"button\", this, {}, function(__root) {\n        __root.buffer(\"Submit\\n\");\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "style": {
          "path": "style",
          "content": "(function() {\n  var all, styles;\n\n  styles = {};\n\n  all = \"main\\nloader\\nmenu\\nmodal\\ntable\\nwindow\".split(\"\\n\").map(function(stylePath) {\n    var content;\n    content = require(\"./style/\" + stylePath);\n    styles[stylePath] = content;\n    return content;\n  }).join(\"\\n\");\n\n  styles.all = all;\n\n  module.exports = styles;\n\n}).call(this);\n",
          "type": "blob"
        },
        "style/loader": {
          "path": "style/loader",
          "content": "module.exports = \"loader {\\n  display: block;\\n  padding: 1em;\\n}\\nloader > p:empty {\\n  margin: 0;\\n}\\nloader > progress {\\n  display: block;\\n}\\n\";",
          "type": "blob"
        },
        "style/main": {
          "path": "style/main",
          "content": "module.exports = \"* {\\n  box-sizing: border-box;\\n}\\nbody {\\n  display: flex;\\n  flex-direction: column;\\n  font-family: Sans-Serif;\\n  font-size: 14px;\\n  line-height: 18px;\\n  margin: 0;\\n}\\nbody,\\nhtml {\\n  height: 100%;\\n}\\ninput,\\ntextarea,\\nkeygen,\\nselect,\\nbutton {\\n  font-size: inherit;\\n  font-family: inherit;\\n}\\n\";",
          "type": "blob"
        },
        "style/menu": {
          "path": "style/menu",
          "content": "module.exports = \"menu {\\n  user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n  background-color: #d3d3d3;\\n  border-bottom: 1px solid rgba(0,0,0,0.5);\\n  margin: 0;\\n  z-index: 1;\\n}\\nmenu:focus {\\n  outline: none;\\n}\\nmenu.context {\\n  z-index: 2000;\\n}\\nmenu-item {\\n  display: block;\\n  list-style-type: none;\\n}\\nmenu-item.active {\\n  background-color: #000080;\\n  color: #fff;\\n}\\nmenu-item > label {\\n  display: flex;\\n  padding: 0 0.25em;\\n  white-space: nowrap;\\n}\\nmenu-item > label > * {\\n  flex: 1 1 auto;\\n}\\nmenu-item > label > span.hotkey {\\n  margin-left: 1em;\\n}\\nmenu-item > label > span.hotkey:empty {\\n  margin-left: 0;\\n}\\nmenu-item > label > .decoration {\\n  flex: 0 1 auto;\\n  line-height: 1em;\\n  text-align: right;\\n  margin-left: 0.5em;\\n}\\nmenu-item > label > .decoration:empty {\\n  margin-left: 0;\\n}\\nmenu-item[disabled] {\\n  color: #808080;\\n}\\nmenu-item[disabled].active {\\n  background-color: rgba(0,0,0,0.125);\\n}\\nmenu.options {\\n  border-top: 1px solid rgba(255,255,255,0.5);\\n  border-left: 1px solid rgba(255,255,255,0.5);\\n  border-right: 1px solid rgba(0,0,0,0.5);\\n  box-shadow: 2px 2px 1px rgba(0,0,0,0.5);\\n  display: none;\\n  padding: 2px;\\n  padding-bottom: 3px;\\n  position: absolute;\\n}\\nmenu.options.active {\\n  display: block;\\n}\\nmenu.options > menu-item.menu {\\n  position: relative;\\n}\\nmenu.options > menu-item.menu > menu {\\n  position: absolute;\\n  left: 100%;\\n  top: -3px;\\n  margin-left: 1px;\\n}\\nmenu-item.menu.active > menu {\\n  background-color: #d3d3d3;\\n  color: #000;\\n  display: block;\\n}\\nmenu.bar {\\n  display: block;\\n  flex: 0 0 auto;\\n  margin: 0;\\n  padding: 0;\\n  position: initial;\\n  white-space: nowrap;\\n  overflow: hidden;\\n}\\nmenu.bar > menu-item {\\n  display: inline-block;\\n}\\nmenu.bar > menu-item > label > .decoration {\\n  display: none;\\n}\\nmenu.bar.accelerator-active span.accelerator {\\n  text-decoration: underline;\\n}\\n\";",
          "type": "blob"
        },
        "style/modal": {
          "path": "style/modal",
          "content": "module.exports = \"#modal {\\n  align-items: center;\\n  background-color: rgba(0,0,0,0.25);\\n  display: none;\\n  justify-content: center;\\n  position: absolute;\\n  z-index: 1000;\\n  top: 0;\\n  width: 100%;\\n  height: 100%;\\n}\\n#modal.active {\\n  display: flex;\\n}\\n#modal > * {\\n  background-color: #fff;\\n  border: 1px solid rgba(0,0,0,0.5);\\n  box-shadow: 2px 2px 6px #000;\\n  max-width: 90%;\\n  max-height: 90%;\\n}\\n#modal > form {\\n  display: block;\\n  padding: 1em;\\n}\\n#modal > form > h1 {\\n  font-size: 1.5em;\\n  margin: 0;\\n}\\n#modal > form > input,\\n#modal > form textarea {\\n  display: block;\\n  margin-bottom: 1em;\\n  width: 100%;\\n}\\n#modal > form > button {\\n  margin-right: 1em;\\n}\\n#modal > form > button:last-child {\\n  margin-right: 0;\\n}\\n\";",
          "type": "blob"
        },
        "style/table": {
          "path": "style/table",
          "content": "module.exports = \"container {\\n  display: block;\\n  height: 100%;\\n  overflow: auto;\\n  width: 100%;\\n}\\ntable {\\n  border-collapse: collapse;\\n  width: 100%;\\n}\\nth {\\n  text-align: left;\\n}\\nthead {\\n  border-bottom: 1px solid #000;\\n}\\ntd > input {\\n  border: none;\\n  background-color: transparent;\\n  width: 100%;\\n  height: 100%;\\n  padding: 0;\\n}\\ntr:nth-child(even) {\\n  background-color: #eee;\\n}\\n\";",
          "type": "blob"
        },
        "style/window": {
          "path": "style/window",
          "content": "module.exports = \"desktop {\\n  user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n  display: block;\\n  flex: 1 0 auto;\\n}\\nwindow {\\n  user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n  background-color: #d3d3d3;\\n  border: 4px double #000;\\n  display: flex;\\n  flex-direction: column;\\n  position: absolute;\\n}\\nwindow > header {\\n  border-bottom: 1px solid #000;\\n  cursor: default;\\n  display: flex;\\n  flex: 0 0 auto;\\n}\\nwindow > header > close,\\nwindow > header > control {\\n  color: #fff;\\n  display: inline-block;\\n  flex: 0 0 auto;\\n  font-family: monospace;\\n  width: 18px;\\n  text-shadow: 1px 0px 0px #000, -1px 0px 0px #000, 0px -1px 0px #000, 0px 1px 0px #000, 1px 1px 0px #808080;\\n  text-align: center;\\n}\\nwindow > header > title-bar {\\n  background-color: #000080;\\n  border-color: #000;\\n  border-style: solid;\\n  border-width: 0 1px;\\n  color: #fff;\\n  display: inline-block;\\n  flex: 1 1 auto;\\n  overflow: hidden;\\n  padding: 0 2px;\\n  text-align: center;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n}\\nwindow > viewport {\\n  background-color: #fff;\\n  display: flex;\\n  height: 100%;\\n  overflow: auto;\\n  position: relative;\\n  z-index: 0;\\n}\\nwindow > viewport > * {\\n  margin: auto;\\n}\\nwindow > viewport > textarea {\\n  font-family: monospace;\\n  height: 100%;\\n  resize: none;\\n  width: 100%;\\n}\\nwindow > viewport > iframe {\\n  border: none;\\n  height: 100%;\\n  width: 100%;\\n  position: absolute;\\n}\\nwindow > resize {\\n  display: block;\\n  position: absolute;\\n}\\nwindow > resize.e,\\nwindow > resize.w {\\n  cursor: ew-resize;\\n}\\nwindow > resize.n,\\nwindow > resize.s {\\n  cursor: ns-resize;\\n}\\nwindow > resize.h {\\n  height: 4px;\\n  width: 100%;\\n}\\nwindow > resize.v {\\n  height: 100%;\\n  width: 4px;\\n}\\nwindow > resize.w {\\n  left: -4px;\\n}\\nwindow > resize.e {\\n  right: -4px;\\n}\\nwindow > resize.n {\\n  top: -4px;\\n}\\nwindow > resize.s {\\n  bottom: -4px;\\n}\\nwindow > resize.n.w {\\n  cursor: nw-resize;\\n}\\nwindow > resize.n.e {\\n  cursor: ne-resize;\\n}\\nwindow > resize.s.e {\\n  cursor: se-resize;\\n}\\nwindow > resize.s.w {\\n  cursor: sw-resize;\\n}\\nwindow > resize.n.v {\\n  height: 23px;\\n  border-bottom: 1px solid #000;\\n}\\nwindow > resize.s.v {\\n  height: 23px;\\n  border-top: 1px solid #000;\\n}\\nwindow > resize.e.h {\\n  border-left: 1px solid #000;\\n  width: 23px;\\n}\\nwindow > resize.w.h {\\n  border-right: 1px solid #000;\\n  width: 23px;\\n}\\nframe-guard {\\n  display: block;\\n  height: 100%;\\n  pointer-events: none;\\n  position: absolute;\\n  width: 100%;\\n  z-index: 100000;\\n}\\nframe-guard.active {\\n  pointer-events: auto;\\n}\\n\";",
          "type": "blob"
        },
        "templates/input": {
          "path": "templates/input",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"input\", this, {\n      \"value\": this.value,\n      \"type\": this.type\n    }, function(__root) {}));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/menu-item": {
          "path": "templates/menu-item",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"menu-item\", this, {\n      \"class\": [this[\"class\"]],\n      \"click\": this.click,\n      \"mousemove\": this.mousemove,\n      \"disabled\": this.disabled\n    }, function(__root) {\n      __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n        __root.buffer(this.title);\n        __root.buffer(__root.element(\"span\", this, {\n          \"class\": [\"hotkey\"]\n        }, function(__root) {\n          __root.buffer(this.hotkey);\n        }));\n        __root.buffer(__root.element(\"span\", this, {\n          \"class\": [\"decoration\"]\n        }, function(__root) {\n          __root.buffer(this.decoration);\n        }));\n      }));\n      __root.buffer(this.content);\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/menu-separator": {
          "path": "templates/menu-separator",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"menu-item\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"hr\", this, {}, function(__root) {}));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/menu": {
          "path": "templates/menu",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"menu\", this, {\n      \"class\": [this[\"class\"]],\n      \"click\": this.click,\n      \"style\": this.style\n    }, function(__root) {\n      __root.buffer(this.items);\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/modal": {
          "path": "templates/modal",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"div\", this, {\n      id: [\"modal\"]\n    }, function(__root) {}));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/modal/prompt": {
          "path": "templates/modal/prompt",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"form\", this, {\n      \"submit\": this.confirm,\n      \"tabindex\": -1\n    }, function(__root) {\n      __root.buffer(__root.element(\"h1\", this, {}, function(__root) {\n        __root.buffer(this.title);\n      }));\n      __root.buffer(__root.element(\"p\", this, {}, function(__root) {\n        __root.buffer(this.message);\n      }));\n      if (this.defaultValue != null) {\n        __root.buffer(__root.element(\"input\", this, {\n          \"type\": \"text\",\n          \"value\": this.defaultValue\n        }, function(__root) {}));\n      }\n      __root.buffer(__root.element(\"button\", this, {}, function(__root) {\n        __root.buffer(\"OK\\n\");\n      }));\n      if (this.cancel) {\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.cancel\n        }, function(__root) {\n          __root.buffer(\"Cancel\\n\");\n        }));\n      }\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/progress": {
          "path": "templates/progress",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"loader\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"p\", this, {}, function(__root) {\n        __root.buffer(this.message);\n      }));\n      __root.buffer(__root.element(\"progress\", this, {\n        \"class\": [this[\"class\"]],\n        \"value\": this.value,\n        \"max\": this.max\n      }, function(__root) {}));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/table": {
          "path": "templates/table",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"container\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"table\", this, {\n        \"keydown\": this.keydown\n      }, function(__root) {\n        __root.buffer(__root.element(\"thead\", this, {}, function(__root) {\n          __root.buffer(__root.element(\"tr\", this, {}, function(__root) {\n            this.headers.forEach(function(header) {\n              return __root.buffer(__root.element(\"th\", this, {}, function(__root) {\n                __root.buffer(header);\n              }));\n            });\n          }));\n        }));\n        __root.buffer(__root.element(\"tbody\", this, {}, function(__root) {}));\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/window": {
          "path": "templates/window",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"window\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"e\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"w\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"e\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"e\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"w\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"w\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"e\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"e\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"w\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"w\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"header\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"control\", this, {}, function(__root) {\n          __root.buffer(\"-\\n\");\n        }));\n        __root.buffer(__root.element(\"title-bar\", this, {}, function(__root) {\n          __root.buffer(this.title);\n        }));\n        __root.buffer(__root.element(\"close\", this, {\n          \"click\": this.close\n        }, function(__root) {\n          __root.buffer(\"X\\n\");\n        }));\n      }));\n      __root.buffer(this.menuBar);\n      __root.buffer(__root.element(\"viewport\", this, {}, function(__root) {\n        __root.buffer(this.content);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "test/menu": {
          "path": "test/menu",
          "content": "(function() {\n  var parse;\n\n  parse = require(\"../lib/indent-parse\");\n\n  describe(\"Menu Parser\", function() {\n    it(\"should parse menus into lists\", function() {\n      var data, results;\n      data = \"File\";\n      results = parse(data);\n      return assert.deepEqual([\"File\"], results);\n    });\n    it(\"should parse empty\", function() {\n      var data;\n      data = \"\";\n      return assert.deepEqual([], parse(data));\n    });\n    it(\"should deal with nesting ok\", function() {\n      var data, results;\n      data = \"File\\n  Open\\n  Save\\nEdit\\n  Copy\\n  Paste\\nHelp\";\n      results = parse(data);\n      return assert.deepEqual([[\"File\", [\"Open\", \"Save\"]], [\"Edit\", [\"Copy\", \"Paste\"]], \"Help\"], results);\n    });\n    it(\"should parse big ol' menus\", function() {\n      var results;\n      results = parse(\"File\\n  New\\n  Open\\n  Save\\n  Save As\\nEdit\\n  Undo\\n  Redo\\n  -\\n  Cut\\n  Copy\\n  Paste\\n  Delete\\n  -\\n  Find\\n  Find Next\\n  Replace\\n  Go To\\n  -\\n  Select All\\n  Time/Date\\nFormat\\n  Word Wrap\\n  Font...\\nView\\n  Status Bar\\nHelp\\n  View Help\\n  -\\n  About Notepad\");\n      return assert.deepEqual([[\"File\", [\"New\", \"Open\", \"Save\", \"Save As\"]], [\"Edit\", [\"Undo\", \"Redo\", \"-\", \"Cut\", \"Copy\", \"Paste\", \"Delete\", \"-\", \"Find\", \"Find Next\", \"Replace\", \"Go To\", \"-\", \"Select All\", \"Time/Date\"]], [\"Format\", [\"Word Wrap\", \"Font...\"]], [\"View\", [\"Status Bar\"]], [\"Help\", [\"View Help\", \"-\", \"About Notepad\"]]], results);\n    });\n    return it(\"should parse hella nested menus\", function() {\n      var results;\n      results = parse(\"File\\n  Special\\n    Nested\\n      Super\\n        Awesome\");\n      return assert.deepEqual([[\"File\", [[\"Special\", [[\"Nested\", [[\"Super\", [\"Awesome\"]]]]]]]]], results);\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "test/modal": {
          "path": "test/modal",
          "content": "(function() {\n  var Modal;\n\n  PACKAGE.name = \"test\";\n\n  Modal = require(\"../main\").Modal;\n\n  describe(\"Modal\", function() {\n    return it(\"shoud be totally chill\", function() {\n      var called, element, handler;\n      element = document.createElement(\"p\");\n      called = false;\n      handler = function(value) {\n        called = true;\n        return assert.equal(value, \"yolo\");\n      };\n      Modal.show(element, handler);\n      Modal.hide('yolo');\n      return assert(called);\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "util": {
          "path": "util",
          "content": "(function() {\n  var A, F, Observable, S, accelerateItem, advance, asElement, elementView, empty, entityMap, formDataToObject, handle, isDescendant, o;\n\n  Observable = require(\"observable\");\n\n  A = function(attr) {\n    return function(x) {\n      return x[attr];\n    };\n  };\n\n  F = function(methodName) {\n    return function(x) {\n      return x[methodName]();\n    };\n  };\n\n  o = function(object, name) {\n    var attribute;\n    attribute = Observable(object[name]);\n    attribute.observe(function(newValue) {\n      return object[name] = newValue;\n    });\n    return attribute;\n  };\n\n  handle = function(fn) {\n    return function(e) {\n      if (e != null ? e.defaultPrevented : void 0) {\n        return;\n      }\n      if (e != null) {\n        e.preventDefault();\n      }\n      return fn.call(this, e);\n    };\n  };\n\n  S = function(object, method, defaultValue) {\n    return function() {\n      if (typeof (object != null ? object[method] : void 0) === 'function') {\n        return object[method]();\n      } else {\n        return defaultValue;\n      }\n    };\n  };\n\n  asElement = A('element');\n\n  accelerateItem = function(items, key) {\n    var acceleratedItem;\n    acceleratedItem = items.filter(function(item) {\n      return item.accelerator === key;\n    })[0];\n    if (acceleratedItem) {\n      return acceleratedItem.click();\n    }\n  };\n\n  isDescendant = function(element, ancestor) {\n    var parent;\n    if (!element) {\n      return;\n    }\n    while ((parent = element.parentElement)) {\n      if (element === ancestor) {\n        return true;\n      }\n      element = parent;\n    }\n  };\n\n  advance = function(list, amount) {\n    var activeItemIndex, currentItem;\n    currentItem = list.filter(function(item) {\n      return item.active();\n    })[0];\n    activeItemIndex = list.indexOf(currentItem) + amount;\n    if (activeItemIndex < 0) {\n      activeItemIndex = list.length - 1;\n    } else if (activeItemIndex >= list.length) {\n      activeItemIndex = 0;\n    }\n    return list[activeItemIndex];\n  };\n\n  formDataToObject = function(formData) {\n    return Array.from(formData.entries()).reduce(function(object, _arg) {\n      var key, value;\n      key = _arg[0], value = _arg[1];\n      object[key] = value;\n      return object;\n    }, {});\n  };\n\n  elementView = function(element) {\n    if (!element) {\n      return;\n    }\n    if (element.view) {\n      return element.view;\n    }\n    return elementView(element.parentElement);\n  };\n\n  empty = function(node) {\n    while (node.hasChildNodes()) {\n      node.removeChild(node.lastChild);\n    }\n    return node;\n  };\n\n  module.exports = {\n    htmlEscape: function(string) {\n      return String(string).replace(/[&<>\"'\\/]/g, function(s) {\n        return entityMap[s];\n      });\n    },\n    A: A,\n    F: F,\n    S: S,\n    o: o,\n    advance: advance,\n    asElement: asElement,\n    accelerateItem: accelerateItem,\n    elementView: elementView,\n    empty: empty,\n    formDataToObject: formDataToObject,\n    handle: handle,\n    isDescendant: isDescendant\n  };\n\n  entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/context-menu": {
          "path": "views/context-menu",
          "content": "\n/*\nContextMenu\n\nDisplay a context menu!\n\nQuestions:\n\nShould we be able to update the options in the menu after creation?\n */\n\n(function() {\n  var MenuView, Observable, isDescendant;\n\n  Observable = require(\"observable\");\n\n  MenuView = require(\"./menu\");\n\n  isDescendant = require(\"../util\").isDescendant;\n\n  module.exports = function(_arg) {\n    var activeItem, contextRoot, element, handlers, items, left, self, top;\n    items = _arg.items, handlers = _arg.handlers;\n    activeItem = Observable(null);\n    top = Observable(\"\");\n    left = Observable(\"\");\n    contextRoot = {\n      activeItem: activeItem,\n      handlers: handlers\n    };\n    self = MenuView({\n      items: items,\n      contextRoot: contextRoot,\n      classes: function() {\n        return [\"context\", \"options\"];\n      },\n      style: function() {\n        return \"top: \" + (top()) + \"px; left: \" + (left()) + \"px\";\n      }\n    });\n    element = self.element;\n    element.view = self;\n    self.contextRoot = contextRoot;\n    self.display = function(_arg1) {\n      var inElement, x, y;\n      inElement = _arg1.inElement, x = _arg1.x, y = _arg1.y;\n      top(y);\n      left(x);\n      (inElement || document.body).appendChild(element);\n      activeItem(self);\n      return element.focus();\n    };\n    document.addEventListener(\"mousedown\", function(e) {\n      if (!isDescendant(e.target, element)) {\n        return activeItem(null);\n      }\n    });\n    element.setAttribute(\"tabindex\", \"-1\");\n    element.addEventListener(\"keydown\", function(e) {\n      var currentItem, direction, key;\n      key = e.key;\n      switch (key) {\n        case \"ArrowLeft\":\n        case \"ArrowUp\":\n        case \"ArrowRight\":\n        case \"ArrowDown\":\n          e.preventDefault();\n          direction = key.replace(\"Arrow\", \"\");\n          currentItem = activeItem();\n          if (currentItem) {\n            return currentItem.cursor(direction);\n          }\n          break;\n        case \"Escape\":\n          return activeItem(null);\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/menu-bar": {
          "path": "views/menu-bar",
          "content": "(function() {\n  var MenuView, Observable, advance, isDescendant, _ref;\n\n  Observable = require(\"observable\");\n\n  MenuView = require(\"./menu\");\n\n  _ref = require(\"../util\"), isDescendant = _ref.isDescendant, advance = _ref.advance;\n\n  module.exports = function(_arg) {\n    var accelerateIfActive, acceleratorActive, activeItem, contextRoot, deactivate, element, handlers, items, previouslyFocusedElement, self;\n    items = _arg.items, handlers = _arg.handlers;\n    acceleratorActive = Observable(false);\n    activeItem = Observable(null);\n    previouslyFocusedElement = null;\n    contextRoot = {\n      activeItem: activeItem,\n      handlers: handlers\n    };\n    self = MenuView({\n      classes: function() {\n        return [\"bar\", acceleratorActive() ? \"accelerator-active\" : void 0];\n      },\n      items: items,\n      contextRoot: contextRoot\n    });\n    element = self.element;\n    self.cursor = function(direction) {\n      switch (direction) {\n        case \"Right\":\n          return self.advance(1);\n        case \"Left\":\n          return self.advance(-1);\n      }\n    };\n    self.items.forEach(function(item) {\n      item.horizontal = true;\n      return item.cursor = function(direction) {\n        var _ref1, _ref2;\n        console.log(\"Item\", direction);\n        if (direction === \"Down\") {\n          return (_ref1 = item.submenu) != null ? _ref1.advance(1) : void 0;\n        } else if (direction === \"Up\") {\n          return (_ref2 = item.submenu) != null ? _ref2.advance(-1) : void 0;\n        } else {\n          return item.parent.cursor(direction);\n        }\n      };\n    });\n    deactivate = function() {\n      activeItem(null);\n      acceleratorActive(false);\n      return previouslyFocusedElement != null ? previouslyFocusedElement.focus() : void 0;\n    };\n    document.addEventListener(\"mousedown\", function(e) {\n      if (!isDescendant(e.target, element)) {\n        acceleratorActive(false);\n        return activeItem(null);\n      }\n    });\n    document.addEventListener(\"keydown\", function(e) {\n      var key, menuIsActive, _ref1;\n      key = e.key;\n      switch (key) {\n        case \"Enter\":\n          return (_ref1 = activeItem()) != null ? _ref1.click() : void 0;\n        case \"Alt\":\n          menuIsActive = false;\n          if (acceleratorActive() || menuIsActive) {\n            return deactivate();\n          } else {\n            previouslyFocusedElement = document.activeElement;\n            element.focus();\n            if (!activeItem()) {\n              activeItem(self);\n            }\n            return acceleratorActive(true);\n          }\n      }\n    });\n    accelerateIfActive = function(key) {\n      var _ref1;\n      if (acceleratorActive()) {\n        return (_ref1 = activeItem()) != null ? _ref1.accelerate(key) : void 0;\n      }\n    };\n    element.setAttribute(\"tabindex\", \"-1\");\n    element.addEventListener(\"keydown\", function(e) {\n      var accelerated, currentItem, direction, key;\n      key = e.key;\n      switch (key) {\n        case \"ArrowLeft\":\n        case \"ArrowUp\":\n        case \"ArrowRight\":\n        case \"ArrowDown\":\n          e.preventDefault();\n          direction = key.replace(\"Arrow\", \"\");\n          currentItem = activeItem();\n          if (currentItem) {\n            return currentItem.cursor(direction);\n          }\n          break;\n        case \"Escape\":\n          return deactivate();\n        default:\n          accelerated = accelerateIfActive(key.toLowerCase());\n          if (accelerated != null) {\n            return e.preventDefault();\n          }\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/menu-item": {
          "path": "views/menu-item",
          "content": "(function() {\n  var F, MenuItemTemplate, S, accelerateItem, advance, asElement, formatAction, formatLabel, handle, htmlEscape, isDescendant, _ref;\n\n  _ref = require(\"../util\"), advance = _ref.advance, htmlEscape = _ref.htmlEscape, asElement = _ref.asElement, F = _ref.F, S = _ref.S, isDescendant = _ref.isDescendant, accelerateItem = _ref.accelerateItem, handle = _ref.handle;\n\n  MenuItemTemplate = require(\"../templates/menu-item\");\n\n  module.exports = function(_arg) {\n    var MenuView, accelerator, action, actionName, active, activeItem, click, content, contextRoot, disabled, element, handlers, hotkey, items, label, labelText, parent, self, submenu, title, _ref1, _ref2;\n    label = _arg.label, MenuView = _arg.MenuView, items = _arg.items, contextRoot = _arg.contextRoot, parent = _arg.parent;\n    self = {};\n    activeItem = contextRoot.activeItem, handlers = contextRoot.handlers;\n    active = function() {\n      var _ref1;\n      return isDescendant((_ref1 = activeItem()) != null ? _ref1.element : void 0, element);\n    };\n    self.active = active;\n    if (items) {\n      submenu = MenuView({\n        items: items,\n        contextRoot: contextRoot,\n        parent: self\n      });\n      content = submenu.element;\n    }\n    _ref1 = formatAction(label), labelText = _ref1[0], actionName = _ref1[1];\n    _ref2 = formatLabel(labelText), title = _ref2[0], accelerator = _ref2[1];\n    action = handlers[actionName];\n    disabled = S(action, \"disabled\", false);\n    hotkey = S(action, \"hotkey\", \"\");\n    click = function(e) {\n      if (disabled()) {\n        return;\n      }\n      if (e != null ? e.defaultPrevented : void 0) {\n        return;\n      }\n      if (e != null) {\n        e.preventDefault();\n      }\n      if (submenu) {\n        activeItem(submenu);\n        return;\n      }\n      console.log(\"Handling\", actionName);\n      if (action != null) {\n        if (typeof action.call === \"function\") {\n          action.call(handlers);\n        }\n      }\n      return activeItem(null);\n    };\n    element = MenuItemTemplate({\n      \"class\": function() {\n        return [items ? \"menu\" : void 0, active() ? \"active\" : void 0];\n      },\n      click: click,\n      mousemove: function(e) {\n        if (!activeItem()) {\n          return;\n        }\n        if (!e.defaultPrevented && isDescendant(e.target, element)) {\n          e.preventDefault();\n          return activeItem(self);\n        }\n      },\n      title: title,\n      content: content,\n      decoration: items ? \"\" : void 0,\n      hotkey: hotkey,\n      disabled: disabled\n    });\n    Object.assign(self, {\n      accelerator: accelerator,\n      accelerate: function(key) {\n        if (submenu) {\n          return submenu.accelerate(key);\n        } else {\n          return parent.accelerate(key);\n        }\n      },\n      click: click,\n      parent: parent,\n      element: element,\n      submenu: submenu,\n      cursor: function(direction) {\n        console.log(\"Item Cursor\", direction);\n        if (submenu && direction === \"Right\") {\n          return activeItem(submenu.navigableItems[0]);\n        } else if (parent.parent && direction === \"Left\") {\n          if (parent.parent.horizontal) {\n            return parent.parent.cursor(direction);\n          } else {\n            return activeItem(parent.parent);\n          }\n        } else {\n          return parent.cursor(direction);\n        }\n      }\n    });\n    return self;\n  };\n\n  formatAction = function(labelText) {\n    var action, title, _ref1;\n    _ref1 = labelText.split(\"->\").map(F(\"trim\")), title = _ref1[0], action = _ref1[1];\n    if (action == null) {\n      action = title.replace(/[^A-Za-z0-9]/g, \"\");\n    }\n    action = action.charAt(0).toLowerCase() + action.substring(1);\n    return [title, action];\n  };\n\n  formatLabel = function(labelText) {\n    var accelerator, span, titleHTML;\n    accelerator = void 0;\n    titleHTML = htmlEscape(labelText).replace(/\\[([^\\]]+)\\]/, function(match, $1) {\n      accelerator = $1.toLowerCase();\n      return \"<span class=\\\"accelerator\\\">\" + $1 + \"</span>\";\n    });\n    span = document.createElement(\"span\");\n    span.innerHTML = titleHTML;\n    return [span, accelerator];\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/menu-separator": {
          "path": "views/menu-separator",
          "content": "(function() {\n  var MenuSeparatorTemplate;\n\n  MenuSeparatorTemplate = require(\"../templates/menu-separator\");\n\n  module.exports = function() {\n    return {\n      element: MenuSeparatorTemplate(),\n      separator: true\n    };\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/menu": {
          "path": "views/menu",
          "content": "(function() {\n  var F, MenuItemTemplate, MenuItemView, MenuTemplate, MenuView, Observable, S, SeparatorView, accelerateItem, advance, asElement, assert, handle, htmlEscape, isDescendant, _ref;\n\n  Observable = require(\"observable\");\n\n  assert = require(\"../lib/assert\");\n\n  _ref = require(\"../util\"), advance = _ref.advance, accelerateItem = _ref.accelerateItem, asElement = _ref.asElement, F = _ref.F, S = _ref.S, htmlEscape = _ref.htmlEscape, handle = _ref.handle, isDescendant = _ref.isDescendant;\n\n  MenuTemplate = require(\"../templates/menu\");\n\n  MenuItemTemplate = require(\"../templates/menu-item\");\n\n  SeparatorView = require(\"./menu-separator\");\n\n  MenuItemView = require(\"./menu-item\");\n\n  module.exports = MenuView = function(_arg) {\n    var active, activeItem, classes, contextRoot, items, navigableItems, parent, self, style;\n    items = _arg.items, classes = _arg.classes, style = _arg.style, contextRoot = _arg.contextRoot, parent = _arg.parent;\n    self = {};\n    if (classes == null) {\n      classes = function() {\n        return [\"options\"];\n      };\n    }\n    activeItem = contextRoot.activeItem;\n    items = items.map(function(item) {\n      var label, submenuItems;\n      switch (false) {\n        case item !== \"-\":\n          return SeparatorView();\n        case !Array.isArray(item):\n          assert(item.length === 2);\n          label = item[0], submenuItems = item[1];\n          return MenuItemView({\n            label: label,\n            items: submenuItems,\n            MenuView: MenuView,\n            contextRoot: contextRoot,\n            parent: self\n          });\n        default:\n          return MenuItemView({\n            label: item,\n            contextRoot: contextRoot,\n            parent: self\n          });\n      }\n    });\n    navigableItems = items.filter(function(item) {\n      return !item.separator;\n    });\n    active = function() {\n      var _ref1;\n      return isDescendant((_ref1 = activeItem()) != null ? _ref1.element : void 0, self.element);\n    };\n    Object.assign(self, {\n      accelerate: function(key) {\n        return accelerateItem(items, key);\n      },\n      cursor: function(direction) {\n        var _ref1;\n        switch (direction) {\n          case \"Up\":\n            return self.advance(-1);\n          case \"Down\":\n            return self.advance(1);\n          default:\n            return (_ref1 = parent.parent) != null ? _ref1.cursor(direction) : void 0;\n        }\n      },\n      parent: parent,\n      items: items,\n      advance: function(n) {\n        return activeItem(advance(navigableItems, n));\n      },\n      navigableItems: navigableItems,\n      element: MenuTemplate({\n        style: style,\n        \"class\": function() {\n          return [active() ? \"active\" : void 0].concat(classes());\n        },\n        click: handle(function(e) {\n          return activeItem(self);\n        }),\n        items: items.map(asElement)\n      })\n    });\n    return self;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/progress": {
          "path": "views/progress",
          "content": "(function() {\n  var Observable, Template;\n\n  Template = require(\"../templates/progress\");\n\n  Observable = require(\"observable\");\n\n  module.exports = function(params) {\n    var element, max, message, value;\n    if (params == null) {\n      params = {};\n    }\n    value = params.value, max = params.max, message = params.message;\n    value = Observable(value || 0);\n    max = Observable(max);\n    message = Observable(message);\n    element = Template({\n      value: value,\n      max: max,\n      message: message\n    });\n    return {\n      element: element,\n      value: value,\n      message: message,\n      max: max\n    };\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/table": {
          "path": "views/table",
          "content": "(function() {\n  var TableTemplate, TableView, advanceRow, empty;\n\n  empty = require(\"../util\").empty;\n\n  TableTemplate = require(\"../templates/table\");\n\n  advanceRow = function(path, prev) {\n    var cellIndex, input, nextRowElement, td, tr;\n    td = path.filter(function(element) {\n      return element.tagName === \"TD\";\n    })[0];\n    if (!td) {\n      return;\n    }\n    tr = td.parentElement;\n    cellIndex = Array.prototype.indexOf.call(tr.children, td);\n    if (prev) {\n      nextRowElement = tr.previousSibling;\n    } else {\n      nextRowElement = tr.nextSibling;\n    }\n    if (nextRowElement) {\n      input = nextRowElement.children[cellIndex].querySelector('input');\n      return input != null ? input.focus() : void 0;\n    }\n  };\n\n  TableView = function(_arg) {\n    var RowElement, containerElement, data, filterAndSort, filterFn, headers, rowElements, tableBody, update;\n    data = _arg.data, headers = _arg.headers, RowElement = _arg.RowElement;\n    if (headers == null) {\n      headers = Object.keys(data[0]);\n    }\n    containerElement = TableTemplate({\n      headers: headers,\n      keydown: function(event) {\n        var key, path;\n        key = event.key, path = event.path;\n        switch (key) {\n          case \"Enter\":\n          case \"ArrowDown\":\n            event.preventDefault();\n            return advanceRow(path);\n          case \"ArrowUp\":\n            event.preventDefault();\n            return advanceRow(path, true);\n        }\n      }\n    });\n    tableBody = containerElement.querySelector('tbody');\n    filterFn = function(datum) {\n      return true;\n    };\n    filterAndSort = function(data, filterFn, sortFn) {\n      var filteredData;\n      if (filterFn == null) {\n        filterFn = function() {\n          return true;\n        };\n      }\n      filteredData = data.filter(filterFn);\n      if (sortFn) {\n        return filteredData.sort(sortFn);\n      } else {\n        return filteredData;\n      }\n    };\n    rowElements = function() {\n      return filterAndSort(data, filterFn, null).map(RowElement);\n    };\n    update = function() {\n      empty(tableBody);\n      return rowElements().forEach(function(element) {\n        return tableBody.appendChild(element);\n      });\n    };\n    update();\n    return {\n      element: containerElement,\n      render: update\n    };\n  };\n\n  module.exports = TableView;\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/window": {
          "path": "views/window",
          "content": "(function() {\n  var Bindable, Observable, WindowTemplate, activeDrag, activeResize, dragStart, elementView, frameGuard, raiseToTop, resizeInitial, resizeStart, styleBind, topIndex;\n\n  WindowTemplate = require(\"../templates/window\");\n\n  elementView = require(\"../util\").elementView;\n\n  frameGuard = document.createElement(\"frame-guard\");\n\n  document.body.appendChild(frameGuard);\n\n  topIndex = 0;\n\n  raiseToTop = function(view) {\n    var zIndex;\n    if (typeof view.zIndex !== 'function') {\n      return;\n    }\n    zIndex = view.zIndex();\n    if (zIndex === topIndex) {\n      return;\n    }\n    topIndex += 1;\n    return view.zIndex(topIndex);\n  };\n\n  activeDrag = null;\n\n  dragStart = null;\n\n  document.addEventListener(\"mousedown\", function(e) {\n    var target, view;\n    target = e.target;\n    view = elementView(target);\n    if (view) {\n      raiseToTop(view);\n    }\n    if (target.tagName === \"TITLE-BAR\") {\n      frameGuard.classList.add(\"active\");\n      dragStart = e;\n      return activeDrag = view;\n    }\n  });\n\n  document.addEventListener(\"mousemove\", function(e) {\n    var dx, dy, prevX, prevY, x, y;\n    if (activeDrag) {\n      prevX = dragStart.clientX, prevY = dragStart.clientY;\n      x = e.clientX, y = e.clientY;\n      dx = x - prevX;\n      dy = y - prevY;\n      activeDrag.x(activeDrag.x() + dx);\n      activeDrag.y(activeDrag.y() + dy);\n      return dragStart = e;\n    }\n  });\n\n  activeResize = null;\n\n  resizeStart = null;\n\n  resizeInitial = null;\n\n  document.addEventListener(\"mousedown\", function(e) {\n    var height, target, width, x, y, _ref;\n    target = e.target;\n    if (target.tagName === \"RESIZE\") {\n      frameGuard.classList.add(\"active\");\n      resizeStart = e;\n      activeResize = target;\n      _ref = elementView(activeResize), width = _ref.width, height = _ref.height, x = _ref.x, y = _ref.y;\n      return resizeInitial = {\n        width: width(),\n        height: height(),\n        x: x(),\n        y: y()\n      };\n    }\n  });\n\n  document.addEventListener(\"mousemove\", function(e) {\n    var actualDeltaX, actualDeltaY, dx, dy, height, startX, startY, view, width, x, y;\n    if (activeResize) {\n      startX = resizeStart.clientX, startY = resizeStart.clientY;\n      x = e.clientX, y = e.clientY;\n      dx = x - startX;\n      dy = y - startY;\n      width = resizeInitial.width;\n      height = resizeInitial.height;\n      if (activeResize.classList.contains(\"e\")) {\n        width += dx;\n      }\n      if (activeResize.classList.contains(\"w\")) {\n        width -= dx;\n      }\n      if (activeResize.classList.contains(\"s\")) {\n        height += dy;\n      }\n      if (activeResize.classList.contains(\"n\")) {\n        height -= dy;\n      }\n      width = Math.max(width, 200);\n      height = Math.max(height, 50);\n      actualDeltaX = width - resizeInitial.width;\n      actualDeltaY = height - resizeInitial.height;\n      view = elementView(activeResize);\n      if (activeResize.classList.contains(\"n\")) {\n        view.y(resizeInitial.y - actualDeltaY);\n      }\n      if (activeResize.classList.contains(\"w\")) {\n        view.x(resizeInitial.x - actualDeltaX);\n      }\n      view.width(width);\n      view.height(height);\n      return view.trigger(\"resize\");\n    }\n  });\n\n  document.addEventListener(\"mouseup\", function() {\n    activeDrag = null;\n    activeResize = null;\n    return frameGuard.classList.remove(\"active\");\n  });\n\n  Bindable = require(\"bindable\");\n\n  Observable = require(\"observable\");\n\n  module.exports = function(params) {\n    var element, height, self, title, width, x, y, zIndex, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n    self = Bindable();\n    x = Observable((_ref = params.x) != null ? _ref : 50);\n    y = Observable((_ref1 = params.y) != null ? _ref1 : 50);\n    width = Observable((_ref2 = params.width) != null ? _ref2 : 400);\n    height = Observable((_ref3 = params.height) != null ? _ref3 : 300);\n    title = Observable((_ref4 = params.title) != null ? _ref4 : \"Untitled\");\n    topIndex += 1;\n    zIndex = Observable((_ref5 = params.zIndex) != null ? _ref5 : topIndex);\n    element = WindowTemplate({\n      title: title,\n      menuBar: params.menuBar,\n      content: params.content,\n      close: function() {\n        return self.close();\n      }\n    });\n    styleBind(y, element, \"top\", \"px\");\n    styleBind(x, element, \"left\", \"px\");\n    styleBind(height, element, \"height\", \"px\");\n    styleBind(width, element, \"width\", \"px\");\n    styleBind(zIndex, element, \"zIndex\");\n    Object.assign(self, {\n      element: element,\n      title: title,\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      zIndex: zIndex,\n      close: function() {\n        return element.remove();\n      }\n    });\n    element.view = self;\n    return self;\n  };\n\n  styleBind = function(observable, element, attr, suffix) {\n    var update;\n    if (suffix == null) {\n      suffix = \"\";\n    }\n    update = function(newValue) {\n      newValue = parseInt(newValue);\n      if (newValue != null) {\n        return element.style[attr] = \"\" + newValue + suffix;\n      }\n    };\n    observable.observe(update);\n    return update(observable());\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "lib/hamlet-runtime": {
          "path": "lib/hamlet-runtime",
          "content": "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.HamletRuntime = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  \"use strict\";\n  var Observable, Runtime, bindEvent, bindObservable, bufferTo, classes, createElement, empty, eventNames, get, id, isEvent, isFragment, makeElement, observeAttribute, observeAttributes, observeContent, specialBindings, valueBind, valueIndexOf;\n\n  Observable = require(\"o_0\");\n\n  eventNames = \"abort\\nblur\\nchange\\nclick\\ncontextmenu\\ndblclick\\ndrag\\ndragend\\ndragenter\\ndragexit\\ndragleave\\ndragover\\ndragstart\\ndrop\\nerror\\nfocus\\ninput\\nkeydown\\nkeypress\\nkeyup\\nload\\nmousedown\\nmousemove\\nmouseout\\nmouseover\\nmouseup\\nreset\\nresize\\nscroll\\nselect\\nsubmit\\ntouchcancel\\ntouchend\\ntouchenter\\ntouchleave\\ntouchmove\\ntouchstart\\nunload\".split(\"\\n\");\n\n  isEvent = function(name) {\n    return eventNames.indexOf(name) !== -1;\n  };\n\n  isFragment = function(node) {\n    return (node != null ? node.nodeType : void 0) === 11;\n  };\n\n  valueBind = function(element, value, context) {\n    Observable(function() {\n      var update;\n      value = Observable(value, context);\n      switch (element.nodeName) {\n        case \"SELECT\":\n          element.oninput = element.onchange = function() {\n            var optionValue, _ref, _value;\n            _ref = this.children[this.selectedIndex], optionValue = _ref.value, _value = _ref._value;\n            return value(_value || optionValue);\n          };\n          update = function(newValue) {\n            var options;\n            element._value = newValue;\n            if ((options = element._options)) {\n              if (newValue.value != null) {\n                return element.value = (typeof newValue.value === \"function\" ? newValue.value() : void 0) || newValue.value;\n              } else {\n                return element.selectedIndex = valueIndexOf(options, newValue);\n              }\n            } else {\n              return element.value = newValue;\n            }\n          };\n          return bindObservable(element, value, context, update);\n        default:\n          element.oninput = element.onchange = function() {\n            return value(element.value);\n          };\n          if (typeof element.attachEvent === \"function\") {\n            element.attachEvent(\"onkeydown\", function() {\n              return setTimeout(function() {\n                return value(element.value);\n              }, 0);\n            });\n          }\n          return bindObservable(element, value, context, function(newValue) {\n            if (element.value !== newValue) {\n              return element.value = newValue;\n            }\n          });\n      }\n    });\n  };\n\n  specialBindings = {\n    INPUT: {\n      checked: function(element, value, context) {\n        element.onchange = function() {\n          return typeof value === \"function\" ? value(element.checked) : void 0;\n        };\n        return bindObservable(element, value, context, function(newValue) {\n          return element.checked = newValue;\n        });\n      }\n    },\n    SELECT: {\n      options: function(element, values, context) {\n        var updateValues;\n        values = Observable(values, context);\n        updateValues = function(values) {\n          empty(element);\n          element._options = values;\n          return values.map(function(value, index) {\n            var option, optionName, optionValue;\n            option = createElement(\"option\");\n            option._value = value;\n            if (typeof value === \"object\") {\n              optionValue = (value != null ? value.value : void 0) || index;\n            } else {\n              optionValue = value.toString();\n            }\n            bindObservable(option, optionValue, value, function(newValue) {\n              return option.value = newValue;\n            });\n            optionName = (value != null ? value.name : void 0) || value;\n            bindObservable(option, optionName, value, function(newValue) {\n              return option.textContent = option.innerText = newValue;\n            });\n            element.appendChild(option);\n            if (value === element._value) {\n              element.selectedIndex = index;\n            }\n            return option;\n          });\n        };\n        return bindObservable(element, values, context, updateValues);\n      }\n    }\n  };\n\n  observeAttribute = function(element, context, name, value) {\n    var binding, nodeName, _ref;\n    nodeName = element.nodeName;\n    if (name === \"value\") {\n      valueBind(element, value);\n    } else if (binding = (_ref = specialBindings[nodeName]) != null ? _ref[name] : void 0) {\n      binding(element, value, context);\n    } else if (name.match(/^on/) && isEvent(name.substr(2))) {\n      bindEvent(element, name, value, context);\n    } else if (isEvent(name)) {\n      bindEvent(element, \"on\" + name, value, context);\n    } else {\n      bindObservable(element, value, context, function(newValue) {\n        if ((newValue != null) && newValue !== false) {\n          return element.setAttribute(name, newValue);\n        } else {\n          return element.removeAttribute(name);\n        }\n      });\n    }\n    return element;\n  };\n\n  observeAttributes = function(element, context, attributes) {\n    return Object.keys(attributes).forEach(function(name) {\n      var value;\n      value = attributes[name];\n      return observeAttribute(element, context, name, value);\n    });\n  };\n\n  bindObservable = function(element, value, context, update) {\n    var observable, observe, unobserve;\n    observable = Observable(value, context);\n    observe = function() {\n      observable.observe(update);\n      return update(observable());\n    };\n    unobserve = function() {\n      return observable.stopObserving(update);\n    };\n    observe();\n    return element;\n  };\n\n  bindEvent = function(element, name, fn, context) {\n    return element[name] = function() {\n      return fn.apply(context, arguments);\n    };\n  };\n\n  id = function(element, context, sources) {\n    var lastId, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(newId) {\n      return element.id = newId;\n    };\n    lastId = function() {\n      return value.last();\n    };\n    return bindObservable(element, lastId, context, update);\n  };\n\n  classes = function(element, context, sources) {\n    var classNames, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(classNames) {\n      return element.className = classNames;\n    };\n    classNames = function() {\n      return value.join(\" \");\n    };\n    return bindObservable(element, classNames, context, update);\n  };\n\n  createElement = function(name) {\n    return document.createElement(name);\n  };\n\n  observeContent = function(element, context, contentFn) {\n    var append, contents, update;\n    contents = [];\n    contentFn.call(context, {\n      buffer: bufferTo(context, contents),\n      element: makeElement\n    });\n    append = function(item) {\n      if (item == null) {\n\n      } else if (typeof item === \"string\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"number\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"boolean\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item.each === \"function\") {\n        return item.each(append);\n      } else if (typeof item.forEach === \"function\") {\n        return item.forEach(append);\n      } else {\n        return element.appendChild(item);\n      }\n    };\n    update = function(contents) {\n      empty(element);\n      return contents.forEach(append);\n    };\n    return update(contents);\n  };\n\n  bufferTo = function(context, collection) {\n    return function(content) {\n      if (typeof content === 'function') {\n        content = Observable(content, context);\n      }\n      collection.push(content);\n      return content;\n    };\n  };\n\n  makeElement = function(name, context, attributes, fn) {\n    var element;\n    if (attributes == null) {\n      attributes = {};\n    }\n    element = createElement(name);\n    Observable(function() {\n      if (attributes.id != null) {\n        id(element, context, attributes.id);\n        return delete attributes.id;\n      }\n    });\n    Observable(function() {\n      if (attributes[\"class\"] != null) {\n        classes(element, context, attributes[\"class\"]);\n        return delete attributes[\"class\"];\n      }\n    });\n    Observable(function() {\n      return observeAttributes(element, context, attributes);\n    }, context);\n    if (element.nodeName !== \"SELECT\") {\n      Observable(function() {\n        return observeContent(element, context, fn);\n      }, context);\n    }\n    return element;\n  };\n\n  Runtime = function(context) {\n    var self;\n    self = {\n      buffer: function(content) {\n        if (self.root) {\n          throw \"Cannot have multiple root elements\";\n        }\n        return self.root = content;\n      },\n      element: makeElement,\n      filter: function(name, content) {}\n    };\n    return self;\n  };\n\n  Runtime.VERSION = require(\"../package.json\").version;\n\n  Runtime.Observable = Observable;\n\n  module.exports = Runtime;\n\n  empty = function(node) {\n    var child, _results;\n    _results = [];\n    while (child = node.firstChild) {\n      _results.push(node.removeChild(child));\n    }\n    return _results;\n  };\n\n  valueIndexOf = function(options, value) {\n    if (typeof value === \"object\") {\n      return options.indexOf(value);\n    } else {\n      return options.map(function(option) {\n        return option.toString();\n      }).indexOf(value.toString());\n    }\n  };\n\n  get = function(x) {\n    if (typeof x === 'function') {\n      return x();\n    } else {\n      return x;\n    }\n  };\n\n}).call(this);\n\n},{\"../package.json\":3,\"o_0\":2}],2:[function(require,module,exports){\n(function (global){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],3:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"hamlet.coffee\",\n  \"version\": \"0.7.6\",\n  \"description\": \"Truly amazing templating!\",\n  \"devDependencies\": {\n    \"browserify\": \"^12.0.1\",\n    \"coffee-script\": \"~1.7.1\",\n    \"jsdom\": \"^7.2.0\",\n    \"mocha\": \"^2.3.3\"\n  },\n  \"dependencies\": {\n    \"hamlet-compiler\": \"0.7.0\",\n    \"o_0\": \"0.3.8\"\n  },\n  \"homepage\": \"hamlet.coffee\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/dr-coffee-labs/hamlet.git\"\n  },\n  \"scripts\": {\n    \"prepublish\": \"script/prepublish\",\n    \"test\": \"script/test\"\n  },\n  \"files\": [\n    \"dist/\"\n  ],\n  \"main\": \"dist/runtime.js\"\n}\n\n},{}]},{},[1])(1)\n});",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "https://danielx.net/editor/"
      },
      "config": {
        "version": "0.1.2",
        "entryPoint": "main",
        "remoteDependencies": [],
        "dependencies": {
          "observable": "distri/observable:master",
          "bindable": "distri/bindable:master"
        }
      },
      "version": "0.1.2",
      "entryPoint": "main",
      "remoteDependencies": [],
      "repository": {
        "branch": "master",
        "default_branch": "master",
        "full_name": "STRd6/ui",
        "homepage": null,
        "description": "Classic User Interface",
        "html_url": "https://github.com/STRd6/ui",
        "url": "https://api.github.com/repos/STRd6/ui",
        "publishBranch": "gh-pages"
      },
      "dependencies": {
        "observable": {
          "source": {
            "LICENSE": {
              "path": "LICENSE",
              "content": "The MIT License (MIT)\n\nCopyright (c) 2014 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
              "mode": "100644",
              "type": "blob"
            },
            "README.md": {
              "path": "README.md",
              "content": "[![Build Status](https://travis-ci.org/distri/observable.svg?branch=npm)](https://travis-ci.org/distri/observable)\n\nObservable\n==========\n\nInstallation\n------------\n\nNode\n\n    npm install o_0\n\nUsage\n-----\n\n    Observable = require \"o_0\"\n\nGet notified when the value changes.\n\n    observable = Observable 5\n\n    observable() # 5\n\n    observable.observe (newValue) ->\n      console.log newValue\n\n    observable 10 # logs 10 to console\n\nArrays\n------\n\nProxy array methods.\n\n    observable = Observable [1, 2, 3]\n\n    observable.forEach (value) ->\n      # 1, 2, 3\n\nFunctions\n---------\n\nAutomagically compute dependencies for observable functions.\n\n    firstName = Observable \"Duder\"\n    lastName = Observable \"Man\"\n\n    o = Observable ->\n      \"#{firstName()} #{lastName()}\"\n\n    o.observe (newValue) ->\n      assert.equal newValue, \"Duder Bro\"\n\n    lastName \"Bro\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "main.coffee.md": {
              "path": "main.coffee.md",
              "content": "Observable\n==========\n\n`Observable` allows for observing arrays, functions, and objects.\n\nFunction dependencies are automagically observed.\n\nStandard array methods are proxied through to the underlying array.\n\n    module.exports = Observable = (value, context) ->\n\nReturn the object if it is already an observable object.\n\n      return value if typeof value?.observe is \"function\"\n\nMaintain a set of listeners to observe changes and provide a helper to notify each observer.\n\n      listeners = []\n\n      notify = (newValue) ->\n        copy(listeners).forEach (listener) ->\n          listener(newValue)\n\nOur observable function is stored as a reference to `self`.\n\nIf `value` is a function compute dependencies and listen to observables that it depends on.\n\n      if typeof value is 'function'\n        fn = value\n\nOur return function is a function that holds only a cached value which is updated\nwhen it's dependencies change.\n\nThe `magicDependency` call is so other functions can depend on this computed function the\nsame way we depend on other types of observables.\n\n        self = ->\n          # Automagic dependency observation\n          magicDependency(self)\n\n          return value\n\n        changed = ->\n          value = computeDependencies(self, fn, changed, context)\n          notify(value)\n\n        changed()\n\n      else\n\nWhen called with zero arguments it is treated as a getter. When called with one argument it is treated as a setter.\n\nChanges to the value will trigger notifications.\n\nThe value is always returned.\n\n        self = (newValue) ->\n          if arguments.length > 0\n            if value != newValue\n              value = newValue\n\n              notify(newValue)\n          else\n            # Automagic dependency observation\n            magicDependency(self)\n\n          return value\n\nThis `each` iterator is similar to [the Maybe monad](http://en.wikipedia.org/wiki/Monad_&#40;functional_programming&#41;#The_Maybe_monad) in that our observable may contain a single value or nothing at all.\n\n      self.each = (callback) ->\n        magicDependency(self)\n\n        if value?\n          [value].forEach (item) ->\n            callback.call(item, item)\n\n        return self\n\nIf the value is an array then proxy array methods and add notifications to mutation events.\n\n      if Array.isArray(value)\n        [\n          \"concat\"\n          \"every\"\n          \"filter\"\n          \"forEach\"\n          \"indexOf\"\n          \"join\"\n          \"lastIndexOf\"\n          \"map\"\n          \"reduce\"\n          \"reduceRight\"\n          \"slice\"\n          \"some\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            magicDependency(self)\n            value[method](args...)\n\n        [\n          \"pop\"\n          \"push\"\n          \"reverse\"\n          \"shift\"\n          \"splice\"\n          \"sort\"\n          \"unshift\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            notifyReturning value[method](args...)\n\n        # Provide length on a best effort basis because older browsers choke\n        if PROXY_LENGTH\n          Object.defineProperty self, 'length',\n            get: ->\n              magicDependency(self)\n              value.length\n            set: (length) ->\n              value.length = length\n              notifyReturning(value.length)\n\n        notifyReturning = (returnValue) ->\n          notify(value)\n\n          return returnValue\n\nAdd some extra helpful methods to array observables.\n\n        extend self,\n          each: (callback) ->\n            self.forEach (item, index) ->\n              callback.call(item, item, index, self)\n\n            return self\n\nRemove an element from the array and notify observers of changes.\n\n          remove: (object) ->\n            index = value.indexOf(object)\n\n            if index >= 0\n              notifyReturning value.splice(index, 1)[0]\n\n          get: (index) ->\n            magicDependency(self)\n            value[index]\n\n          first: ->\n            magicDependency(self)\n            value[0]\n\n          last: ->\n            magicDependency(self)\n            value[value.length-1]\n\n          size: ->\n            magicDependency(self)\n            value.length\n\n      extend self,\n        listeners: listeners\n\n        observe: (listener) ->\n          listeners.push listener\n\n        stopObserving: (fn) ->\n          remove listeners, fn\n\n        toggle: ->\n          self !value\n\n        increment: (n) ->\n          self value + n\n\n        decrement: (n) ->\n          self value - n\n\n        toString: ->\n          \"Observable(#{value})\"\n\n      return self\n\n    Observable.concat = ->\n      # Optimization: Manually copy arguments to an array\n      args = new Array(arguments.length)\n      for arg, i in arguments\n        args[i] = arguments[i]\n\n      collection = Observable(args)\n\n      o = Observable ->\n        flatten collection.map(splat)\n\n      o.push = collection.push\n\n      return o\n\nAppendix\n--------\n\nThe extend method adds one object's properties to another.\n\n    extend = (target) ->\n      # Optimization: iterate through arguments manually rather than pass to slice to create an array\n      for source, i in arguments\n        # The first argument is target, so skip it\n        if i > 0\n          for name of source\n            target[name] = source[name]\n\n      return target\n\nSuper hax for computing dependencies. This needs to be a shared global so that\ndifferent bundled versions of observable libraries can interoperate.\n\n    global.OBSERVABLE_ROOT_HACK = []\n\n    magicDependency = (self) ->\n      observerSet = last(global.OBSERVABLE_ROOT_HACK)\n      if observerSet\n        observerSet.add self\n\nOptimization: Keep the function containing the try-catch as small as possible.\n\n    tryCallWithFinallyPop = (fn, context) ->\n      try\n        fn.call(context)\n      finally\n        global.OBSERVABLE_ROOT_HACK.pop()\n\nAutomagically compute dependencies.\n\n    computeDependencies = (self, fn, update, context) ->\n      deps = new Set\n\n      global.OBSERVABLE_ROOT_HACK.push(deps)\n\n      value = tryCallWithFinallyPop fn, context\n\n      self._deps?.forEach (observable) ->\n        observable.stopObserving update\n\n      self._deps = deps\n\n      deps.forEach (observable) ->\n        observable.observe update\n\n      return value\n\nCheck if we can proxy function length property.\n\n    try\n      Object.defineProperty (->), 'length',\n        get: ->\n        set: ->\n\n      PROXY_LENGTH = true\n    catch\n      PROXY_LENGTH = false\n\nRemove a value from an array.\n\n    remove = (array, value) ->\n      index = array.indexOf(value)\n\n      if index >= 0\n        array.splice(index, 1)[0]\n\n    copy = (array) ->\n      array.concat([])\n\n    get = (arg) ->\n      if typeof arg is \"function\"\n        arg()\n      else\n        arg\n\n    splat = (item) ->\n      results = []\n\n      return results unless item?\n\n      if typeof item.forEach is \"function\"\n        item.forEach (i) ->\n          results.push i\n      else\n        result = get item\n\n        results.push result if result?\n\n      results\n\n    last = (array) ->\n      array[array.length - 1]\n\n    flatten = (array) ->\n      array.reduce (a, b) ->\n        a.concat(b)\n      , []\n",
              "mode": "100644",
              "type": "blob"
            },
            "pixie.cson": {
              "path": "pixie.cson",
              "content": "version: \"0.3.8\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "test/observable.coffee": {
              "path": "test/observable.coffee",
              "content": "global.Observable = require \"../main\"\n\ndescribe 'Observable', ->\n  it 'should create an observable for an object', ->\n    n = 5\n\n    observable = Observable(n)\n\n    assert.equal(observable(), n)\n\n  it 'should fire events when setting', ->\n    string = \"yolo\"\n\n    observable = Observable(string)\n    observable.observe (newValue) ->\n      assert.equal newValue, \"4life\"\n\n    observable(\"4life\")\n\n  it \"should not fire when setting to the same value\", ->\n    o = Observable 5\n\n    o.observe ->\n      assert false\n\n    o(5)\n\n  it 'should be idempotent', ->\n    o = Observable(5)\n\n    assert.equal o, Observable(o)\n\n  describe \"#each\", ->\n    it \"should be invoked once if there is an observable\", ->\n      o = Observable(5)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n        assert.equal value, 5\n\n      assert.equal called, 1\n\n    it \"should not be invoked if observable is null\", ->\n      o = Observable(null)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n\n      assert.equal called, 0\n\n    it \"should have the correct `this` scope for items\", (done) ->\n      o = Observable 5\n\n      o.each ->\n        assert.equal this, 5\n        done()\n\n    it \"should have the correct `this` scope for items in observable arrays\", ->\n      scopes = []\n\n      o = Observable [\"I'm\", \"an\", \"array\"]\n\n      o.each ->\n        scopes.push this\n\n      assert.equal scopes[0], \"I'm\"\n      assert.equal scopes[1], \"an\"\n      assert.equal scopes[2], \"array\"\n\n  it \"should allow for stopping observation\", ->\n    observable = Observable(\"string\")\n\n    called = 0\n    fn = (newValue) ->\n      called += 1\n      assert.equal newValue, \"4life\"\n\n    observable.observe fn\n\n    observable(\"4life\")\n\n    observable.stopObserving fn\n\n    observable(\"wat\")\n\n    assert.equal called, 1\n\n  it \"should increment\", ->\n    observable = Observable 1\n\n    observable.increment(5)\n\n    assert.equal observable(), 6\n\n  it \"should decremnet\", ->\n    observable = Observable 1\n\n    observable.decrement 5\n\n    assert.equal observable(), -4\n\n  it \"should toggle\", ->\n    observable = Observable false\n\n    observable.toggle()\n    assert.equal observable(), true\n\n    observable.toggle()\n    assert.equal observable(), false\n\n  it \"should trigger when toggling\", (done) ->\n    observable = Observable true\n    observable.observe (v) ->\n      assert.equal v, false\n      done()\n\n    observable.toggle()\n\n  it \"should have a nice toString\", ->\n    observable = Observable 5\n\n    assert.equal observable.toString(), \"Observable(5)\"\n\ndescribe \"Observable Array\", ->\n  it \"should proxy array methods\", ->\n    o = Observable [5]\n\n    o.map (n) ->\n      assert.equal n, 5\n\n  it \"should notify on mutation methods\", (done) ->\n    o = Observable []\n\n    o.observe (newValue) ->\n      assert.equal newValue[0], 1\n\n    o.push 1\n\n    done()\n\n  it \"should have an each method\", ->\n    o = Observable []\n\n    assert o.each\n\n  it \"#get\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.get(2), 2\n\n  it \"#first\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.first(), 0\n\n  it \"#last\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.last(), 3\n\n  it \"#remove\", (done) ->\n    o = Observable [0, 1, 2, 3]\n\n    o.observe (newValue) ->\n      assert.equal newValue.length, 3\n      setTimeout ->\n        done()\n      , 0\n\n    assert.equal o.remove(2), 2\n\n  it \"#remove non-existent element\", ->\n    o = Observable [1, 2, 3]\n\n    assert.equal o.remove(0), undefined\n\n  it \"should proxy the length property\", ->\n    o = Observable [1, 2, 3]\n\n    assert.equal o.length, 3\n\n    called = false\n    o.observe (value) ->\n      assert.equal value[0], 1\n      assert.equal value[1], undefined\n      called = true\n\n    o.length = 1\n    assert.equal o.length, 1\n    assert.equal called, true\n\n  it \"should auto detect conditionals of length as a dependency\", ->\n    observableArray = Observable [1, 2, 3]\n\n    o = Observable ->\n      if observableArray.length > 5\n        true\n      else\n        false\n\n    assert.equal o(), false\n\n    called = 0\n    o.observe ->\n      called += 1\n\n    observableArray.push 4, 5, 6\n\n    assert.equal called, 1\n\ndescribe \"Observable functions\", ->\n  it \"should compute dependencies\", (done) ->\n    firstName = Observable \"Duder\"\n    lastName = Observable \"Man\"\n\n    o = Observable ->\n      \"#{firstName()} #{lastName()}\"\n\n    o.observe (newValue) ->\n      assert.equal newValue, \"Duder Bro\"\n\n      done()\n\n    lastName \"Bro\"\n\n  it \"should compute array#get as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.get(0)\n\n    assert.equal observableFn(), 0\n\n    observableArray([5])\n\n    assert.equal observableFn(), 5\n\n  it \"should compute array#first as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.first() + 1\n\n    assert.equal observableFn(), 1\n\n    observableArray([5])\n\n    assert.equal observableFn(), 6\n\n  it \"should compute array#last as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.last()\n\n    assert.equal observableFn(), 2\n\n    observableArray.pop()\n\n    assert.equal observableFn(), 1\n\n    observableArray([5])\n\n    assert.equal observableFn(), 5\n\n  it \"should compute array#size as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.size() * 2\n\n    assert.equal observableFn(), 6\n\n    observableArray.pop()\n    assert.equal observableFn(), 4\n    observableArray.shift()\n    assert.equal observableFn(), 2\n\n  it \"should allow double nesting\", (done) ->\n    bottom = Observable \"rad\"\n    middle = Observable ->\n      bottom()\n    top = Observable ->\n      middle()\n\n    top.observe (newValue) ->\n      assert.equal newValue, \"wat\"\n      assert.equal top(), newValue\n      assert.equal middle(), newValue\n\n      done()\n\n    bottom(\"wat\")\n\n  it \"should work with dynamic dependencies\", ->\n    observableArray = Observable []\n\n    dynamicObservable = Observable ->\n      observableArray.filter (item) ->\n        item.age() > 3\n\n    assert.equal dynamicObservable().length, 0\n\n    observableArray.push\n      age: Observable 1\n\n    observableArray()[0].age 5\n    assert.equal dynamicObservable().length, 1\n\n  it \"should work with context\", ->\n    model =\n      a: Observable \"Hello\"\n      b: Observable \"there\"\n\n    model.c = Observable ->\n      \"#{@a()} #{@b()}\"\n    , model\n\n    assert.equal model.c(), \"Hello there\"\n\n    model.b \"world\"\n\n    assert.equal model.c(), \"Hello world\"\n\n  it \"should be ok even if the function throws an exception\", ->\n    assert.throws ->\n      t = Observable ->\n        throw \"wat\"\n\n    # TODO: Should be able to find a test case that is affected by this rather that\n    # checking it directly\n    assert.equal global.OBSERVABLE_ROOT_HACK.length, 0\n\n  it \"should have an each method\", ->\n    o = Observable ->\n\n    assert o.each()\n\n  it \"should not invoke when returning undefined\", ->\n    o = Observable ->\n\n    o.each ->\n      assert false\n\n  it \"should invoke when returning any defined value\", (done) ->\n    o = Observable -> 5\n\n    o.each (n) ->\n      assert.equal n, 5\n      done()\n\n  it \"should work on an array dependency\", ->\n    oA = Observable [1, 2, 3]\n\n    o = Observable ->\n      oA()[0]\n\n    last = Observable ->\n      oA()[oA().length-1]\n\n    assert.equal o(), 1\n\n    oA.unshift 0\n\n    assert.equal o(), 0\n\n    oA.push 4\n\n    assert.equal last(), 4, \"Last should be 4\"\n\n  it \"should work with multiple dependencies\", ->\n    letter = Observable \"A\"\n    checked = ->\n      l = letter()\n      @name().indexOf(l) is 0\n\n    first = {name: Observable(\"Andrew\")}\n    first.checked = Observable checked, first\n\n    second = {name: Observable(\"Benjamin\")}\n    second.checked = Observable checked, second\n\n    assert.equal first.checked(), true\n    assert.equal second.checked(), false\n\n    assert.equal letter.listeners.length, 2\n\n    letter \"B\"\n\n    assert.equal first.checked(), false\n    assert.equal second.checked(), true\n\n  it \"shouldn't double count dependencies\", ->\n    dep = Observable \"yo\"\n\n    o = Observable ->\n      dep()\n      dep()\n      dep()\n\n    count = 0\n    o.observe ->\n      count += 1\n\n    dep('heyy')\n\n    assert.equal count, 1\n\n  it \"should work with nested observable construction\", ->\n    gen = Observable ->\n      Observable \"Duder\"\n\n    o = gen()\n\n    assert.equal o(), \"Duder\"\n\n    o(\"wat\")\n\n    assert.equal o(), \"wat\"\n\n  describe \"Scoping\", ->\n    it \"should be scoped to optional context\", (done) ->\n      model =\n        firstName: Observable \"Duder\"\n        lastName: Observable \"Man\"\n\n      model.name = Observable ->\n        \"#{@firstName()} #{@lastName()}\"\n      , model\n\n      model.name.observe (newValue) ->\n        assert.equal newValue, \"Duder Bro\"\n\n        done()\n\n      model.lastName \"Bro\"\n\n  describe \"concat\", ->\n    it \"should work with a single observable\", ->\n      observable = Observable \"something\"\n      observableArray = Observable.concat observable\n      assert.equal observableArray.last(), \"something\"\n\n      observable \"something else\"\n      assert.equal observableArray.last(), \"something else\"\n\n    it \"should work with an undefined observable\", ->\n      observable = Observable undefined\n      observableArray = Observable.concat observable\n      assert.equal observableArray.size(), 0\n\n      observable \"defined\"\n      assert.equal observableArray.size(), 1\n\n    it \"should work with undefined\", ->\n      observableArray = Observable.concat undefined\n      assert.equal observableArray.size(), 0\n\n    it \"should work with []\", ->\n      observableArray = Observable.concat []\n      assert.equal observableArray.size(), 0\n\n    it \"should return an observable array that changes based on changes in inputs\", ->\n      numbers = Observable [1, 2, 3]\n      letters = Observable [\"a\", \"b\", \"c\"]\n      item = Observable({})\n      nullable = Observable null\n\n      observableArray = Observable.concat numbers, \"literal\", letters, item, nullable\n\n      assert.equal observableArray().length, 3 + 1 + 3 + 1\n\n      assert.equal observableArray()[0], 1\n      assert.equal observableArray()[3], \"literal\"\n      assert.equal observableArray()[4], \"a\"\n      assert.equal observableArray()[7], item()\n\n      numbers.push 4\n\n      assert.equal observableArray().length, 9\n\n      nullable \"cool\"\n\n      assert.equal observableArray().length, 10\n\n    it \"should work with observable functions that return arrays\", ->\n      item = Observable(\"wat\")\n\n      computedArray = Observable ->\n        [item()]\n\n      observableArray = Observable.concat computedArray, computedArray\n\n      assert.equal observableArray().length, 2\n\n      assert.equal observableArray()[1], \"wat\"\n\n      item \"yolo\"\n\n      assert.equal observableArray()[1], \"yolo\"\n\n    it \"should have a push method\", ->\n      observableArray = Observable.concat()\n\n      observable = Observable \"hey\"\n\n      observableArray.push observable\n\n      assert.equal observableArray()[0], \"hey\"\n\n      observable \"wat\"\n\n      assert.equal observableArray()[0], \"wat\"\n\n      observableArray.push \"cool\"\n      observableArray.push \"radical\"\n\n      assert.equal observableArray().length, 3\n\n    it \"should be observable\", (done) ->\n      observableArray = Observable.concat()\n\n      observableArray.observe (items) ->\n        assert.equal items.length, 3\n        done()\n\n      observableArray.push [\"A\", \"B\", \"C\"]\n\n    it \"should have an each method\", ->\n      observableArray = Observable.concat([\"A\", \"B\", \"C\"])\n\n      n = 0\n      observableArray.each () ->\n        n += 1\n\n      assert.equal n, 3\n\n  describe \"nesting dependencies\", ->\n    it \"should update the correct observable\", ->\n      a = Observable \"a\"\n      b = Observable \"b\"\n\n      results = Observable ->\n        r = Observable.concat()\n\n        r.push a\n        r.push b\n\n        r\n\n      # TODO: Should this just be\n      #     results.first()\n      assert.equal results().first(), \"a\"\n\n      a(\"newA\")\n\n      assert.equal results().first(), \"newA\"\n",
              "mode": "100644",
              "type": "blob"
            }
          },
          "distribution": {
            "main": {
              "path": "main",
              "content": "(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n",
              "type": "blob"
            },
            "pixie": {
              "path": "pixie",
              "content": "module.exports = {\"version\":\"0.3.8\"};",
              "type": "blob"
            },
            "test/observable": {
              "path": "test/observable",
              "content": "(function() {\n  global.Observable = require(\"../main\");\n\n  describe('Observable', function() {\n    it('should create an observable for an object', function() {\n      var n, observable;\n      n = 5;\n      observable = Observable(n);\n      return assert.equal(observable(), n);\n    });\n    it('should fire events when setting', function() {\n      var observable, string;\n      string = \"yolo\";\n      observable = Observable(string);\n      observable.observe(function(newValue) {\n        return assert.equal(newValue, \"4life\");\n      });\n      return observable(\"4life\");\n    });\n    it(\"should not fire when setting to the same value\", function() {\n      var o;\n      o = Observable(5);\n      o.observe(function() {\n        return assert(false);\n      });\n      return o(5);\n    });\n    it('should be idempotent', function() {\n      var o;\n      o = Observable(5);\n      return assert.equal(o, Observable(o));\n    });\n    describe(\"#each\", function() {\n      it(\"should be invoked once if there is an observable\", function() {\n        var called, o;\n        o = Observable(5);\n        called = 0;\n        o.each(function(value) {\n          called += 1;\n          return assert.equal(value, 5);\n        });\n        return assert.equal(called, 1);\n      });\n      it(\"should not be invoked if observable is null\", function() {\n        var called, o;\n        o = Observable(null);\n        called = 0;\n        o.each(function(value) {\n          return called += 1;\n        });\n        return assert.equal(called, 0);\n      });\n      it(\"should have the correct `this` scope for items\", function(done) {\n        var o;\n        o = Observable(5);\n        return o.each(function() {\n          assert.equal(this, 5);\n          return done();\n        });\n      });\n      return it(\"should have the correct `this` scope for items in observable arrays\", function() {\n        var o, scopes;\n        scopes = [];\n        o = Observable([\"I'm\", \"an\", \"array\"]);\n        o.each(function() {\n          return scopes.push(this);\n        });\n        assert.equal(scopes[0], \"I'm\");\n        assert.equal(scopes[1], \"an\");\n        return assert.equal(scopes[2], \"array\");\n      });\n    });\n    it(\"should allow for stopping observation\", function() {\n      var called, fn, observable;\n      observable = Observable(\"string\");\n      called = 0;\n      fn = function(newValue) {\n        called += 1;\n        return assert.equal(newValue, \"4life\");\n      };\n      observable.observe(fn);\n      observable(\"4life\");\n      observable.stopObserving(fn);\n      observable(\"wat\");\n      return assert.equal(called, 1);\n    });\n    it(\"should increment\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.increment(5);\n      return assert.equal(observable(), 6);\n    });\n    it(\"should decremnet\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.decrement(5);\n      return assert.equal(observable(), -4);\n    });\n    it(\"should toggle\", function() {\n      var observable;\n      observable = Observable(false);\n      observable.toggle();\n      assert.equal(observable(), true);\n      observable.toggle();\n      return assert.equal(observable(), false);\n    });\n    it(\"should trigger when toggling\", function(done) {\n      var observable;\n      observable = Observable(true);\n      observable.observe(function(v) {\n        assert.equal(v, false);\n        return done();\n      });\n      return observable.toggle();\n    });\n    return it(\"should have a nice toString\", function() {\n      var observable;\n      observable = Observable(5);\n      return assert.equal(observable.toString(), \"Observable(5)\");\n    });\n  });\n\n  describe(\"Observable Array\", function() {\n    it(\"should proxy array methods\", function() {\n      var o;\n      o = Observable([5]);\n      return o.map(function(n) {\n        return assert.equal(n, 5);\n      });\n    });\n    it(\"should notify on mutation methods\", function(done) {\n      var o;\n      o = Observable([]);\n      o.observe(function(newValue) {\n        return assert.equal(newValue[0], 1);\n      });\n      o.push(1);\n      return done();\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable([]);\n      return assert(o.each);\n    });\n    it(\"#get\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.get(2), 2);\n    });\n    it(\"#first\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.first(), 0);\n    });\n    it(\"#last\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.last(), 3);\n    });\n    it(\"#remove\", function(done) {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      o.observe(function(newValue) {\n        assert.equal(newValue.length, 3);\n        return setTimeout(function() {\n          return done();\n        }, 0);\n      });\n      return assert.equal(o.remove(2), 2);\n    });\n    it(\"#remove non-existent element\", function() {\n      var o;\n      o = Observable([1, 2, 3]);\n      return assert.equal(o.remove(0), void 0);\n    });\n    it(\"should proxy the length property\", function() {\n      var called, o;\n      o = Observable([1, 2, 3]);\n      assert.equal(o.length, 3);\n      called = false;\n      o.observe(function(value) {\n        assert.equal(value[0], 1);\n        assert.equal(value[1], void 0);\n        return called = true;\n      });\n      o.length = 1;\n      assert.equal(o.length, 1);\n      return assert.equal(called, true);\n    });\n    return it(\"should auto detect conditionals of length as a dependency\", function() {\n      var called, o, observableArray;\n      observableArray = Observable([1, 2, 3]);\n      o = Observable(function() {\n        if (observableArray.length > 5) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n      assert.equal(o(), false);\n      called = 0;\n      o.observe(function() {\n        return called += 1;\n      });\n      observableArray.push(4, 5, 6);\n      return assert.equal(called, 1);\n    });\n  });\n\n  describe(\"Observable functions\", function() {\n    it(\"should compute dependencies\", function(done) {\n      var firstName, lastName, o;\n      firstName = Observable(\"Duder\");\n      lastName = Observable(\"Man\");\n      o = Observable(function() {\n        return \"\" + (firstName()) + \" \" + (lastName());\n      });\n      o.observe(function(newValue) {\n        assert.equal(newValue, \"Duder Bro\");\n        return done();\n      });\n      return lastName(\"Bro\");\n    });\n    it(\"should compute array#get as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.get(0);\n      });\n      assert.equal(observableFn(), 0);\n      observableArray([5]);\n      return assert.equal(observableFn(), 5);\n    });\n    it(\"should compute array#first as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.first() + 1;\n      });\n      assert.equal(observableFn(), 1);\n      observableArray([5]);\n      return assert.equal(observableFn(), 6);\n    });\n    it(\"should compute array#last as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.last();\n      });\n      assert.equal(observableFn(), 2);\n      observableArray.pop();\n      assert.equal(observableFn(), 1);\n      observableArray([5]);\n      return assert.equal(observableFn(), 5);\n    });\n    it(\"should compute array#size as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.size() * 2;\n      });\n      assert.equal(observableFn(), 6);\n      observableArray.pop();\n      assert.equal(observableFn(), 4);\n      observableArray.shift();\n      return assert.equal(observableFn(), 2);\n    });\n    it(\"should allow double nesting\", function(done) {\n      var bottom, middle, top;\n      bottom = Observable(\"rad\");\n      middle = Observable(function() {\n        return bottom();\n      });\n      top = Observable(function() {\n        return middle();\n      });\n      top.observe(function(newValue) {\n        assert.equal(newValue, \"wat\");\n        assert.equal(top(), newValue);\n        assert.equal(middle(), newValue);\n        return done();\n      });\n      return bottom(\"wat\");\n    });\n    it(\"should work with dynamic dependencies\", function() {\n      var dynamicObservable, observableArray;\n      observableArray = Observable([]);\n      dynamicObservable = Observable(function() {\n        return observableArray.filter(function(item) {\n          return item.age() > 3;\n        });\n      });\n      assert.equal(dynamicObservable().length, 0);\n      observableArray.push({\n        age: Observable(1)\n      });\n      observableArray()[0].age(5);\n      return assert.equal(dynamicObservable().length, 1);\n    });\n    it(\"should work with context\", function() {\n      var model;\n      model = {\n        a: Observable(\"Hello\"),\n        b: Observable(\"there\")\n      };\n      model.c = Observable(function() {\n        return \"\" + (this.a()) + \" \" + (this.b());\n      }, model);\n      assert.equal(model.c(), \"Hello there\");\n      model.b(\"world\");\n      return assert.equal(model.c(), \"Hello world\");\n    });\n    it(\"should be ok even if the function throws an exception\", function() {\n      assert.throws(function() {\n        var t;\n        return t = Observable(function() {\n          throw \"wat\";\n        });\n      });\n      return assert.equal(global.OBSERVABLE_ROOT_HACK.length, 0);\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable(function() {});\n      return assert(o.each());\n    });\n    it(\"should not invoke when returning undefined\", function() {\n      var o;\n      o = Observable(function() {});\n      return o.each(function() {\n        return assert(false);\n      });\n    });\n    it(\"should invoke when returning any defined value\", function(done) {\n      var o;\n      o = Observable(function() {\n        return 5;\n      });\n      return o.each(function(n) {\n        assert.equal(n, 5);\n        return done();\n      });\n    });\n    it(\"should work on an array dependency\", function() {\n      var last, o, oA;\n      oA = Observable([1, 2, 3]);\n      o = Observable(function() {\n        return oA()[0];\n      });\n      last = Observable(function() {\n        return oA()[oA().length - 1];\n      });\n      assert.equal(o(), 1);\n      oA.unshift(0);\n      assert.equal(o(), 0);\n      oA.push(4);\n      return assert.equal(last(), 4, \"Last should be 4\");\n    });\n    it(\"should work with multiple dependencies\", function() {\n      var checked, first, letter, second;\n      letter = Observable(\"A\");\n      checked = function() {\n        var l;\n        l = letter();\n        return this.name().indexOf(l) === 0;\n      };\n      first = {\n        name: Observable(\"Andrew\")\n      };\n      first.checked = Observable(checked, first);\n      second = {\n        name: Observable(\"Benjamin\")\n      };\n      second.checked = Observable(checked, second);\n      assert.equal(first.checked(), true);\n      assert.equal(second.checked(), false);\n      assert.equal(letter.listeners.length, 2);\n      letter(\"B\");\n      assert.equal(first.checked(), false);\n      return assert.equal(second.checked(), true);\n    });\n    it(\"shouldn't double count dependencies\", function() {\n      var count, dep, o;\n      dep = Observable(\"yo\");\n      o = Observable(function() {\n        dep();\n        dep();\n        return dep();\n      });\n      count = 0;\n      o.observe(function() {\n        return count += 1;\n      });\n      dep('heyy');\n      return assert.equal(count, 1);\n    });\n    it(\"should work with nested observable construction\", function() {\n      var gen, o;\n      gen = Observable(function() {\n        return Observable(\"Duder\");\n      });\n      o = gen();\n      assert.equal(o(), \"Duder\");\n      o(\"wat\");\n      return assert.equal(o(), \"wat\");\n    });\n    describe(\"Scoping\", function() {\n      return it(\"should be scoped to optional context\", function(done) {\n        var model;\n        model = {\n          firstName: Observable(\"Duder\"),\n          lastName: Observable(\"Man\")\n        };\n        model.name = Observable(function() {\n          return \"\" + (this.firstName()) + \" \" + (this.lastName());\n        }, model);\n        model.name.observe(function(newValue) {\n          assert.equal(newValue, \"Duder Bro\");\n          return done();\n        });\n        return model.lastName(\"Bro\");\n      });\n    });\n    describe(\"concat\", function() {\n      it(\"should work with a single observable\", function() {\n        var observable, observableArray;\n        observable = Observable(\"something\");\n        observableArray = Observable.concat(observable);\n        assert.equal(observableArray.last(), \"something\");\n        observable(\"something else\");\n        return assert.equal(observableArray.last(), \"something else\");\n      });\n      it(\"should work with an undefined observable\", function() {\n        var observable, observableArray;\n        observable = Observable(void 0);\n        observableArray = Observable.concat(observable);\n        assert.equal(observableArray.size(), 0);\n        observable(\"defined\");\n        return assert.equal(observableArray.size(), 1);\n      });\n      it(\"should work with undefined\", function() {\n        var observableArray;\n        observableArray = Observable.concat(void 0);\n        return assert.equal(observableArray.size(), 0);\n      });\n      it(\"should work with []\", function() {\n        var observableArray;\n        observableArray = Observable.concat([]);\n        return assert.equal(observableArray.size(), 0);\n      });\n      it(\"should return an observable array that changes based on changes in inputs\", function() {\n        var item, letters, nullable, numbers, observableArray;\n        numbers = Observable([1, 2, 3]);\n        letters = Observable([\"a\", \"b\", \"c\"]);\n        item = Observable({});\n        nullable = Observable(null);\n        observableArray = Observable.concat(numbers, \"literal\", letters, item, nullable);\n        assert.equal(observableArray().length, 3 + 1 + 3 + 1);\n        assert.equal(observableArray()[0], 1);\n        assert.equal(observableArray()[3], \"literal\");\n        assert.equal(observableArray()[4], \"a\");\n        assert.equal(observableArray()[7], item());\n        numbers.push(4);\n        assert.equal(observableArray().length, 9);\n        nullable(\"cool\");\n        return assert.equal(observableArray().length, 10);\n      });\n      it(\"should work with observable functions that return arrays\", function() {\n        var computedArray, item, observableArray;\n        item = Observable(\"wat\");\n        computedArray = Observable(function() {\n          return [item()];\n        });\n        observableArray = Observable.concat(computedArray, computedArray);\n        assert.equal(observableArray().length, 2);\n        assert.equal(observableArray()[1], \"wat\");\n        item(\"yolo\");\n        return assert.equal(observableArray()[1], \"yolo\");\n      });\n      it(\"should have a push method\", function() {\n        var observable, observableArray;\n        observableArray = Observable.concat();\n        observable = Observable(\"hey\");\n        observableArray.push(observable);\n        assert.equal(observableArray()[0], \"hey\");\n        observable(\"wat\");\n        assert.equal(observableArray()[0], \"wat\");\n        observableArray.push(\"cool\");\n        observableArray.push(\"radical\");\n        return assert.equal(observableArray().length, 3);\n      });\n      it(\"should be observable\", function(done) {\n        var observableArray;\n        observableArray = Observable.concat();\n        observableArray.observe(function(items) {\n          assert.equal(items.length, 3);\n          return done();\n        });\n        return observableArray.push([\"A\", \"B\", \"C\"]);\n      });\n      return it(\"should have an each method\", function() {\n        var n, observableArray;\n        observableArray = Observable.concat([\"A\", \"B\", \"C\"]);\n        n = 0;\n        observableArray.each(function() {\n          return n += 1;\n        });\n        return assert.equal(n, 3);\n      });\n    });\n    return describe(\"nesting dependencies\", function() {\n      return it(\"should update the correct observable\", function() {\n        var a, b, results;\n        a = Observable(\"a\");\n        b = Observable(\"b\");\n        results = Observable(function() {\n          var r;\n          r = Observable.concat();\n          r.push(a);\n          r.push(b);\n          return r;\n        });\n        assert.equal(results().first(), \"a\");\n        a(\"newA\");\n        return assert.equal(results().first(), \"newA\");\n      });\n    });\n  });\n\n}).call(this);\n",
              "type": "blob"
            }
          },
          "progenitor": {
            "url": "https://danielx.net/editor/"
          },
          "config": {
            "version": "0.3.8"
          },
          "version": "0.3.8",
          "entryPoint": "main",
          "repository": {
            "branch": "master",
            "default_branch": "master",
            "full_name": "distri/observable",
            "homepage": "http://observable.us",
            "description": null,
            "html_url": "https://github.com/distri/observable",
            "url": "https://api.github.com/repos/distri/observable",
            "publishBranch": "gh-pages"
          },
          "dependencies": {}
        },
        "bindable": {
          "source": {
            "LICENSE": {
              "path": "LICENSE",
              "content": "The MIT License (MIT)\n\nCopyright (c) 2014 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
              "mode": "100644",
              "type": "blob"
            },
            "README.coffee.md": {
              "path": "README.coffee.md",
              "content": "Bindable\n========\n\nAdd event binding to objects.\n\n>     bindable = Bindable()\n>     bindable.on \"greet\", ->\n>       console.log \"yo!\"\n>     bindable.trigger \"greet\"\n>     #=> \"yo!\" is printed to log\n\nUse as a mixin.\n\n>    self.include Bindable\n\n    module.exports = (I={}, self={}) ->\n      eventCallbacks = {}\n\nAdds a function as an event listener.\n\nThis will call `coolEventHandler` after `yourObject.trigger \"someCustomEvent\"`\nis called.\n\n>     yourObject.on \"someCustomEvent\", coolEventHandler\n\nHandlers can be attached to namespaces as well. The namespaces are only used\nfor finer control of targeting event removal. For example if you are making a\ncustom drawing system you could unbind `\".Drawable\"` events and add your own.\n\n>     yourObject.on \"\"\n\n      self.on = (namespacedEvent, callback) ->\n        [event, namespace] = namespacedEvent.split(\".\")\n\n        # HACK: Here we annotate the callback function with namespace metadata\n        # This will probably lead to some strange edge cases, but should work fine\n        # for simple cases.\n        if namespace\n          callback.__PIXIE ||= {}\n          callback.__PIXIE[namespace] = true\n\n        eventCallbacks[event] ||= []\n        eventCallbacks[event].push(callback)\n\n        return self\n\nRemoves a specific event listener, or all event listeners if\nno specific listener is given.\n\nRemoves the handler coolEventHandler from the event `\"someCustomEvent\"` while\nleaving the other events intact.\n\n>     yourObject.off \"someCustomEvent\", coolEventHandler\n\nRemoves all handlers attached to `\"anotherCustomEvent\"`\n\n>     yourObject.off \"anotherCustomEvent\"\n\nRemove all handlers from the `\".Drawable\" namespace`\n\n>     yourObject.off \".Drawable\"\n\n      self.off = (namespacedEvent, callback) ->\n        [event, namespace] = namespacedEvent.split(\".\")\n\n        if event\n          eventCallbacks[event] ||= []\n\n          if namespace\n            # Select only the callbacks that do not have this namespace metadata\n            eventCallbacks[event] = eventCallbacks.filter (callback) ->\n              !callback.__PIXIE?[namespace]?\n\n          else\n            if callback\n              remove eventCallbacks[event], callback\n            else\n              eventCallbacks[event] = []\n        else if namespace\n          # No event given\n          # Select only the callbacks that do not have this namespace metadata\n          # for any events bound\n          for key, callbacks of eventCallbacks\n            eventCallbacks[key] = callbacks.filter (callback) ->\n              !callback.__PIXIE?[namespace]?\n\n        return self\n\nCalls all listeners attached to the specified event.\n\n>     # calls each event handler bound to \"someCustomEvent\"\n>     yourObject.trigger \"someCustomEvent\"\n\nAdditional parameters can be passed to the handlers.\n\n>     yourObject.trigger \"someEvent\", \"hello\", \"anotherParameter\"\n\n      self.trigger = (event, parameters...) ->\n        callbacks = eventCallbacks[event]\n\n        if callbacks\n          callbacks.forEach (callback) ->\n            callback.apply(self, parameters)\n\n        return self\n\n      return self\n\nHelpers\n-------\n\nRemove a value from an array.\n\n    remove = (array, value) ->\n      index = array.indexOf(value)\n\n      if index >= 0\n        array.splice(index, 1)[0]\n",
              "mode": "100644",
              "type": "blob"
            },
            "pixie.cson": {
              "path": "pixie.cson",
              "content": "entryPoint: \"README\"\nversion: \"0.2.0\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "test/bindable.coffee": {
              "path": "test/bindable.coffee",
              "content": "test = it\nok = assert\nequal = assert.equal\n\nBindable = require \"../README\"\n\ndescribe \"Bindable\", ->\n\n  test \"#bind and #trigger\", ->\n    o = Bindable()\n\n    o.on(\"test\", -> ok true)\n\n    o.trigger(\"test\")\n\n  test \"Multiple bindings\", ->\n    o = Bindable()\n\n    o.on(\"test\", -> ok true)\n    o.on(\"test\", -> ok true)\n\n    o.trigger(\"test\")\n\n  test \"#trigger arguments\", ->\n    o = Bindable()\n\n    param1 = \"the message\"\n    param2 = 3\n\n    o.on \"test\", (p1, p2) ->\n      equal(p1, param1)\n      equal(p2, param2)\n\n    o.trigger \"test\", param1, param2\n\n  test \"#unbind\", ->\n    o = Bindable()\n\n    callback = ->\n      ok false\n\n    o.on \"test\", callback\n    # Unbind specific event\n    o.off \"test\", callback\n    o.trigger \"test\"\n\n    o.on \"test\", callback\n    # Unbind all events\n    o.off \"test\"\n    o.trigger \"test\"\n\n  test \"#trigger namespace\", ->\n    o = Bindable()\n    o.on \"test.TestNamespace\", ->\n      ok true\n\n    o.trigger \"test\"\n\n    o.off \".TestNamespace\"\n    o.trigger \"test\"\n\n  test \"#unbind namespaced\", ->\n    o = Bindable()\n\n    o.on \"test.TestNamespace\", ->\n      ok true\n\n    o.trigger \"test\"\n\n    o.off \".TestNamespace\", ->\n    o.trigger \"test\"\n",
              "mode": "100644",
              "type": "blob"
            }
          },
          "distribution": {
            "README": {
              "path": "README",
              "content": "(function() {\n  var remove,\n    __slice = [].slice;\n\n  module.exports = function(I, self) {\n    var eventCallbacks;\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = {};\n    }\n    eventCallbacks = {};\n    self.on = function(namespacedEvent, callback) {\n      var event, namespace, _ref;\n      _ref = namespacedEvent.split(\".\"), event = _ref[0], namespace = _ref[1];\n      if (namespace) {\n        callback.__PIXIE || (callback.__PIXIE = {});\n        callback.__PIXIE[namespace] = true;\n      }\n      eventCallbacks[event] || (eventCallbacks[event] = []);\n      eventCallbacks[event].push(callback);\n      return self;\n    };\n    self.off = function(namespacedEvent, callback) {\n      var callbacks, event, key, namespace, _ref;\n      _ref = namespacedEvent.split(\".\"), event = _ref[0], namespace = _ref[1];\n      if (event) {\n        eventCallbacks[event] || (eventCallbacks[event] = []);\n        if (namespace) {\n          eventCallbacks[event] = eventCallbacks.filter(function(callback) {\n            var _ref1;\n            return ((_ref1 = callback.__PIXIE) != null ? _ref1[namespace] : void 0) == null;\n          });\n        } else {\n          if (callback) {\n            remove(eventCallbacks[event], callback);\n          } else {\n            eventCallbacks[event] = [];\n          }\n        }\n      } else if (namespace) {\n        for (key in eventCallbacks) {\n          callbacks = eventCallbacks[key];\n          eventCallbacks[key] = callbacks.filter(function(callback) {\n            var _ref1;\n            return ((_ref1 = callback.__PIXIE) != null ? _ref1[namespace] : void 0) == null;\n          });\n        }\n      }\n      return self;\n    };\n    self.trigger = function() {\n      var callbacks, event, parameters;\n      event = arguments[0], parameters = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      callbacks = eventCallbacks[event];\n      if (callbacks) {\n        callbacks.forEach(function(callback) {\n          return callback.apply(self, parameters);\n        });\n      }\n      return self;\n    };\n    return self;\n  };\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n}).call(this);\n",
              "type": "blob"
            },
            "pixie": {
              "path": "pixie",
              "content": "module.exports = {\"entryPoint\":\"README\",\"version\":\"0.2.0\"};",
              "type": "blob"
            },
            "test/bindable": {
              "path": "test/bindable",
              "content": "(function() {\n  var Bindable, equal, ok, test;\n\n  test = it;\n\n  ok = assert;\n\n  equal = assert.equal;\n\n  Bindable = require(\"../README\");\n\n  describe(\"Bindable\", function() {\n    test(\"#bind and #trigger\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test\", function() {\n        return ok(true);\n      });\n      return o.trigger(\"test\");\n    });\n    test(\"Multiple bindings\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test\", function() {\n        return ok(true);\n      });\n      o.on(\"test\", function() {\n        return ok(true);\n      });\n      return o.trigger(\"test\");\n    });\n    test(\"#trigger arguments\", function() {\n      var o, param1, param2;\n      o = Bindable();\n      param1 = \"the message\";\n      param2 = 3;\n      o.on(\"test\", function(p1, p2) {\n        equal(p1, param1);\n        return equal(p2, param2);\n      });\n      return o.trigger(\"test\", param1, param2);\n    });\n    test(\"#unbind\", function() {\n      var callback, o;\n      o = Bindable();\n      callback = function() {\n        return ok(false);\n      };\n      o.on(\"test\", callback);\n      o.off(\"test\", callback);\n      o.trigger(\"test\");\n      o.on(\"test\", callback);\n      o.off(\"test\");\n      return o.trigger(\"test\");\n    });\n    test(\"#trigger namespace\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test.TestNamespace\", function() {\n        return ok(true);\n      });\n      o.trigger(\"test\");\n      o.off(\".TestNamespace\");\n      return o.trigger(\"test\");\n    });\n    return test(\"#unbind namespaced\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test.TestNamespace\", function() {\n        return ok(true);\n      });\n      o.trigger(\"test\");\n      o.off(\".TestNamespace\", function() {});\n      return o.trigger(\"test\");\n    });\n  });\n\n}).call(this);\n",
              "type": "blob"
            }
          },
          "progenitor": {
            "url": "https://danielx.net/editor/"
          },
          "version": "0.2.0",
          "entryPoint": "README",
          "repository": {
            "branch": "master",
            "default_branch": "master",
            "full_name": "distri/bindable",
            "homepage": null,
            "description": "Event binding",
            "html_url": "https://github.com/distri/bindable",
            "url": "https://api.github.com/repos/distri/bindable",
            "publishBranch": "gh-pages"
          },
          "dependencies": {}
        }
      }
    }
  }
});